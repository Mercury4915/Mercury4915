<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RocketMQ高级功能+源码分析 | Mercury个人博客</title><meta name="author" content="Mercury"><meta name="copyright" content="Mercury"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 高级功能1.1 消息存储分布式队列因为有高可靠性的要求，所以数据要进行持久化存储。   消息生成者发送消息 MQ收到消息，将消息进行持久化，在存储中新增一条记录 返回ACK给生产者 MQ push 消息给对应的消费者，然后等待消费者返回ACK 如果消息消费者在指定时间内成功返回ack，那么MQ认为消息消费成功，在存储中删除消息，即执行第6步；如果MQ在指定时间内没有收到ACK，则认为消息消费">
<meta property="og:type" content="article">
<meta property="og:title" content="RocketMQ高级功能+源码分析">
<meta property="og:url" content="http://example.com/2023/06/20/blog20/index.html">
<meta property="og:site_name" content="Mercury个人博客">
<meta property="og:description" content="1. 高级功能1.1 消息存储分布式队列因为有高可靠性的要求，所以数据要进行持久化存储。   消息生成者发送消息 MQ收到消息，将消息进行持久化，在存储中新增一条记录 返回ACK给生产者 MQ push 消息给对应的消费者，然后等待消费者返回ACK 如果消息消费者在指定时间内成功返回ack，那么MQ认为消息消费成功，在存储中删除消息，即执行第6步；如果MQ在指定时间内没有收到ACK，则认为消息消费">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2023-06-20T12:42:35.000Z">
<meta property="article:modified_time" content="2023-06-20T12:43:43.190Z">
<meta property="article:author" content="Mercury">
<meta property="article:tag" content="消息队列">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/06/20/blog20/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RocketMQ高级功能+源码分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-20 20:43:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_top_img.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Mercury个人博客"><span class="site-name">Mercury个人博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RocketMQ高级功能+源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-20T12:42:35.000Z" title="发表于 2023-06-20 20:42:35">2023-06-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-20T12:43:43.190Z" title="更新于 2023-06-20 20:43:43">2023-06-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RocketMQ高级功能+源码分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-高级功能"><a href="#1-高级功能" class="headerlink" title="1. 高级功能"></a>1. 高级功能</h1><h2 id="1-1-消息存储"><a href="#1-1-消息存储" class="headerlink" title="1.1 消息存储"></a>1.1 消息存储</h2><p>分布式队列因为有高可靠性的要求，所以数据要进行持久化存储。</p>
<p><img src="/../imgs/blog20/%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.png"></p>
<ol>
<li>消息生成者发送消息</li>
<li>MQ收到消息，将消息进行持久化，在存储中新增一条记录</li>
<li>返回ACK给生产者</li>
<li>MQ push 消息给对应的消费者，然后等待消费者返回ACK</li>
<li>如果消息消费者在指定时间内成功返回ack，那么MQ认为消息消费成功，在存储中删除消息，即执行第6步；如果MQ在指定时间内没有收到ACK，则认为消息消费失败，会尝试重新push消息,重复执行4、5、6步骤</li>
<li>MQ删除消息</li>
</ol>
<h3 id="1-1-1-存储介质"><a href="#1-1-1-存储介质" class="headerlink" title="1.1.1 存储介质"></a>1.1.1 存储介质</h3><ul>
<li>关系型数据库DB</li>
</ul>
<p>Apache下开源的另外一款MQ—ActiveMQ（默认采用的KahaDB做消息存储）可选用JDBC的方式来做消息持久化，通过简单的xml配置信息即可实现JDBC消息存储。由于，普通关系型数据库（如Mysql）在单表数据量达到千万级别的情况下，其IO读写性能往往会出现瓶颈。在可靠性方面，该种方案非常依赖DB，如果一旦DB出现故障，则MQ的消息就无法落盘存储会导致线上故障</p>
<p><img src="/../imgs/blog20/MySQL.png"></p>
<ul>
<li><p>文件系统</p>
<p>目前业界较为常用的几款产品（RocketMQ&#x2F;Kafka&#x2F;RabbitMQ）均采用的是消息刷盘至所部署虚拟机&#x2F;物理机的文件系统来做持久化（刷盘一般可以分为异步刷盘和同步刷盘两种模式）。消息刷盘为消息存储提供了一种高效率、高可靠性和高性能的数据持久化方式。除非部署MQ机器本身或是本地磁盘挂了，否则一般是不会出现无法持久化的故障问题。</p>
<p><img src="/../imgs/blog20/%E7%A3%81%E7%9B%98.png"></p>
</li>
</ul>
<p>###1.1.2 性能对比</p>
<p>文件系统&gt;关系型数据库DB</p>
<h3 id="1-1-3-消息的存储和发送"><a href="#1-1-3-消息的存储和发送" class="headerlink" title="1.1.3 消息的存储和发送"></a>1.1.3 消息的存储和发送</h3><h4 id="1）消息存储"><a href="#1）消息存储" class="headerlink" title="1）消息存储"></a>1）消息存储</h4><p>磁盘如果使用得当，磁盘的速度完全可以匹配上网络 的数据传输速度。目前的高性能磁盘，顺序写速度可以达到600MB&#x2F;s， 超过了一般网卡的传输速度。但是磁盘随机写的速度只有大概100KB&#x2F;s，和顺序写的性能相差6000倍！因为有如此巨大的速度差别，好的消息队列系统会比普通的消息队列系统速度快多个数量级。RocketMQ的消息用顺序写,保证了消息存储的速度。</p>
<p>####2）消息发送</p>
<p>Linux操作系统分为【用户态】和【内核态】，文件操作、网络操作需要涉及这两种形态的切换，免不了进行数据复制。</p>
<p>一台服务器 把本机磁盘文件的内容发送到客户端，一般分为两个步骤：</p>
<p>1）read；读取本地文件内容； </p>
<p>2）write；将读取的内容通过网络发送出去。</p>
<p>这两个看似简单的操作，实际进行了4 次数据复制，分别是：</p>
<ol>
<li>从磁盘复制数据到内核态内存；</li>
<li>从内核态内存复 制到用户态内存；</li>
<li>然后从用户态 内存复制到网络驱动的内核态内存；</li>
<li>最后是从网络驱动的内核态内存复 制到网卡中进行传输。</li>
</ol>
<p><img src="/../imgs/blog20/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C.png">通过使用mmap的方式，可以省去向用户态的内存复制，提高速度。这种机制在Java中是通过MappedByteBuffer实现的</p>
<p>RocketMQ充分利用了上述特性，也就是所谓的“零拷贝”技术，提高消息存盘和网络发送的速度。</p>
<blockquote>
<p>这里需要注意的是，采用MappedByteBuffer这种内存映射的方式有几个限制，其中之一是一次只能映射1.5~2G 的文件至用户态的虚拟内存，这也是为何RocketMQ默认设置单个CommitLog日志数据文件为1G的原因了</p>
</blockquote>
<h3 id="1-1-4-消息存储结构"><a href="#1-1-4-消息存储结构" class="headerlink" title="1.1.4 消息存储结构"></a>1.1.4 消息存储结构</h3><p>RocketMQ消息的存储是由ConsumeQueue和CommitLog配合完成 的，消息真正的物理存储文件是CommitLog，ConsumeQueue是消息的逻辑队列，类似数据库的索引文件，存储的是指向物理存储的地址。每 个Topic下的每个Message Queue都有一个对应的ConsumeQueue文件。</p>
<p><img src="/../imgs/blog20/%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"></p>
<ul>
<li>CommitLog：存储消息的元数据</li>
<li>ConsumerQueue：存储消息在CommitLog的索引</li>
<li>IndexFile：为了消息查询提供了一种通过key或时间区间来查询消息的方法，这种通过IndexFile来查找消息的方法不影响发送与消费消息的主流程</li>
</ul>
<h3 id="1-1-5-刷盘机制"><a href="#1-1-5-刷盘机制" class="headerlink" title="1.1.5 刷盘机制"></a>1.1.5 刷盘机制</h3><p>RocketMQ的消息是存储到磁盘上的，这样既能保证断电后恢复， 又可以让存储的消息量超出内存的限制。RocketMQ为了提高性能，会尽可能地保证磁盘的顺序写。消息在通过Producer写入RocketMQ的时 候，有两种写磁盘方式，分布式同步刷盘和异步刷盘。</p>
<p><img src="/../imgs/blog20/%E5%90%8C%E6%AD%A5%E5%88%B7%E7%9B%98%E5%92%8C%E5%BC%82%E6%AD%A5%E5%88%B7%E7%9B%98.png"></p>
<h4 id="1）同步刷盘"><a href="#1）同步刷盘" class="headerlink" title="1）同步刷盘"></a>1）同步刷盘</h4><p>在返回写成功状态时，消息已经被写入磁盘。具体流程是，消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘， 然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写 成功的状态。</p>
<h4 id="2）异步刷盘"><a href="#2）异步刷盘" class="headerlink" title="2）异步刷盘"></a>2）异步刷盘</h4><p>在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入。</p>
<p>####3）配置</p>
<p><strong>同步刷盘还是异步刷盘，都是通过Broker配置文件里的flushDiskType 参数设置的，这个参数被配置成SYNC_FLUSH、ASYNC_FLUSH中的 一个。</strong></p>
<h2 id="1-2-高可用性机制"><a href="#1-2-高可用性机制" class="headerlink" title="1.2 高可用性机制"></a>1.2 高可用性机制</h2><p><img src="/../imgs/blog20/RocketMQ%E8%A7%92%E8%89%B2.jpg"></p>
<p>RocketMQ分布式集群是通过Master和Slave的配合达到高可用性的。</p>
<p>Master和Slave的区别：在Broker的配置文件中，参数 brokerId的值为0表明这个Broker是Master，大于0表明这个Broker是 Slave，同时brokerRole参数也会说明这个Broker是Master还是Slave。</p>
<p>Master角色的Broker支持读和写，Slave角色的Broker仅支持读，也就是 Producer只能和Master角色的Broker连接写入消息；Consumer可以连接 Master角色的Broker，也可以连接Slave角色的Broker来读取消息。</p>
<h3 id="1-2-1-消息消费高可用"><a href="#1-2-1-消息消费高可用" class="headerlink" title="1.2.1 消息消费高可用"></a>1.2.1 消息消费高可用</h3><p>在Consumer的配置文件中，并不需要设置是从Master读还是从Slave 读，当Master不可用或者繁忙的时候，Consumer会被自动切换到从Slave 读。有了自动切换Consumer这种机制，当一个Master角色的机器出现故障后，Consumer仍然可以从Slave读取消息，不影响Consumer程序。这就达到了消费端的高可用性。</p>
<h3 id="1-2-2-消息发送高可用"><a href="#1-2-2-消息发送高可用" class="headerlink" title="1.2.2 消息发送高可用"></a>1.2.2 消息发送高可用</h3><p>在创建Topic的时候，把Topic的多个Message Queue创建在多个Broker组上（相同Broker名称，不同 brokerId的机器组成一个Broker组），这样当一个Broker组的Master不可 用后，其他组的Master仍然可用，Producer仍然可以发送消息。 RocketMQ目前还不支持把Slave自动转成Master，如果机器资源不足， 需要把Slave转成Master，则要手动停止Slave角色的Broker，更改配置文 件，用新的配置文件启动Broker。</p>
<p><img src="/../imgs/blog20/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AE%BE%E8%AE%A1.jpg"></p>
<h3 id="1-2-3-消息主从复制"><a href="#1-2-3-消息主从复制" class="headerlink" title="1.2.3 消息主从复制"></a>1.2.3 消息主从复制</h3><p>如果一个Broker组有Master和Slave，消息需要从Master复制到Slave 上，有同步和异步两种复制方式。</p>
<p>####1）同步复制</p>
<p>同步复制方式是等Master和Slave均写 成功后才反馈给客户端写成功状态；</p>
<p>在同步复制方式下，如果Master出故障， Slave上有全部的备份数据，容易恢复，但是同步复制会增大数据写入 延迟，降低系统吞吐量。</p>
<p>####2）异步复制 </p>
<p>异步复制方式是只要Master写成功 即可反馈给客户端写成功状态。</p>
<p>在异步复制方式下，系统拥有较低的延迟和较高的吞吐量，但是如果Master出了故障，有些数据因为没有被写 入Slave，有可能会丢失；</p>
<p>####3）配置</p>
<p>同步复制和异步复制是通过Broker配置文件里的brokerRole参数进行设置的，这个参数可以被设置成ASYNC_MASTER、 SYNC_MASTER、SLAVE三个值中的一个。</p>
<p>####4）总结</p>
<p><img src="/../imgs/blog20/%E5%A4%8D%E5%88%B6%E5%88%B7%E7%9B%98.png"></p>
<p>实际应用中要结合业务场景，合理设置刷盘方式和主从复制方式， 尤其是SYNC_FLUSH方式，由于频繁地触发磁盘写动作，会明显降低 性能。通常情况下，应该把Master和Save配置成ASYNC_FLUSH的刷盘 方式，主从之间配置成SYNC_MASTER的复制方式，这样即使有一台 机器出故障，仍然能保证数据不丢，是个不错的选择。</p>
<h2 id="1-3-负载均衡"><a href="#1-3-负载均衡" class="headerlink" title="1.3 负载均衡"></a>1.3 负载均衡</h2><h3 id="1-3-1-Producer负载均衡"><a href="#1-3-1-Producer负载均衡" class="headerlink" title="1.3.1 Producer负载均衡"></a>1.3.1 Producer负载均衡</h3><p>Producer端，每个实例在发消息的时候，默认会轮询所有的message queue发送，以达到让消息平均落在不同的queue上。而由于queue可以散落在不同的broker，所以消息就发送到不同的broker下，如下图：</p>
<p><img src="/../imgs/blog20/producer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png"></p>
<p>图中箭头线条上的标号代表顺序，发布方会把第一条消息发送至 Queue 0，然后第二条消息发送至 Queue 1，以此类推。</p>
<h3 id="1-3-2-Consumer负载均衡"><a href="#1-3-2-Consumer负载均衡" class="headerlink" title="1.3.2 Consumer负载均衡"></a>1.3.2 Consumer负载均衡</h3><h4 id="1）集群模式"><a href="#1）集群模式" class="headerlink" title="1）集群模式"></a>1）集群模式</h4><p>在集群消费模式下，每条消息只需要投递到订阅这个topic的Consumer Group下的一个实例即可。RocketMQ采用主动拉取的方式拉取并消费消息，在拉取的时候需要明确指定拉取哪一条message queue。</p>
<p>而每当实例的数量有变更，都会触发一次所有实例的负载均衡，这时候会按照queue的数量和实例的数量平均分配queue给每个实例。</p>
<p>默认的分配算法是AllocateMessageQueueAveragely，如下图：</p>
<p><img src="/../imgs/blog20/consumer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png"></p>
<p>还有另外一种平均的算法是AllocateMessageQueueAveragelyByCircle，也是平均分摊每一条queue，只是以环状轮流分queue的形式，如下图：</p>
<p><img src="/../imgs/blog20/consumer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A12.png"></p>
<p>需要注意的是，集群模式下，queue都是只允许分配只一个实例，这是由于如果多个实例同时消费一个queue的消息，由于拉取哪些消息是consumer主动控制的，那样会导致同一个消息在不同的实例下被消费多次，所以算法上都是一个queue只分给一个consumer实例，一个consumer实例可以允许同时分到不同的queue。</p>
<p>通过增加consumer实例去分摊queue的消费，可以起到水平扩展的消费能力的作用。而有实例下线的时候，会重新触发负载均衡，这时候原来分配到的queue将分配到其他实例上继续消费。</p>
<p>但是如果consumer实例的数量比message queue的总数量还多的话，多出来的consumer实例将无法分到queue，也就无法消费到消息，也就无法起到分摊负载的作用了。所以需要控制让queue的总数量大于等于consumer的数量。</p>
<p>####2）广播模式</p>
<p>由于广播模式下要求一条消息需要投递到一个消费组下面所有的消费者实例，所以也就没有消息被分摊消费的说法。</p>
<p>在实现上，其中一个不同就是在consumer分配queue的时候，所有consumer都分到所有的queue。</p>
<p><img src="/../imgs/blog20/consumer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A13.png"></p>
<h2 id="1-4-消息重试"><a href="#1-4-消息重试" class="headerlink" title="1.4 消息重试"></a>1.4 消息重试</h2><h3 id="1-4-1-顺序消息的重试"><a href="#1-4-1-顺序消息的重试" class="headerlink" title="1.4.1 顺序消息的重试"></a>1.4.1 顺序消息的重试</h3><p>对于顺序消息，当消费者消费消息失败后，消息队列 RocketMQ 会自动不断进行消息重试（每次间隔时间为 1 秒），这时，应用会出现消息消费被阻塞的情况。因此，在使用顺序消息时，务必保证应用能够及时监控并处理消费失败的情况，避免阻塞现象的发生。</p>
<h3 id="1-4-2-无序消息的重试"><a href="#1-4-2-无序消息的重试" class="headerlink" title="1.4.2 无序消息的重试"></a>1.4.2 无序消息的重试</h3><p>对于无序消息（普通、定时、延时、事务消息），当消费者消费消息失败时，您可以通过设置返回状态达到消息重试的结果。</p>
<p>无序消息的重试只针对集群消费方式生效；广播方式不提供失败重试特性，即消费失败后，失败消息不再重试，继续消费新的消息。</p>
<h4 id="1）重试次数"><a href="#1）重试次数" class="headerlink" title="1）重试次数"></a>1）重试次数</h4><p>消息队列 RocketMQ 默认允许每条消息最多重试 16 次，每次重试的间隔时间如下：</p>
<table>
<thead>
<tr>
<th align="center">第几次重试</th>
<th align="center">与上次重试的间隔时间</th>
<th align="center">第几次重试</th>
<th align="center">与上次重试的间隔时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">10 秒</td>
<td align="center">9</td>
<td align="center">7 分钟</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">30 秒</td>
<td align="center">10</td>
<td align="center">8 分钟</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1 分钟</td>
<td align="center">11</td>
<td align="center">9 分钟</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">2 分钟</td>
<td align="center">12</td>
<td align="center">10 分钟</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">3 分钟</td>
<td align="center">13</td>
<td align="center">20 分钟</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">4 分钟</td>
<td align="center">14</td>
<td align="center">30 分钟</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">5 分钟</td>
<td align="center">15</td>
<td align="center">1 小时</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">6 分钟</td>
<td align="center">16</td>
<td align="center">2 小时</td>
</tr>
</tbody></table>
<p>如果消息重试 16 次后仍然失败，消息将不再投递。如果严格按照上述重试时间间隔计算，某条消息在一直消费失败的前提下，将会在接下来的 4 小时 46 分钟之内进行 16 次重试，超过这个时间范围消息将不再重试投递。</p>
<p><strong>注意：</strong> 一条消息无论重试多少次，这些重试消息的 Message ID 不会改变。</p>
<h4 id="2）配置方式"><a href="#2）配置方式" class="headerlink" title="2）配置方式"></a>2）配置方式</h4><p><strong>消费失败后，重试配置方式</strong></p>
<p>集群消费方式下，消息消费失败后期望消息重试，需要在消息监听器接口的实现中明确进行配置（三种方式任选一种）：</p>
<ul>
<li>返回 Action.ReconsumeLater （推荐）</li>
<li>返回 Null</li>
<li>抛出异常</li>
</ul>
<pre><code class="java">public class MessageListenerImpl implements MessageListener &#123;
    @Override
    public Action consume(Message message, ConsumeContext context) &#123;
        //处理消息
        doConsumeMessage(message);
        //方式1：返回 Action.ReconsumeLater，消息将重试
        return Action.ReconsumeLater;
        //方式2：返回 null，消息将重试
        return null;
        //方式3：直接抛出异常， 消息将重试
        throw new RuntimeException(&quot;Consumer Message exceotion&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>消费失败后，不重试配置方式</strong></p>
<p>集群消费方式下，消息失败后期望消息不重试，需要捕获消费逻辑中可能抛出的异常，最终返回 Action.CommitMessage，此后这条消息将不会再重试。</p>
<pre><code class="java">public class MessageListenerImpl implements MessageListener &#123;
    @Override
    public Action consume(Message message, ConsumeContext context) &#123;
        try &#123;
            doConsumeMessage(message);
        &#125; catch (Throwable e) &#123;
            //捕获消费逻辑中的所有异常，并返回 Action.CommitMessage;
            return Action.CommitMessage;
        &#125;
        //消息处理正常，直接返回 Action.CommitMessage;
        return Action.CommitMessage;
    &#125;
&#125;
</code></pre>
<p><strong>自定义消息最大重试次数</strong></p>
<p>消息队列 RocketMQ 允许 Consumer 启动的时候设置最大重试次数，重试时间间隔将按照如下策略：</p>
<ul>
<li>最大重试次数小于等于 16 次，则重试时间间隔同上表描述。</li>
<li>最大重试次数大于 16 次，超过 16 次的重试时间间隔均为每次 2 小时。</li>
</ul>
<pre><code class="java">Properties properties = new Properties();
//配置对应 Group ID 的最大消息重试次数为 20 次
properties.put(PropertyKeyConst.MaxReconsumeTimes,&quot;20&quot;);
Consumer consumer =ONSFactory.createConsumer(properties);
</code></pre>
<blockquote>
<p>注意：</p>
</blockquote>
<ul>
<li>消息最大重试次数的设置对相同 Group ID 下的所有 Consumer 实例有效。</li>
<li>如果只对相同 Group ID 下两个 Consumer 实例中的其中一个设置了 MaxReconsumeTimes，那么该配置对两个 Consumer 实例均生效。</li>
<li>配置采用覆盖的方式生效，即最后启动的 Consumer 实例会覆盖之前的启动实例的配置</li>
</ul>
<p><strong>获取消息重试次数</strong></p>
<p>消费者收到消息后，可按照如下方式获取消息的重试次数：</p>
<pre><code class="java">public class MessageListenerImpl implements MessageListener &#123;
    @Override
    public Action consume(Message message, ConsumeContext context) &#123;
        //获取消息的重试次数
        System.out.println(message.getReconsumeTimes());
        return Action.CommitMessage;
    &#125;
&#125;
</code></pre>
<h2 id="1-5-死信队列"><a href="#1-5-死信队列" class="headerlink" title="1.5 死信队列"></a>1.5 死信队列</h2><p>当一条消息初次消费失败，消息队列 RocketMQ 会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 RocketMQ 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</p>
<p>在消息队列 RocketMQ 中，这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。</p>
<h3 id="1-5-1-死信特性"><a href="#1-5-1-死信特性" class="headerlink" title="1.5.1 死信特性"></a>1.5.1 死信特性</h3><p>死信消息具有以下特性</p>
<ul>
<li>不会再被消费者正常消费。</li>
<li>有效期与正常消息相同，均为 3 天，3 天后会被自动删除。因此，请在死信消息产生后的 3 天内及时处理。</li>
</ul>
<p>死信队列具有以下特性：</p>
<ul>
<li>一个死信队列对应一个 Group ID， 而不是对应单个消费者实例。</li>
<li>如果一个 Group ID 未产生死信消息，消息队列 RocketMQ 不会为其创建相应的死信队列。</li>
<li>一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic。</li>
</ul>
<h3 id="1-5-2-查看死信信息"><a href="#1-5-2-查看死信信息" class="headerlink" title="1.5.2 查看死信信息"></a>1.5.2 查看死信信息</h3><ol>
<li>在控制台查询出现死信队列的主题信息</li>
</ol>
<p><img src="/../imgs/blog20/%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E4%B8%BB%E9%A2%98.png"></p>
<ol start="2">
<li>在消息界面根据主题查询死信消息</li>
</ol>
<p><img src="/../imgs/blog20/%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E4%B8%BB%E9%A2%982.png"></p>
<ol start="3">
<li>选择重新发送消息</li>
</ol>
<p>一条消息进入死信队列，意味着某些因素导致消费者无法正常消费该消息，因此，通常需要您对其进行特殊处理。排查可疑因素并解决问题后，可以在消息队列 RocketMQ 控制台重新发送该消息，让消费者重新消费一次。</p>
<h2 id="1-6-消费幂等"><a href="#1-6-消费幂等" class="headerlink" title="1.6 消费幂等"></a>1.6 消费幂等</h2><p>消息队列 RocketMQ 消费者在接收到消息以后，有必要根据业务上的唯一 Key 对消息做幂等处理的必要性。</p>
<h3 id="1-6-1-消费幂等的必要性"><a href="#1-6-1-消费幂等的必要性" class="headerlink" title="1.6.1 消费幂等的必要性"></a>1.6.1 消费幂等的必要性</h3><p>在互联网应用中，尤其在网络不稳定的情况下，消息队列 RocketMQ 的消息有可能会出现重复，这个重复简单可以概括为以下情况：</p>
<ul>
<li><p>发送时消息重复</p>
<p>当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或者客户端宕机，导致服务端对客户端应答失败。 如果此时生产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p>
</li>
<li><p>投递时消息重复</p>
<p>消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。 为了保证消息至少被消费一次，消息队列 RocketMQ 的服务端将在网络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p>
</li>
<li><p>负载均衡时消息重复（包括但不限于网络抖动、Broker 重启以及订阅方应用重启）</p>
<p>当消息队列 RocketMQ 的 Broker 或客户端重启、扩容或缩容时，会触发 Rebalance，此时消费者可能会收到重复消息。</p>
</li>
</ul>
<h3 id="1-6-2-处理方式"><a href="#1-6-2-处理方式" class="headerlink" title="1.6.2 处理方式"></a>1.6.2 处理方式</h3><p>因为 Message ID 有可能出现冲突（重复）的情况，所以真正安全的幂等处理，不建议以 Message ID 作为处理依据。 最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息 Key 进行设置：</p>
<pre><code class="java">Message message = new Message();
message.setKey(&quot;ORDERID_100&quot;);
SendResult sendResult = producer.send(message);
</code></pre>
<p>订阅方收到消息时可以根据消息的 Key 进行幂等处理：</p>
<pre><code class="java">consumer.subscribe(&quot;ons_test&quot;, &quot;*&quot;, new MessageListener() &#123;
    public Action consume(Message message, ConsumeContext context) &#123;
        String key = message.getKey()
        // 根据业务唯一标识的 key 做幂等处理
    &#125;
&#125;);
</code></pre>
<h1 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h1><h2 id="2-1-环境搭建"><a href="#2-1-环境搭建" class="headerlink" title="2.1 环境搭建"></a>2.1 环境搭建</h2><p>依赖工具</p>
<ul>
<li>JDK ：1.8+</li>
<li>Maven</li>
<li>IntelliJ IDEA</li>
</ul>
<h3 id="2-1-1-源码拉取"><a href="#2-1-1-源码拉取" class="headerlink" title="2.1.1 源码拉取"></a>2.1.1 源码拉取</h3><p>从官方仓库 <a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq">https://github.com/apache/rocketmq</a> <code>clone</code>或者<code>download</code>源码。</p>
<p><img src="/../imgs/blog20/%E6%BA%90%E7%A0%811.png"></p>
<p><strong>源码目录结构：</strong></p>
<ul>
<li><p>broker: broker 模块（broke 启动进程） </p>
</li>
<li><p>client ：消息客户端，包含消息生产者、消息消费者相关类 </p>
</li>
<li><p>common ：公共包 </p>
</li>
<li><p>dev ：开发者信息（非源代码） </p>
</li>
<li><p>distribution ：部署实例文件夹（非源代码） </p>
</li>
<li><p>example: RocketMQ 例代码 </p>
</li>
<li><p>filter ：消息过滤相关基础类</p>
</li>
<li><p>filtersrv：消息过滤服务器实现相关类（Filter启动进程）</p>
</li>
<li><p>logappender：日志实现相关类</p>
</li>
<li><p>namesrv：NameServer实现相关类（NameServer启动进程）</p>
</li>
<li><p>openmessageing：消息开放标准</p>
</li>
<li><p>remoting：远程通信模块，给予Netty</p>
</li>
<li><p>srcutil：服务工具类</p>
</li>
<li><p>store：消息存储实现相关类</p>
</li>
<li><p>style：checkstyle相关实现</p>
</li>
<li><p>test：测试相关类</p>
</li>
<li><p>tools：工具类，监控命令相关实现类</p>
</li>
</ul>
<p>###2.1.2 导入IDEA</p>
<p><img src="/../imgs/blog20/%E6%BA%90%E7%A0%812.png"></p>
<p><strong>执行安装</strong></p>
<pre><code class="sh">clean install -Dmaven.test.skip=true
</code></pre>
<h3 id="2-1-3-调试"><a href="#2-1-3-调试" class="headerlink" title="2.1.3 调试"></a>2.1.3 调试</h3><p>创建<code>conf</code>配置文件夹,从<code>distribution</code>拷贝<code>broker.conf</code>和<code>logback_broker.xml</code>和<code>logback_namesrv.xml</code></p>
<p><img src="/../imgs/blog20/%E6%BA%90%E7%A0%816.png"></p>
<h4 id="1）启动NameServer"><a href="#1）启动NameServer" class="headerlink" title="1）启动NameServer"></a>1）启动NameServer</h4><ul>
<li>展开namesrv模块，右键NamesrvStartup.java</li>
</ul>
<p><img src="/../imgs/blog20/%E6%BA%90%E7%A0%813.png"></p>
<ul>
<li>配置<strong>ROCKETMQ_HOME</strong></li>
</ul>
<p><img src="/../imgs/blog20/%E6%BA%90%E7%A0%814.png"></p>
<p><img src="/../imgs/blog20/%E6%BA%90%E7%A0%815.png"></p>
<ul>
<li><p>重新启动</p>
<p>控制台打印结果</p>
</li>
</ul>
<pre><code class="sh">The Name Server boot success. serializeType=JSON
</code></pre>
<h4 id="2）启动Broker"><a href="#2）启动Broker" class="headerlink" title="2）启动Broker"></a>2）启动Broker</h4><ul>
<li><code>broker.conf</code>配置文件内容</li>
</ul>
<pre><code class="properties">brokerClusterName = DefaultCluster
brokerName = broker-a
brokerId = 0
# namesrvAddr地址
namesrvAddr=127.0.0.1:9876
deleteWhen = 04
fileReservedTime = 48
brokerRole = ASYNC_MASTER
flushDiskType = ASYNC_FLUSH
autoCreateTopicEnable=true

# 存储路径
storePathRootDir=E:\\RocketMQ\\data\\rocketmq\\dataDir
# commitLog路径
storePathCommitLog=E:\\RocketMQ\\data\\rocketmq\\dataDir\\commitlog
# 消息队列存储路径
storePathConsumeQueue=E:\\RocketMQ\\data\\rocketmq\\dataDir\\consumequeue
# 消息索引存储路径
storePathIndex=E:\\RocketMQ\\data\\rocketmq\\dataDir\\index
# checkpoint文件路径
storeCheckpoint=E:\\RocketMQ\\data\\rocketmq\\dataDir\\checkpoint
# abort文件存储路径
abortFile=E:\\RocketMQ\\data\\rocketmq\\dataDir\\abort
</code></pre>
<ul>
<li>创建数据文件夹<code>dataDir</code></li>
<li>启动<code>BrokerStartup</code>,配置<code>broker.conf</code>和<code>ROCKETMQ_HOME</code></li>
</ul>
<p><img src="/../imgs/blog20/%E6%BA%90%E7%A0%817.png"></p>
<p><img src="/../imgs/blog20/%E6%BA%90%E7%A0%818.png"></p>
<p>####3）发送消息</p>
<ul>
<li>进入example模块的<code>org.apache.rocketmq.example.quickstart</code></li>
<li>指定Namesrv地址</li>
</ul>
<pre><code class="java">DefaultMQProducer producer = new DefaultMQProducer(&quot;please_rename_unique_group_name&quot;);
producer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);
</code></pre>
<ul>
<li>运行<code>main</code>方法，发送消息</li>
</ul>
<h4 id="4）消费消息"><a href="#4）消费消息" class="headerlink" title="4）消费消息"></a>4）消费消息</h4><ul>
<li>进入example模块的<code>org.apache.rocketmq.example.quickstart</code></li>
<li>指定Namesrv地址</li>
</ul>
<pre><code class="java">DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;please_rename_unique_group_name_4&quot;);
consumer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);
</code></pre>
<ul>
<li>运行<code>main</code>方法，消费消息</li>
</ul>
<h2 id="2-2-NameServer"><a href="#2-2-NameServer" class="headerlink" title="2.2 NameServer"></a>2.2 NameServer</h2><h3 id="2-2-1-架构设计"><a href="#2-2-1-架构设计" class="headerlink" title="2.2.1 架构设计"></a>2.2.1 架构设计</h3><p>消息中间件的设计思路一般是基于主题订阅发布的机制，消息生产者（Producer）发送某一个主题到消息服务器，消息服务器负责将消息持久化存储，消息消费者（Consumer）订阅该兴趣的主题，消息服务器根据订阅信息（路由信息）将消息推送到消费者（Push模式）或者消费者主动向消息服务器拉去（Pull模式），从而实现消息生产者与消息消费者解耦。为了避免消息服务器的单点故障导致的整个系统瘫痪，通常会部署多台消息服务器共同承担消息的存储。那消息生产者如何知道消息要发送到哪台消息服务器呢？如果某一台消息服务器宕机了，那么消息生产者如何在不重启服务情况下感知呢？</p>
<p>NameServer就是为了解决以上问题设计的。</p>
<p><img src="/../imgs/blog20/RocketMQ%E8%A7%92%E8%89%B2.jpg"></p>
<p>Broker消息服务器在启动的时向所有NameServer注册，消息生产者（Producer）在发送消息时之前先从NameServer获取Broker服务器地址列表，然后根据负载均衡算法从列表中选择一台服务器进行发送。NameServer与每台Broker保持长连接，并间隔30S检测Broker是否存活，如果检测到Broker宕机，则从路由注册表中删除。但是路由变化不会马上通知消息生产者。这样设计的目的是为了降低NameServer实现的复杂度，在消息发送端提供容错机制保证消息发送的可用性。</p>
<p>NameServer本身的高可用是通过部署多台NameServer来实现，但彼此之间不通讯，也就是NameServer服务器之间在某一个时刻的数据并不完全相同，但这对消息发送并不会造成任何影响，这也是NameServer设计的一个亮点，总之，RocketMQ设计追求简单高效。</p>
<h3 id="2-2-2-启动流程"><a href="#2-2-2-启动流程" class="headerlink" title="2.2.2 启动流程"></a>2.2.2 启动流程</h3><p><img src="/../imgs/blog20/NameServer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png"></p>
<p>启动类：<code>org.apache.rocketmq.namesrv.NamesrvStartup</code></p>
<p>####步骤一</p>
<p>解析配置文件，填充NameServerConfig、NettyServerConfig属性值，并创建NamesrvController</p>
<p><em><strong>代码：NamesrvController#createNamesrvController</strong></em></p>
<pre><code class="java">//创建NamesrvConfig
final NamesrvConfig namesrvConfig = new NamesrvConfig();
//创建NettyServerConfig
final NettyServerConfig nettyServerConfig = new NettyServerConfig();
//设置启动端口号
nettyServerConfig.setListenPort(9876);
//解析启动-c参数
if (commandLine.hasOption(&#39;c&#39;)) &#123;
    String file = commandLine.getOptionValue(&#39;c&#39;);
    if (file != null) &#123;
        InputStream in = new BufferedInputStream(new FileInputStream(file));
        properties = new Properties();
        properties.load(in);
        MixAll.properties2Object(properties, namesrvConfig);
        MixAll.properties2Object(properties, nettyServerConfig);

        namesrvConfig.setConfigStorePath(file);

        System.out.printf(&quot;load config properties file OK, %s%n&quot;, file);
        in.close();
    &#125;
&#125;
//解析启动-p参数
if (commandLine.hasOption(&#39;p&#39;)) &#123;
    InternalLogger console = InternalLoggerFactory.getLogger(LoggerName.NAMESRV_CONSOLE_NAME);
    MixAll.printObjectProperties(console, namesrvConfig);
    MixAll.printObjectProperties(console, nettyServerConfig);
    System.exit(0);
&#125;
//将启动参数填充到namesrvConfig,nettyServerConfig
MixAll.properties2Object(ServerUtil.commandLine2Properties(commandLine), namesrvConfig);

//创建NameServerController
final NamesrvController controller = new NamesrvController(namesrvConfig, nettyServerConfig);
</code></pre>
<p><u><strong>NamesrvConfig属性</strong></u></p>
<pre><code class="java">private String rocketmqHome = System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY, System.getenv(MixAll.ROCKETMQ_HOME_ENV));
private String kvConfigPath = System.getProperty(&quot;user.home&quot;) + File.separator + &quot;namesrv&quot; + File.separator + &quot;kvConfig.json&quot;;
private String configStorePath = System.getProperty(&quot;user.home&quot;) + File.separator + &quot;namesrv&quot; + File.separator + &quot;namesrv.properties&quot;;
private String productEnvName = &quot;center&quot;;
private boolean clusterTest = false;
private boolean orderMessageEnable = false;
</code></pre>
<p><strong>rocketmqHome：</strong>rocketmq主目录</p>
<p><strong>kvConfig：</strong>NameServer存储KV配置属性的持久化路径</p>
<p><strong>configStorePath：</strong>nameServer默认配置文件路径</p>
<p><strong>orderMessageEnable：</strong>是否支持顺序消息</p>
<p><u><strong>NettyServerConfig属性</strong></u></p>
<pre><code class="java">private int listenPort = 8888;
private int serverWorkerThreads = 8;
private int serverCallbackExecutorThreads = 0;
private int serverSelectorThreads = 3;
private int serverOnewaySemaphoreValue = 256;
private int serverAsyncSemaphoreValue = 64;
private int serverChannelMaxIdleTimeSeconds = 120;
private int serverSocketSndBufSize = NettySystemConfig.socketSndbufSize;
private int serverSocketRcvBufSize = NettySystemConfig.socketRcvbufSize;
private boolean serverPooledByteBufAllocatorEnable = true;
private boolean useEpollNativeSelector = false;
</code></pre>
<p><strong>listenPort：</strong>NameServer监听端口，该值默认会被初始化为9876<br><strong>serverWorkerThreads：</strong>Netty业务线程池线程个数<br><strong>serverCallbackExecutorThreads：</strong>Netty public任务线程池线程个数，Netty网络设计，根据业务类型会创建不同的线程池，比如处理消息发送、消息消费、心跳检测等。如果该业务类型未注册线程池，则由public线程池执行。<br><strong>serverSelectorThreads：</strong>IO线程池个数，主要是NameServer、Broker端解析请求、返回相应的线程个数，这类线程主要是处理网路请求的，解析请求包，然后转发到各个业务线程池完成具体的操作，然后将结果返回给调用方;<br><strong>serverOnewaySemaphoreValue：</strong>send oneway消息请求并发读（Broker端参数）;<br><strong>serverAsyncSemaphoreValue：</strong>异步消息发送最大并发度;<br><strong>serverChannelMaxIdleTimeSeconds ：</strong>网络连接最大的空闲时间，默认120s。<br><strong>serverSocketSndBufSize：</strong>网络socket发送缓冲区大小。<br><strong>serverSocketRcvBufSize：</strong> 网络接收端缓存区大小。<br><strong>serverPooledByteBufAllocatorEnable：</strong>ByteBuffer是否开启缓存;<br><strong>useEpollNativeSelector：</strong>是否启用Epoll IO模型。</p>
<h4 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h4><p>根据启动属性创建NamesrvController实例，并初始化该实例。NameServerController实例为NameServer核心控制器</p>
<p><em><strong>代码：NamesrvController#initialize</strong></em></p>
<pre><code class="java">public boolean initialize() &#123;
    //加载KV配置
    this.kvConfigManager.load();
    //创建NettyServer网络处理对象
    this.remotingServer = new NettyRemotingServer(this.nettyServerConfig, this.brokerHousekeepingService);
    //开启定时任务:每隔10s扫描一次Broker,移除不活跃的Broker
    this.remotingExecutor =
        Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), new ThreadFactoryImpl(&quot;RemotingExecutorThread_&quot;));
    this.registerProcessor();
    this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;
        @Override
        public void run() &#123;
            NamesrvController.this.routeInfoManager.scanNotActiveBroker();
        &#125;
    &#125;, 5, 10, TimeUnit.SECONDS);
    //开启定时任务:每隔10min打印一次KV配置
    this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;

        @Override
        public void run() &#123;
            NamesrvController.this.kvConfigManager.printAllPeriodically();
        &#125;
    &#125;, 1, 10, TimeUnit.MINUTES);
    return true;
&#125;
</code></pre>
<h4 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h4><p>在JVM进程关闭之前，先将线程池关闭，及时释放资源</p>
<p><em><strong>代码：NamesrvStartup#start</strong></em></p>
<pre><code class="java">//注册JVM钩子函数代码
Runtime.getRuntime().addShutdownHook(new ShutdownHookThread(log, new Callable&lt;Void&gt;() &#123;
    @Override
    public Void call() throws Exception &#123;
        //释放资源
        controller.shutdown();
        return null;
    &#125;
&#125;));
</code></pre>
<h3 id="2-2-3-路由管理"><a href="#2-2-3-路由管理" class="headerlink" title="2.2.3 路由管理"></a>2.2.3 路由管理</h3><p>NameServer的主要作用是为消息的生产者和消息消费者提供关于主题Topic的路由信息，那么NameServer需要存储路由的基础信息，还要管理Broker节点，包括路由注册、路由删除等。</p>
<h4 id="2-2-3-1-路由元信息"><a href="#2-2-3-1-路由元信息" class="headerlink" title="2.2.3.1 路由元信息"></a>2.2.3.1 路由元信息</h4><p><em><strong>代码：RouteInfoManager</strong></em></p>
<pre><code class="java">private final HashMap&lt;String/* topic */, List&lt;QueueData&gt;&gt; topicQueueTable;
private final HashMap&lt;String/* brokerName */, BrokerData&gt; brokerAddrTable;
private final HashMap&lt;String/* clusterName */, Set&lt;String/* brokerName */&gt;&gt; clusterAddrTable;
private final HashMap&lt;String/* brokerAddr */, BrokerLiveInfo&gt; brokerLiveTable;
private final HashMap&lt;String/* brokerAddr */, List&lt;String&gt;/* Filter Server */&gt; filterServerTable;
</code></pre>
<p><img src="/../imgs/blog20/%E8%B7%AF%E7%94%B1%E5%AE%9E%E4%BD%93%E5%9B%BE.png"></p>
<p><strong>topicQueueTable：</strong>Topic消息队列路由信息，消息发送时根据路由表进行负载均衡</p>
<p><strong>brokerAddrTable：</strong>Broker基础信息，包括brokerName、所属集群名称、主备Broker地址</p>
<p><strong>clusterAddrTable：</strong>Broker集群信息，存储集群中所有Broker名称</p>
<p><strong>brokerLiveTable：</strong>Broker状态信息，NameServer每次收到心跳包是会替换该信息</p>
<p><strong>filterServerTable：</strong>Broker上的FilterServer列表，用于类模式消息过滤。</p>
<blockquote>
<p>RocketMQ基于定于发布机制，一个Topic拥有多个消息队列，一个Broker为每一个主题创建4个读队列和4个写队列。多个Broker组成一个集群，集群由相同的多台Broker组成Master-Slave架构，brokerId为0代表Master，大于0为Slave。BrokerLiveInfo中的lastUpdateTimestamp存储上次收到Broker心跳包的时间。</p>
</blockquote>
<p><img src="/../imgs/blog20/%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE%E5%AE%9E%E4%BE%8B.png"></p>
<p><img src="/../imgs/blog20/%E5%AE%9E%E4%BD%93%E6%95%B0%E6%8D%AE%E5%AE%9E%E4%BE%8B2.png"></p>
<h4 id="2-2-3-2-路由注册"><a href="#2-2-3-2-路由注册" class="headerlink" title="2.2.3.2 路由注册"></a>2.2.3.2 路由注册</h4><p>#####1）发送心跳包</p>
<p><img src="/../imgs/blog20/%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%86%8C.png"></p>
<p>RocketMQ路由注册是通过Broker与NameServer的心跳功能实现的。Broker启动时向集群中所有的NameServer发送心跳信息，每隔30s向集群中所有NameServer发送心跳包，NameServer收到心跳包时会更新brokerLiveTable缓存中BrokerLiveInfo的lastUpdataTimeStamp信息，然后NameServer每隔10s扫描brokerLiveTable，如果连续120S没有收到心跳包，NameServer将移除Broker的路由信息同时关闭Socket连接。</p>
<p><em><strong>代码：BrokerController#start</strong></em></p>
<pre><code class="java">//注册Broker信息
this.registerBrokerAll(true, false, true);
//每隔30s上报Broker信息到NameServer
this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;

    @Override
    public void run() &#123;
        try &#123;
            BrokerController.this.registerBrokerAll(true, false, brokerConfig.isForceRegister());
        &#125; catch (Throwable e) &#123;
            log.error(&quot;registerBrokerAll Exception&quot;, e);
        &#125;
    &#125;
&#125;, 1000 * 10, Math.max(10000, Math.min(brokerConfig.getRegisterNameServerPeriod(), 60000)), 
                                                  TimeUnit.MILLISECONDS);
</code></pre>
<p><em><strong>代码：BrokerOuterAPI#registerBrokerAll</strong></em></p>
<pre><code class="java">//获得nameServer地址信息
List&lt;String&gt; nameServerAddressList = this.remotingClient.getNameServerAddressList();
//遍历所有nameserver列表
if (nameServerAddressList != null &amp;&amp; nameServerAddressList.size() &gt; 0) &#123;

    //封装请求头
    final RegisterBrokerRequestHeader requestHeader = new RegisterBrokerRequestHeader();
    requestHeader.setBrokerAddr(brokerAddr);
    requestHeader.setBrokerId(brokerId);
    requestHeader.setBrokerName(brokerName);
    requestHeader.setClusterName(clusterName);
    requestHeader.setHaServerAddr(haServerAddr);
    requestHeader.setCompressed(compressed);
    //封装请求体
    RegisterBrokerBody requestBody = new RegisterBrokerBody();
    requestBody.setTopicConfigSerializeWrapper(topicConfigWrapper);
    requestBody.setFilterServerList(filterServerList);
    final byte[] body = requestBody.encode(compressed);
    final int bodyCrc32 = UtilAll.crc32(body);
    requestHeader.setBodyCrc32(bodyCrc32);
    final CountDownLatch countDownLatch = new CountDownLatch(nameServerAddressList.size());
    for (final String namesrvAddr : nameServerAddressList) &#123;
        brokerOuterExecutor.execute(new Runnable() &#123;
            @Override
            public void run() &#123;
                try &#123;
                    //分别向NameServer注册
                    RegisterBrokerResult result = registerBroker(namesrvAddr,oneway, timeoutMills,requestHeader,body);
                    if (result != null) &#123;
                        registerBrokerResultList.add(result);
                    &#125;

                    log.info(&quot;register broker[&#123;&#125;]to name server &#123;&#125; OK&quot;, brokerId, namesrvAddr);
                &#125; catch (Exception e) &#123;
                    log.warn(&quot;registerBroker Exception, &#123;&#125;&quot;, namesrvAddr, e);
                &#125; finally &#123;
                    countDownLatch.countDown();
                &#125;
            &#125;
        &#125;);
    &#125;

    try &#123;
        countDownLatch.await(timeoutMills, TimeUnit.MILLISECONDS);
    &#125; catch (InterruptedException e) &#123;
    &#125;
&#125;
</code></pre>
<p><em><strong>代码：BrokerOutAPI#registerBroker</strong></em></p>
<pre><code class="java">if (oneway) &#123;
    try &#123;
        this.remotingClient.invokeOneway(namesrvAddr, request, timeoutMills);
    &#125; catch (RemotingTooMuchRequestException e) &#123;
        // Ignore
    &#125;
    return null;
&#125;
RemotingCommand response = this.remotingClient.invokeSync(namesrvAddr, request, timeoutMills);
</code></pre>
<h5 id="2）处理心跳包"><a href="#2）处理心跳包" class="headerlink" title="2）处理心跳包"></a>2）处理心跳包</h5><p><img src="/../imgs/blog20/NameServer%E5%A4%84%E7%90%86%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%86%8C.png"></p>
<p><code>org.apache.rocketmq.namesrv.processor.DefaultRequestProcessor</code>网路处理类解析请求类型，如果请求类型是为<em><strong>REGISTER_BROKER</strong></em>，则将请求转发到<code>RouteInfoManager#regiesterBroker</code></p>
<p><em><strong>代码：DefaultRequestProcessor#processRequest</strong></em></p>
<pre><code class="java">//判断是注册Broker信息
case RequestCode.REGISTER_BROKER:
    Version brokerVersion = MQVersion.value2Version(request.getVersion());
    if (brokerVersion.ordinal() &gt;= MQVersion.Version.V3_0_11.ordinal()) &#123;
        return this.registerBrokerWithFilterServer(ctx, request);
    &#125; else &#123;
        //注册Broker信息
        return this.registerBroker(ctx, request);
    &#125;
</code></pre>
<p><em><strong>代码：DefaultRequestProcessor#registerBroker</strong></em></p>
<pre><code class="java">RegisterBrokerResult result = this.namesrvController.getRouteInfoManager().registerBroker(
    requestHeader.getClusterName(),
    requestHeader.getBrokerAddr(),
    requestHeader.getBrokerName(),
    requestHeader.getBrokerId(),
    requestHeader.getHaServerAddr(),
    topicConfigWrapper,
    null,
    ctx.channel()
);
</code></pre>
<p><em><strong>代码：RouteInfoManager#registerBroker</strong></em></p>
<p>维护路由信息</p>
<pre><code class="java">//加锁
this.lock.writeLock().lockInterruptibly();
//维护clusterAddrTable
Set&lt;String&gt; brokerNames = this.clusterAddrTable.get(clusterName);
if (null == brokerNames) &#123;
    brokerNames = new HashSet&lt;String&gt;();
    this.clusterAddrTable.put(clusterName, brokerNames);
&#125;
brokerNames.add(brokerName);
</code></pre>
<pre><code class="java">//维护brokerAddrTable
BrokerData brokerData = this.brokerAddrTable.get(brokerName);
//第一次注册,则创建brokerData
if (null == brokerData) &#123;
    registerFirst = true;
    brokerData = new BrokerData(clusterName, brokerName, new HashMap&lt;Long, String&gt;());
    this.brokerAddrTable.put(brokerName, brokerData);
&#125;
//非第一次注册,更新Broker
Map&lt;Long, String&gt; brokerAddrsMap = brokerData.getBrokerAddrs();
Iterator&lt;Entry&lt;Long, String&gt;&gt; it = brokerAddrsMap.entrySet().iterator();
while (it.hasNext()) &#123;
    Entry&lt;Long, String&gt; item = it.next();
    if (null != brokerAddr &amp;&amp; brokerAddr.equals(item.getValue()) &amp;&amp; brokerId != item.getKey()) &#123;
        it.remove();
    &#125;
&#125;
String oldAddr = brokerData.getBrokerAddrs().put(brokerId, brokerAddr);
registerFirst = registerFirst || (null == oldAddr);
</code></pre>
<pre><code class="java">//维护topicQueueTable
if (null != topicConfigWrapper &amp;&amp; MixAll.MASTER_ID == brokerId) &#123;
    if (this.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion()) || 
        registerFirst) &#123;
        ConcurrentMap&lt;String, TopicConfig&gt; tcTable = topicConfigWrapper.getTopicConfigTable();
        if (tcTable != null) &#123;
            for (Map.Entry&lt;String, TopicConfig&gt; entry : tcTable.entrySet()) &#123;
                this.createAndUpdateQueueData(brokerName, entry.getValue());
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><em><strong>代码：RouteInfoManager#createAndUpdateQueueData</strong></em></p>
<pre><code class="java">private void createAndUpdateQueueData(final String brokerName, final TopicConfig topicConfig) &#123;
    //创建QueueData
    QueueData queueData = new QueueData();
    queueData.setBrokerName(brokerName);
    queueData.setWriteQueueNums(topicConfig.getWriteQueueNums());
    queueData.setReadQueueNums(topicConfig.getReadQueueNums());
    queueData.setPerm(topicConfig.getPerm());
    queueData.setTopicSynFlag(topicConfig.getTopicSysFlag());
    //获得topicQueueTable中队列集合
    List&lt;QueueData&gt; queueDataList = this.topicQueueTable.get(topicConfig.getTopicName());
    //topicQueueTable为空,则直接添加queueData到队列集合
    if (null == queueDataList) &#123;
        queueDataList = new LinkedList&lt;QueueData&gt;();
        queueDataList.add(queueData);
        this.topicQueueTable.put(topicConfig.getTopicName(), queueDataList);
        log.info(&quot;new topic registered, &#123;&#125; &#123;&#125;&quot;, topicConfig.getTopicName(), queueData);
    &#125; else &#123;
        //判断是否是新的队列
        boolean addNewOne = true;
        Iterator&lt;QueueData&gt; it = queueDataList.iterator();
        while (it.hasNext()) &#123;
            QueueData qd = it.next();
            //如果brokerName相同,代表不是新的队列
            if (qd.getBrokerName().equals(brokerName)) &#123;
                if (qd.equals(queueData)) &#123;
                    addNewOne = false;
            &#125; else &#123;
                        log.info(&quot;topic changed, &#123;&#125; OLD: &#123;&#125; NEW: &#123;&#125;&quot;, topicConfig.getTopicName(), qd,
                            queueData);
                        it.remove();
                    &#125;
                &#125;
            &#125;
        //如果是新的队列,则添加队列到queueDataList
        if (addNewOne) &#123;
            queueDataList.add(queueData);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">//维护brokerLiveTable
BrokerLiveInfo prevBrokerLiveInfo = this.brokerLiveTable.put(brokerAddr,new BrokerLiveInfo(
    System.currentTimeMillis(),
    topicConfigWrapper.getDataVersion(),
    channel,
    haServerAddr));
</code></pre>
<pre><code class="java">//维护filterServerList
if (filterServerList != null) &#123;
    if (filterServerList.isEmpty()) &#123;
        this.filterServerTable.remove(brokerAddr);
    &#125; else &#123;
        this.filterServerTable.put(brokerAddr, filterServerList);
    &#125;
&#125;

if (MixAll.MASTER_ID != brokerId) &#123;
    String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);
    if (masterAddr != null) &#123;
        BrokerLiveInfo brokerLiveInfo = this.brokerLiveTable.get(masterAddr);
        if (brokerLiveInfo != null) &#123;
            result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());
            result.setMasterAddr(masterAddr);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="2-2-3-3-路由删除"><a href="#2-2-3-3-路由删除" class="headerlink" title="2.2.3.3 路由删除"></a>2.2.3.3 路由删除</h4><p><code>Broker</code>每隔30s向<code>NameServer</code>发送一个心跳包，心跳包包含<code>BrokerId</code>，<code>Broker</code>地址，<code>Broker</code>名称，<code>Broker</code>所属集群名称、<code>Broker</code>关联的<code>FilterServer</code>列表。但是如果<code>Broker</code>宕机，<code>NameServer</code>无法收到心跳包，此时<code>NameServer</code>如何来剔除这些失效的<code>Broker</code>呢？<code>NameServer</code>会每隔10s扫描<code>brokerLiveTable</code>状态表，如果<code>BrokerLive</code>的<strong>lastUpdateTimestamp</strong>的时间戳距当前时间超过120s，则认为<code>Broker</code>失效，移除该<code>Broker</code>，关闭与<code>Broker</code>连接，同时更新<code>topicQueueTable</code>、<code>brokerAddrTable</code>、<code>brokerLiveTable</code>、<code>filterServerTable</code>。</p>
<p><strong>RocketMQ有两个触发点来删除路由信息</strong>：</p>
<ul>
<li>NameServer定期扫描brokerLiveTable检测上次心跳包与当前系统的时间差，如果时间超过120s，则需要移除broker。</li>
<li>Broker在正常关闭的情况下，会执行unregisterBroker指令</li>
</ul>
<p>这两种方式路由删除的方法都是一样的，就是从相关路由表中删除与该broker相关的信息。</p>
<p><img src="/../imgs/blog20/%E8%B7%AF%E7%94%B1%E5%88%A0%E9%99%A4.png"></p>
<p><em><strong>代码：NamesrvController#initialize</strong></em></p>
<pre><code class="java">//每隔10s扫描一次为活跃Broker
this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;

    @Override
    public void run() &#123;
        NamesrvController.this.routeInfoManager.scanNotActiveBroker();
    &#125;
&#125;, 5, 10, TimeUnit.SECONDS);
</code></pre>
<p><em><strong>代码：RouteInfoManager#scanNotActiveBroker</strong></em></p>
<pre><code class="java">public void scanNotActiveBroker() &#123;
    //获得brokerLiveTable
    Iterator&lt;Entry&lt;String, BrokerLiveInfo&gt;&gt; it = this.brokerLiveTable.entrySet().iterator();
    //遍历brokerLiveTable
    while (it.hasNext()) &#123;
        Entry&lt;String, BrokerLiveInfo&gt; next = it.next();
        long last = next.getValue().getLastUpdateTimestamp();
        //如果收到心跳包的时间距当时时间是否超过120s
        if ((last + BROKER_CHANNEL_EXPIRED_TIME) &lt; System.currentTimeMillis()) &#123;
            //关闭连接
            RemotingUtil.closeChannel(next.getValue().getChannel());
            //移除broker
            it.remove();
            //维护路由表
            this.onChannelDestroy(next.getKey(), next.getValue().getChannel());
        &#125;
    &#125;
&#125;
</code></pre>
<p><em><strong>代码：RouteInfoManager#onChannelDestroy</strong></em></p>
<pre><code class="java">//申请写锁,根据brokerAddress从brokerLiveTable和filterServerTable移除
this.lock.writeLock().lockInterruptibly();
this.brokerLiveTable.remove(brokerAddrFound);
this.filterServerTable.remove(brokerAddrFound);
</code></pre>
<pre><code class="java">//维护brokerAddrTable
String brokerNameFound = null;
boolean removeBrokerName = false;
Iterator&lt;Entry&lt;String, BrokerData&gt;&gt; itBrokerAddrTable =this.brokerAddrTable.entrySet().iterator();
//遍历brokerAddrTable
while (itBrokerAddrTable.hasNext() &amp;&amp; (null == brokerNameFound)) &#123;
    BrokerData brokerData = itBrokerAddrTable.next().getValue();
    //遍历broker地址
    Iterator&lt;Entry&lt;Long, String&gt;&gt; it = brokerData.getBrokerAddrs().entrySet().iterator();
    while (it.hasNext()) &#123;
        Entry&lt;Long, String&gt; entry = it.next();
        Long brokerId = entry.getKey();
        String brokerAddr = entry.getValue();
        //根据broker地址移除brokerAddr
        if (brokerAddr.equals(brokerAddrFound)) &#123;
            brokerNameFound = brokerData.getBrokerName();
            it.remove();
            log.info(&quot;remove brokerAddr[&#123;&#125;, &#123;&#125;] from brokerAddrTable, because channel destroyed&quot;,
                brokerId, brokerAddr);
            break;
        &#125;
    &#125;
    //如果当前主题只包含待移除的broker,则移除该topic
    if (brokerData.getBrokerAddrs().isEmpty()) &#123;
        removeBrokerName = true;
        itBrokerAddrTable.remove();
        log.info(&quot;remove brokerName[&#123;&#125;] from brokerAddrTable, because channel destroyed&quot;,
            brokerData.getBrokerName());
    &#125;
&#125;
</code></pre>
<pre><code class="java">//维护clusterAddrTable
if (brokerNameFound != null &amp;&amp; removeBrokerName) &#123;
    Iterator&lt;Entry&lt;String, Set&lt;String&gt;&gt;&gt; it = this.clusterAddrTable.entrySet().iterator();
    //遍历clusterAddrTable
    while (it.hasNext()) &#123;
        Entry&lt;String, Set&lt;String&gt;&gt; entry = it.next();
        //获得集群名称
        String clusterName = entry.getKey();
        //获得集群中brokerName集合
        Set&lt;String&gt; brokerNames = entry.getValue();
        //从brokerNames中移除brokerNameFound
        boolean removed = brokerNames.remove(brokerNameFound);
        if (removed) &#123;
            log.info(&quot;remove brokerName[&#123;&#125;], clusterName[&#123;&#125;] from clusterAddrTable, because channel destroyed&quot;,
                brokerNameFound, clusterName);

            if (brokerNames.isEmpty()) &#123;
                log.info(&quot;remove the clusterName[&#123;&#125;] from clusterAddrTable, because channel destroyed and no broker in this cluster&quot;,
                    clusterName);
                //如果集群中不包含任何broker,则移除该集群
                it.remove();
            &#125;

            break;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">//维护topicQueueTable队列
if (removeBrokerName) &#123;
    //遍历topicQueueTable
    Iterator&lt;Entry&lt;String, List&lt;QueueData&gt;&gt;&gt; itTopicQueueTable =
        this.topicQueueTable.entrySet().iterator();
    while (itTopicQueueTable.hasNext()) &#123;
        Entry&lt;String, List&lt;QueueData&gt;&gt; entry = itTopicQueueTable.next();
        //主题名称
        String topic = entry.getKey();
        //队列集合
        List&lt;QueueData&gt; queueDataList = entry.getValue();
        //遍历该主题队列
        Iterator&lt;QueueData&gt; itQueueData = queueDataList.iterator();
        while (itQueueData.hasNext()) &#123;
            //从队列中移除为活跃broker信息
            QueueData queueData = itQueueData.next();
            if (queueData.getBrokerName().equals(brokerNameFound)) &#123;
                itQueueData.remove();
                log.info(&quot;remove topic[&#123;&#125; &#123;&#125;], from topicQueueTable, because channel destroyed&quot;,
                    topic, queueData);
            &#125;
        &#125;
        //如果该topic的队列为空,则移除该topic
        if (queueDataList.isEmpty()) &#123;
            itTopicQueueTable.remove();
            log.info(&quot;remove topic[&#123;&#125;] all queue, from topicQueueTable, because channel destroyed&quot;,
                topic);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">//释放写锁
finally &#123;
    this.lock.writeLock().unlock();
&#125;
</code></pre>
<h4 id="2-2-3-4-路由发现"><a href="#2-2-3-4-路由发现" class="headerlink" title="2.2.3.4 路由发现"></a>2.2.3.4 路由发现</h4><p>RocketMQ路由发现是非实时的，当Topic路由出现变化后，NameServer不会主动推送给客户端，而是由客户端定时拉取主题最新的路由。</p>
<p><em><strong>代码：DefaultRequestProcessor#getRouteInfoByTopic</strong></em></p>
<pre><code class="java">public RemotingCommand getRouteInfoByTopic(ChannelHandlerContext ctx,
    RemotingCommand request) throws RemotingCommandException &#123;
    final RemotingCommand response = RemotingCommand.createResponseCommand(null);
    final GetRouteInfoRequestHeader requestHeader =
        (GetRouteInfoRequestHeader) request.decodeCommandCustomHeader(GetRouteInfoRequestHeader.class);
    //调用RouteInfoManager的方法,从路由表topicQueueTable、brokerAddrTable、filterServerTable中分别填充TopicRouteData的List&lt;QueueData&gt;、List&lt;BrokerData&gt;、filterServer
    TopicRouteData topicRouteData = this.namesrvController.getRouteInfoManager().pickupTopicRouteData(requestHeader.getTopic());
    //如果找到主题对应你的路由信息并且该主题为顺序消息，则从NameServer KVConfig中获取关于顺序消息相关的配置填充路由信息
    if (topicRouteData != null) &#123;
        if (this.namesrvController.getNamesrvConfig().isOrderMessageEnable()) &#123;
            String orderTopicConf =
                this.namesrvController.getKvConfigManager().getKVConfig(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG,
                    requestHeader.getTopic());
            topicRouteData.setOrderTopicConf(orderTopicConf);
        &#125;

        byte[] content = topicRouteData.encode();
        response.setBody(content);
        response.setCode(ResponseCode.SUCCESS);
        response.setRemark(null);
        return response;
    &#125;

    response.setCode(ResponseCode.TOPIC_NOT_EXIST);
    response.setRemark(&quot;No topic route info in name server for the topic: &quot; + requestHeader.getTopic()
        + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL));
    return response;
&#125;
</code></pre>
<h3 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4 小结"></a>2.2.4 小结</h3><p><img src="/../imgs/blog20/NameServer%E5%B0%8F%E7%BB%93.png"></p>
<h2 id="2-3-Producer"><a href="#2-3-Producer" class="headerlink" title="2.3 Producer"></a>2.3 Producer</h2><p>消息生产者的代码都在client模块中，相对于RocketMQ来讲，消息生产者就是客户端，也是消息的提供者。</p>
<p><img src="/../imgs/blog20/DefaultMQProducer%E7%B1%BB%E5%9B%BE.png"></p>
<p>###2.3.1 方法和属性</p>
<p>####1）主要方法介绍</p>
<p><img src="/../imgs/blog20/MQAdmin.png"></p>
<ul>
<li><pre><code class="java">//创建主题
void createTopic(final String key, final String newTopic, final int queueNum) throws MQClientException;
</code></pre>
</li>
<li><pre><code class="java">//根据时间戳从队列中查找消息偏移量
long searchOffset(final MessageQueue mq, final long timestamp)
</code></pre>
</li>
<li><pre><code class="java">//查找消息队列中最大的偏移量
long maxOffset(final MessageQueue mq) throws MQClientException;
</code></pre>
</li>
<li><pre><code class="java">//查找消息队列中最小的偏移量
long minOffset(final MessageQueue mq) 
</code></pre>
</li>
<li><pre><code class="java">//根据偏移量查找消息
MessageExt viewMessage(final String offsetMsgId) throws RemotingException, MQBrokerException,
        InterruptedException, MQClientException;
</code></pre>
</li>
<li><pre><code class="java">//根据条件查找消息
QueryResult queryMessage(final String topic, final String key, final int maxNum, final long begin,
        final long end) throws MQClientException, InterruptedException;
</code></pre>
</li>
<li><pre><code class="java">//根据消息ID和主题查找消息
MessageExt viewMessage(String topic,String msgId) throws RemotingException, MQBrokerException, InterruptedException, MQClientException;
</code></pre>
</li>
</ul>
<p><img src="/../imgs/blog20/MQProducer.png"></p>
<ul>
<li><pre><code class="java">//启动
void start() throws MQClientException;
</code></pre>
</li>
<li><pre><code class="java">//关闭
void shutdown();
</code></pre>
</li>
<li><pre><code class="java">//查找该主题下所有消息
List&lt;MessageQueue&gt; fetchPublishMessageQueues(final String topic) throws MQClientException;
</code></pre>
</li>
<li><pre><code class="java">//同步发送消息
SendResult send(final Message msg) throws MQClientException, RemotingException, MQBrokerException,
        InterruptedException;
</code></pre>
</li>
<li><pre><code class="java">//同步超时发送消息
SendResult send(final Message msg, final long timeout) throws MQClientException,
        RemotingException, MQBrokerException, InterruptedException;
</code></pre>
</li>
<li><pre><code class="java">//异步发送消息
void send(final Message msg, final SendCallback sendCallback) throws MQClientException,
        RemotingException, InterruptedException;
</code></pre>
</li>
<li><pre><code class="java">//异步超时发送消息
void send(final Message msg, final SendCallback sendCallback, final long timeout)
    throws MQClientException, RemotingException, InterruptedException;
</code></pre>
</li>
<li><pre><code class="java">//发送单向消息
void sendOneway(final Message msg) throws MQClientException, RemotingException,
    InterruptedException;
</code></pre>
</li>
<li><pre><code class="java">//选择指定队列同步发送消息
SendResult send(final Message msg, final MessageQueue mq) throws MQClientException,
    RemotingException, MQBrokerException, InterruptedException;
</code></pre>
</li>
<li><pre><code class="java">//选择指定队列异步发送消息
void send(final Message msg, final MessageQueue mq, final SendCallback sendCallback)
    throws MQClientException, RemotingException, InterruptedException;
</code></pre>
</li>
<li><pre><code class="java">//选择指定队列单项发送消息
void sendOneway(final Message msg, final MessageQueue mq) throws MQClientException,
    RemotingException, InterruptedException;
</code></pre>
</li>
<li><pre><code class="java">//批量发送消息
SendResult send(final Collection&lt;Message&gt; msgs) throws MQClientException, RemotingException, MQBrokerException,InterruptedException;
</code></pre>
</li>
</ul>
<p>####2）属性介绍</p>
<p><img src="/../imgs/blog20/DefaultMQProducer%E5%B1%9E%E6%80%A7.png"></p>
<pre><code class="java">producerGroup：生产者所属组
createTopicKey：默认Topic
defaultTopicQueueNums：默认主题在每一个Broker队列数量
sendMsgTimeout：发送消息默认超时时间，默认3s
compressMsgBodyOverHowmuch：消息体超过该值则启用压缩，默认4k
retryTimesWhenSendFailed：同步方式发送消息重试次数，默认为2，总共执行3次
retryTimesWhenSendAsyncFailed：异步方法发送消息重试次数，默认为2
retryAnotherBrokerWhenNotStoreOK：消息重试时选择另外一个Broker时，是否不等待存储结果就返回，默认为false
maxMessageSize：允许发送的最大消息长度，默认为4M
</code></pre>
<h3 id="2-3-2-启动流程"><a href="#2-3-2-启动流程" class="headerlink" title="2.3.2 启动流程"></a>2.3.2 启动流程</h3><p><img src="/../imgs/blog20/%E7%94%9F%E4%BA%A7%E8%80%85%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png"></p>
<p><em><strong>代码：DefaultMQProducerImpl#start</strong></em></p>
<pre><code class="java">//检查生产者组是否满足要求
this.checkConfig();
//更改当前instanceName为进程ID
if (!this.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;
    this.defaultMQProducer.changeInstanceNameToPID();
&#125;
//获得MQ客户端实例
this.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(this.defaultMQProducer, rpcHook);
</code></pre>
<blockquote>
<p>整个JVM中只存在一个MQClientManager实例，维护一个MQClientInstance缓存表</p>
<p>ConcurrentMap&lt;String&#x2F;* clientId *&#x2F;, MQClientInstance&gt; factoryTable &#x3D; new ConcurrentHashMap&lt;String,MQClientInstance&gt;();</p>
<p>同一个clientId只会创建一个MQClientInstance。</p>
<p>MQClientInstance封装了RocketMQ网络处理API，是消息生产者和消息消费者与NameServer、Broker打交道的网络通道</p>
</blockquote>
<p><em><strong>代码：MQClientManager#getAndCreateMQClientInstance</strong></em></p>
<pre><code class="java">public MQClientInstance getAndCreateMQClientInstance(final ClientConfig clientConfig, 
                                                     RPCHook rpcHook) &#123;
    //构建客户端ID
    String clientId = clientConfig.buildMQClientId();
    //根据客户端ID或者客户端实例
    MQClientInstance instance = this.factoryTable.get(clientId);
    //实例如果为空就创建新的实例,并添加到实例表中
    if (null == instance) &#123;
        instance =
            new MQClientInstance(clientConfig.cloneClientConfig(),
                this.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);
        MQClientInstance prev = this.factoryTable.putIfAbsent(clientId, instance);
        if (prev != null) &#123;
            instance = prev;
            log.warn(&quot;Returned Previous MQClientInstance for clientId:[&#123;&#125;]&quot;, clientId);
        &#125; else &#123;
            log.info(&quot;Created new MQClientInstance for clientId:[&#123;&#125;]&quot;, clientId);
        &#125;
    &#125;

    return instance;
&#125;
</code></pre>
<p><em><strong>代码：DefaultMQProducerImpl#start</strong></em></p>
<pre><code class="java">//注册当前生产者到到MQClientInstance管理中,方便后续调用网路请求
boolean registerOK = mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this);
if (!registerOK) &#123;
    this.serviceState = ServiceState.CREATE_JUST;
    throw new MQClientException(&quot;The producer group[&quot; + this.defaultMQProducer.getProducerGroup()
        + &quot;] has been created before, specify another name please.&quot; + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),
        null);
&#125;
//启动生产者
if (startFactory) &#123;
    mQClientFactory.start();
&#125;
</code></pre>
<h3 id="2-3-3-消息发送"><a href="#2-3-3-消息发送" class="headerlink" title="2.3.3 消息发送"></a>2.3.3 消息发送</h3><p><img src="/../imgs/blog20/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81.png"></p>
<p><em><strong>代码：DefaultMQProducerImpl#send(Message msg)</strong></em></p>
<pre><code class="java">//发送消息
public SendResult send(Message msg) &#123;
    return send(msg, this.defaultMQProducer.getSendMsgTimeout());
&#125;
</code></pre>
<p><em><strong>代码：DefaultMQProducerImpl#send(Message msg,long timeout)</strong></em></p>
<pre><code class="java">//发送消息,默认超时时间为3s
public SendResult send(Message msg,long timeout)&#123;
    return this.sendDefaultImpl(msg, CommunicationMode.SYNC, null, timeout);
&#125;
</code></pre>
<p><em><strong>代码：DefaultMQProducerImpl#sendDefaultImpl</strong></em></p>
<pre><code class="java">//校验消息
Validators.checkMessage(msg, this.defaultMQProducer);
</code></pre>
<p>####1）验证消息</p>
<p><em><strong>代码：Validators#checkMessage</strong></em></p>
<pre><code class="java">public static void checkMessage(Message msg, DefaultMQProducer defaultMQProducer)
    throws MQClientException &#123;
    //判断是否为空
    if (null == msg) &#123;
        throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL, &quot;the message is null&quot;);
    &#125;
    // 校验主题
    Validators.checkTopic(msg.getTopic());
        
    // 校验消息体
    if (null == msg.getBody()) &#123;
        throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL, &quot;the message body is null&quot;);
    &#125;

    if (0 == msg.getBody().length) &#123;
        throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL, &quot;the message body length is zero&quot;);
    &#125;

    if (msg.getBody().length &gt; defaultMQProducer.getMaxMessageSize()) &#123;
        throw new MQClientException(ResponseCode.MESSAGE_ILLEGAL,
            &quot;the message body size over max value, MAX: &quot; + defaultMQProducer.getMaxMessageSize());
    &#125;
&#125;
</code></pre>
<p>####2）查找路由</p>
<p><em><strong>代码：DefaultMQProducerImpl#tryToFindTopicPublishInfo</strong></em></p>
<pre><code class="java">private TopicPublishInfo tryToFindTopicPublishInfo(final String topic) &#123;
    //从缓存中获得主题的路由信息
    TopicPublishInfo topicPublishInfo = this.topicPublishInfoTable.get(topic);
    //路由信息为空,则从NameServer获取路由
    if (null == topicPublishInfo || !topicPublishInfo.ok()) &#123;
        this.topicPublishInfoTable.putIfAbsent(topic, new TopicPublishInfo());
        this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);
        topicPublishInfo = this.topicPublishInfoTable.get(topic);
    &#125;

    if (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;
        return topicPublishInfo;
    &#125; else &#123;
        //如果未找到当前主题的路由信息,则用默认主题继续查找
        this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, true, this.defaultMQProducer);
        topicPublishInfo = this.topicPublishInfoTable.get(topic);
        return topicPublishInfo;
    &#125;
&#125;
</code></pre>
<p><img src="/../imgs/blog20/Topic%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF.png"></p>
<p><em><strong>代码：TopicPublishInfo</strong></em></p>
<pre><code class="java">public class TopicPublishInfo &#123;
    private boolean orderTopic = false;	//是否是顺序消息
    private boolean haveTopicRouterInfo = false; 
    private List&lt;MessageQueue&gt; messageQueueList = new ArrayList&lt;MessageQueue&gt;();	//该主题消息队列
    private volatile ThreadLocalIndex sendWhichQueue = new ThreadLocalIndex();//每选择一次消息队列,该值+1
    private TopicRouteData topicRouteData;//关联Topic路由元信息
&#125;
</code></pre>
<p><em><strong>代码：MQClientInstance#updateTopicRouteInfoFromNameServer</strong></em></p>
<pre><code class="java">TopicRouteData topicRouteData;
//使用默认主题从NameServer获取路由信息
if (isDefault &amp;&amp; defaultMQProducer != null) &#123;
    topicRouteData = this.mQClientAPIImpl.getDefaultTopicRouteInfoFromNameServer(defaultMQProducer.getCreateTopicKey(),
        1000 * 3);
    if (topicRouteData != null) &#123;
        for (QueueData data : topicRouteData.getQueueDatas()) &#123;
            int queueNums = Math.min(defaultMQProducer.getDefaultTopicQueueNums(), data.getReadQueueNums());
            data.setReadQueueNums(queueNums);
            data.setWriteQueueNums(queueNums);
        &#125;
    &#125;
&#125; else &#123;
    //使用指定主题从NameServer获取路由信息
    topicRouteData = this.mQClientAPIImpl.getTopicRouteInfoFromNameServer(topic, 1000 * 3);
&#125;
</code></pre>
<p><em><strong>代码：MQClientInstance#updateTopicRouteInfoFromNameServer</strong></em></p>
<pre><code class="java">//判断路由是否需要更改
TopicRouteData old = this.topicRouteTable.get(topic);
boolean changed = topicRouteDataIsChange(old, topicRouteData);
if (!changed) &#123;
    changed = this.isNeedUpdateTopicRouteInfo(topic);
&#125; else &#123;
    log.info(&quot;the topic[&#123;&#125;] route info changed, old[&#123;&#125;] ,new[&#123;&#125;]&quot;, topic, old, topicRouteData);
&#125;
</code></pre>
<p><em><strong>代码：MQClientInstance#updateTopicRouteInfoFromNameServer</strong></em></p>
<pre><code class="java">if (changed) &#123;
    //将topicRouteData转换为发布队列
    TopicPublishInfo publishInfo = topicRouteData2TopicPublishInfo(topic, topicRouteData);
    publishInfo.setHaveTopicRouterInfo(true);
    //遍历生产
    Iterator&lt;Entry&lt;String, MQProducerInner&gt;&gt; it = this.producerTable.entrySet().iterator();
    while (it.hasNext()) &#123;
        Entry&lt;String, MQProducerInner&gt; entry = it.next();
        MQProducerInner impl = entry.getValue();
        if (impl != null) &#123;
            //生产者不为空时,更新publishInfo信息
            impl.updateTopicPublishInfo(topic, publishInfo);
        &#125;
    &#125;
&#125;
</code></pre>
<p><em><strong>代码：MQClientInstance#topicRouteData2TopicPublishInfo</strong></em></p>
<pre><code class="java">public static TopicPublishInfo topicRouteData2TopicPublishInfo(final String topic, final TopicRouteData route) &#123;
        //创建TopicPublishInfo对象
        TopicPublishInfo info = new TopicPublishInfo();
        //关联topicRoute
        info.setTopicRouteData(route);
        //顺序消息,更新TopicPublishInfo
        if (route.getOrderTopicConf() != null &amp;&amp; route.getOrderTopicConf().length() &gt; 0) &#123;
            String[] brokers = route.getOrderTopicConf().split(&quot;;&quot;);
            for (String broker : brokers) &#123;
                String[] item = broker.split(&quot;:&quot;);
                int nums = Integer.parseInt(item[1]);
                for (int i = 0; i &lt; nums; i++) &#123;
                    MessageQueue mq = new MessageQueue(topic, item[0], i);
                    info.getMessageQueueList().add(mq);
                &#125;
            &#125;

            info.setOrderTopic(true);
        &#125; else &#123;
            //非顺序消息更新TopicPublishInfo
            List&lt;QueueData&gt; qds = route.getQueueDatas();
            Collections.sort(qds);
            //遍历topic队列信息
            for (QueueData qd : qds) &#123;
                //是否是写队列
                if (PermName.isWriteable(qd.getPerm())) &#123;
                    BrokerData brokerData = null;
                    //遍历写队列Broker
                    for (BrokerData bd : route.getBrokerDatas()) &#123;
                        //根据名称获得读队列对应的Broker
                        if (bd.getBrokerName().equals(qd.getBrokerName())) &#123;
                        brokerData = bd;
                        break;
                    &#125;
                &#125;

                if (null == brokerData) &#123;
                    continue;
                &#125;

                if (!brokerData.getBrokerAddrs().containsKey(MixAll.MASTER_ID)) &#123;
                    continue;
                &#125;
                //封装TopicPublishInfo写队列
                for (int i = 0; i &lt; qd.getWriteQueueNums(); i++) &#123;
                    MessageQueue mq = new MessageQueue(topic, qd.getBrokerName(), i);
                    info.getMessageQueueList().add(mq);
                &#125;
            &#125;
        &#125;

        info.setOrderTopic(false);
    &#125;
    //返回TopicPublishInfo对象
    return info;
&#125;
</code></pre>
<h4 id="3）选择队列"><a href="#3）选择队列" class="headerlink" title="3）选择队列"></a>3）选择队列</h4><ul>
<li>默认不启用Broker故障延迟机制</li>
</ul>
<p><em><strong>代码：TopicPublishInfo#selectOneMessageQueue(lastBrokerName)</strong></em></p>
<pre><code class="java">public MessageQueue selectOneMessageQueue(final String lastBrokerName) &#123;
    //第一次选择队列
    if (lastBrokerName == null) &#123;
        return selectOneMessageQueue();
    &#125; else &#123;
        //sendWhichQueue
        int index = this.sendWhichQueue.getAndIncrement();
        //遍历消息队列集合
        for (int i = 0; i &lt; this.messageQueueList.size(); i++) &#123;
            //sendWhichQueue自增后取模
            int pos = Math.abs(index++) % this.messageQueueList.size();
            if (pos &lt; 0)
                pos = 0;
            //规避上次Broker队列
            MessageQueue mq = this.messageQueueList.get(pos);
            if (!mq.getBrokerName().equals(lastBrokerName)) &#123;
                return mq;
            &#125;
        &#125;
        //如果以上情况都不满足,返回sendWhichQueue取模后的队列
        return selectOneMessageQueue();
    &#125;
&#125;
</code></pre>
<p><em><strong>代码：TopicPublishInfo#selectOneMessageQueue()</strong></em></p>
<pre><code class="java">//第一次选择队列
public MessageQueue selectOneMessageQueue() &#123;
    //sendWhichQueue自增
    int index = this.sendWhichQueue.getAndIncrement();
    //对队列大小取模
    int pos = Math.abs(index) % this.messageQueueList.size();
    if (pos &lt; 0)
        pos = 0;
    //返回对应的队列
    return this.messageQueueList.get(pos);
&#125;
</code></pre>
<ul>
<li>启用Broker故障延迟机制</li>
</ul>
<pre><code class="java">public MessageQueue selectOneMessageQueue(final TopicPublishInfo tpInfo, final String lastBrokerName) &#123;
    //Broker故障延迟机制
    if (this.sendLatencyFaultEnable) &#123;
        try &#123;
            //对sendWhichQueue自增
            int index = tpInfo.getSendWhichQueue().getAndIncrement();
            //对消息队列轮询获取一个队列
            for (int i = 0; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;
                int pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();
                if (pos &lt; 0)
                    pos = 0;
                MessageQueue mq = tpInfo.getMessageQueueList().get(pos);
                //验证该队列是否可用
                if (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;
                    //可用
                    if (null == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))
                        return mq;
                &#125;
            &#125;
            //从规避的Broker中选择一个可用的Broker
            final String notBestBroker = latencyFaultTolerance.pickOneAtLeast();
            //获得Broker的写队列集合
            int writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);
            if (writeQueueNums &gt; 0) &#123;
                //获得一个队列,指定broker和队列ID并返回
                final MessageQueue mq = tpInfo.selectOneMessageQueue();
                if (notBestBroker != null) &#123;
                    mq.setBrokerName(notBestBroker);
                    mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);
                &#125;
                return mq;
            &#125; else &#123;
                latencyFaultTolerance.remove(notBestBroker);
            &#125;
        &#125; catch (Exception e) &#123;
            log.error(&quot;Error occurred when selecting message queue&quot;, e);
        &#125;

        return tpInfo.selectOneMessageQueue();
    &#125;

    return tpInfo.selectOneMessageQueue(lastBrokerName);
&#125;
</code></pre>
<p><img src="/../imgs/blog20/Broker%E6%95%85%E9%9A%9C%E5%BB%B6%E8%BF%9F%E6%9C%BA%E5%88%B6%E6%A0%B8%E5%BF%83%E7%B1%BB.png"></p>
<ul>
<li>延迟机制接口规范</li>
</ul>
<pre><code class="java">public interface LatencyFaultTolerance&lt;T&gt; &#123;
    //更新失败条目
    void updateFaultItem(final T name, final long currentLatency, final long notAvailableDuration);
    //判断Broker是否可用
    boolean isAvailable(final T name);
    //移除Fault条目
    void remove(final T name);
    //尝试从规避的Broker中选择一个可用的Broker
    T pickOneAtLeast();
&#125;
</code></pre>
<ul>
<li>FaultItem：失败条目</li>
</ul>
<pre><code class="java">class FaultItem implements Comparable&lt;FaultItem&gt; &#123;
    //条目唯一键,这里为brokerName
    private final String name;
    //本次消息发送延迟
    private volatile long currentLatency;
    //故障规避开始时间
    private volatile long startTimestamp;
&#125;
</code></pre>
<ul>
<li>消息失败策略</li>
</ul>
<pre><code class="java">public class MQFaultStrategy &#123;
   //根据currentLatency本地消息发送延迟,从latencyMax尾部向前找到第一个比currentLatency小的索引,如果没有找到,返回0
    private long[] latencyMax = &#123;50L, 100L, 550L, 1000L, 2000L, 3000L, 15000L&#125;;
    //根据这个索引从notAvailableDuration取出对应的时间,在该时长内,Broker设置为不可用
    private long[] notAvailableDuration = &#123;0L, 0L, 30000L, 60000L, 120000L, 180000L, 600000L&#125;;
&#125;
</code></pre>
<p><u><em><strong>原理分析</strong></em></u></p>
<p><em><strong>代码：DefaultMQProducerImpl#sendDefaultImpl</strong></em></p>
<pre><code class="java">sendResult = this.sendKernelImpl(msg, 
                                 mq, 
                                 communicationMode, 
                                 sendCallback, 
                                 topicPublishInfo, 
                                 timeout - costTime);
endTimestamp = System.currentTimeMillis();
this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);
</code></pre>
<p>如果上述发送过程出现异常，则调用<code>DefaultMQProducerImpl#updateFaultItem</code></p>
<pre><code class="java">public void updateFaultItem(final String brokerName, final long currentLatency, boolean isolation) &#123;
    //参数一：broker名称
    //参数二:本次消息发送延迟时间
    //参数三:是否隔离
    this.mqFaultStrategy.updateFaultItem(brokerName, currentLatency, isolation);
&#125;
</code></pre>
<p><em><strong>代码：MQFaultStrategy#updateFaultItem</strong></em></p>
<pre><code class="java">public void updateFaultItem(final String brokerName, final long currentLatency, boolean isolation) &#123;
    if (this.sendLatencyFaultEnable) &#123;
        //计算broker规避的时长
        long duration = computeNotAvailableDuration(isolation ? 30000 : currentLatency);
        //更新该FaultItem规避时长
        this.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);
    &#125;
&#125;
</code></pre>
<p><em><strong>代码：MQFaultStrategy#computeNotAvailableDuration</strong></em></p>
<pre><code class="java">private long computeNotAvailableDuration(final long currentLatency) &#123;
    //遍历latencyMax
    for (int i = latencyMax.length - 1; i &gt;= 0; i--) &#123;
        //找到第一个比currentLatency的latencyMax值
        if (currentLatency &gt;= latencyMax[i])
            return this.notAvailableDuration[i];
    &#125;
    //没有找到则返回0
    return 0;
&#125;
</code></pre>
<p><em><strong>代码：LatencyFaultToleranceImpl#updateFaultItem</strong></em></p>
<pre><code class="java">public void updateFaultItem(final String name, final long currentLatency, final long notAvailableDuration) &#123;
    //获得原FaultItem
    FaultItem old = this.faultItemTable.get(name);
    //为空新建faultItem对象,设置规避时长和开始时间
    if (null == old) &#123;
        final FaultItem faultItem = new FaultItem(name);
        faultItem.setCurrentLatency(currentLatency);
        faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);

        old = this.faultItemTable.putIfAbsent(name, faultItem);
        if (old != null) &#123;
            old.setCurrentLatency(currentLatency);
            old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);
        &#125;
    &#125; else &#123;
        //更新规避时长和开始时间
        old.setCurrentLatency(currentLatency);
        old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);
    &#125;
&#125;
</code></pre>
<p>####4）发送消息</p>
<p>消息发送API核心入口<em><strong>DefaultMQProducerImpl#sendKernelImpl</strong></em></p>
<pre><code class="java">private SendResult sendKernelImpl(
    final Message msg,	//待发送消息
    final MessageQueue mq,	//消息发送队列
    final CommunicationMode communicationMode,		//消息发送内模式
    final SendCallback sendCallback,	pp	//异步消息回调函数
    final TopicPublishInfo topicPublishInfo,	//主题路由信息
    final long timeout	//超时时间
    )
</code></pre>
<p><em><strong>代码：DefaultMQProducerImpl#sendKernelImpl</strong></em></p>
<pre><code class="java">//获得broker网络地址信息
String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());
if (null == brokerAddr) &#123;
    //没有找到从NameServer更新broker网络地址信息
    tryToFindTopicPublishInfo(mq.getTopic());
    brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());
&#125;
</code></pre>
<pre><code class="java">//为消息分类唯一ID
if (!(msg instanceof MessageBatch)) &#123;
    MessageClientIDSetter.setUniqID(msg);
&#125;

boolean topicWithNamespace = false;
if (null != this.mQClientFactory.getClientConfig().getNamespace()) &#123;
    msg.setInstanceId(this.mQClientFactory.getClientConfig().getNamespace());
    topicWithNamespace = true;
&#125;
//消息大小超过4K,启用消息压缩
int sysFlag = 0;
boolean msgBodyCompressed = false;
if (this.tryToCompressMessage(msg)) &#123;
    sysFlag |= MessageSysFlag.COMPRESSED_FLAG;
    msgBodyCompressed = true;
&#125;
//如果是事务消息,设置消息标记MessageSysFlag.TRANSACTION_PREPARED_TYPE
final String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);
if (tranMsg != null &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;
    sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;
&#125;
</code></pre>
<pre><code class="java">//如果注册了消息发送钩子函数,在执行消息发送前的增强逻辑
if (this.hasSendMessageHook()) &#123;
    context = new SendMessageContext();
    context.setProducer(this);
    context.setProducerGroup(this.defaultMQProducer.getProducerGroup());
    context.setCommunicationMode(communicationMode);
    context.setBornHost(this.defaultMQProducer.getClientIP());
    context.setBrokerAddr(brokerAddr);
    context.setMessage(msg);
    context.setMq(mq);
    context.setNamespace(this.defaultMQProducer.getNamespace());
    String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);
    if (isTrans != null &amp;&amp; isTrans.equals(&quot;true&quot;)) &#123;
        context.setMsgType(MessageType.Trans_Msg_Half);
    &#125;

    if (msg.getProperty(&quot;__STARTDELIVERTIME&quot;) != null || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != null) &#123;
        context.setMsgType(MessageType.Delay_Msg);
    &#125;
    this.executeSendMessageHookBefore(context);
&#125;
</code></pre>
<p><em><strong>代码：SendMessageHook</strong></em></p>
<pre><code class="java">public interface SendMessageHook &#123;
    String hookName();

    void sendMessageBefore(final SendMessageContext context);

    void sendMessageAfter(final SendMessageContext context);
&#125;
</code></pre>
<p><em><strong>代码：DefaultMQProducerImpl#sendKernelImpl</strong></em></p>
<pre><code class="java">//构建消息发送请求包
SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();
//生产者组
requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());
//主题
requestHeader.setTopic(msg.getTopic());
//默认创建主题Key
requestHeader.setDefaultTopic(this.defaultMQProducer.getCreateTopicKey());
//该主题在单个Broker默认队列树
requestHeader.setDefaultTopicQueueNums(this.defaultMQProducer.getDefaultTopicQueueNums());
//队列ID
requestHeader.setQueueId(mq.getQueueId());
//消息系统标记
requestHeader.setSysFlag(sysFlag);
//消息发送时间
requestHeader.setBornTimestamp(System.currentTimeMillis());
//消息标记
requestHeader.setFlag(msg.getFlag());
//消息扩展信息
requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));
//消息重试次数
requestHeader.setReconsumeTimes(0);
requestHeader.setUnitMode(this.isUnitMode());
//是否是批量消息等
requestHeader.setBatch(msg instanceof MessageBatch);
if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;
    String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);
    if (reconsumeTimes != null) &#123;
        requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));
        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);
    &#125;

    String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);
    if (maxReconsumeTimes != null) &#123;
        requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));
        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);
    &#125;
&#125;
</code></pre>
<pre><code class="java">case ASYNC:		//异步发送
    Message tmpMessage = msg;
    boolean messageCloned = false;
    if (msgBodyCompressed) &#123;
        //If msg body was compressed, msgbody should be reset using prevBody.
        //Clone new message using commpressed message body and recover origin massage.
        //Fix bug:https://github.com/apache/rocketmq-externals/issues/66
        tmpMessage = MessageAccessor.cloneMessage(msg);
        messageCloned = true;
        msg.setBody(prevBody);
    &#125;

    if (topicWithNamespace) &#123;
        if (!messageCloned) &#123;
            tmpMessage = MessageAccessor.cloneMessage(msg);
            messageCloned = true;
        &#125;
        msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), 
                                                    this.defaultMQProducer.getNamespace()));
    &#125;

        long costTimeAsync = System.currentTimeMillis() - beginStartTime;
        if (timeout &lt; costTimeAsync) &#123;
            throw new RemotingTooMuchRequestException(&quot;sendKernelImpl call timeout&quot;);
        &#125;
        sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(
                    brokerAddr,
                    mq.getBrokerName(),
                    tmpMessage,
                    requestHeader,
                    timeout - costTimeAsync,
                    communicationMode,
                    sendCallback,
                    topicPublishInfo,
                    this.mQClientFactory,
                    this.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(),
                    context,
                    this);
        break;
case ONEWAY:
case SYNC:		//同步发送
    long costTimeSync = System.currentTimeMillis() - beginStartTime;
        if (timeout &lt; costTimeSync) &#123;
            throw new RemotingTooMuchRequestException(&quot;sendKernelImpl call timeout&quot;);
        &#125;
        sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(
            brokerAddr,
            mq.getBrokerName(),
            msg,
            requestHeader,
            timeout - costTimeSync,
            communicationMode,
            context,
            this);
        break;
    default:
        assert false;
        break;
&#125;
</code></pre>
<pre><code class="java">//如果注册了钩子函数,则发送完毕后执行钩子函数
if (this.hasSendMessageHook()) &#123;
    context.setSendResult(sendResult);
    this.executeSendMessageHookAfter(context);
&#125;
</code></pre>
<h3 id="2-3-4-批量消息发送"><a href="#2-3-4-批量消息发送" class="headerlink" title="2.3.4 批量消息发送"></a>2.3.4 批量消息发送</h3><p><img src="/../imgs/blog20/%E5%8F%91%E9%80%81%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF.png"></p>
<p>批量消息发送是将同一个主题的多条消息一起打包发送到消息服务端，减少网络调用次数，提高网络传输效率。当然，并不是在同一批次中发送的消息数量越多越好，其判断依据是单条消息的长度，如果单条消息内容比较长，则打包多条消息发送会影响其他线程发送消息的响应时间，并且单批次消息总长度不能超过DefaultMQProducer#maxMessageSize。</p>
<p>批量消息发送要解决的问题是如何将这些消息编码以便服务端能够正确解码出每条消息的消息内容。</p>
<p><em><strong>代码：DefaultMQProducer#send</strong></em></p>
<pre><code class="java">public SendResult send(Collection&lt;Message&gt; msgs) 
    throws MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;
    //压缩消息集合成一条消息,然后发送出去
    return this.defaultMQProducerImpl.send(batch(msgs));
&#125;
</code></pre>
<p><em><strong>代码：DefaultMQProducer#batch</strong></em></p>
<pre><code class="java">private MessageBatch batch(Collection&lt;Message&gt; msgs) throws MQClientException &#123;
    MessageBatch msgBatch;
    try &#123;
        //将集合消息封装到MessageBatch
        msgBatch = MessageBatch.generateFromList(msgs);
        //遍历消息集合,检查消息合法性,设置消息ID,设置Topic
        for (Message message : msgBatch) &#123;
            Validators.checkMessage(message, this);
            MessageClientIDSetter.setUniqID(message);
            message.setTopic(withNamespace(message.getTopic()));
        &#125;
        //压缩消息,设置消息body
        msgBatch.setBody(msgBatch.encode());
    &#125; catch (Exception e) &#123;
        throw new MQClientException(&quot;Failed to initiate the MessageBatch&quot;, e);
    &#125;
    //设置msgBatch的topic
    msgBatch.setTopic(withNamespace(msgBatch.getTopic()));
    return msgBatch;
&#125;
</code></pre>
<h2 id="2-4-消息存储"><a href="#2-4-消息存储" class="headerlink" title="2.4 消息存储"></a>2.4 消息存储</h2><p>###2.4.1 消息存储核心类</p>
<p><img src="/../imgs/blog20/DefaultMessageStore.png"></p>
<pre><code class="java">private final MessageStoreConfig messageStoreConfig;	//消息配置属性
private final CommitLog commitLog;		//CommitLog文件存储的实现类
private final ConcurrentMap&lt;String/* topic */, ConcurrentMap&lt;Integer/* queueId */, ConsumeQueue&gt;&gt; consumeQueueTable;	//消息队列存储缓存表,按照消息主题分组
private final FlushConsumeQueueService flushConsumeQueueService;	//消息队列文件刷盘线程
private final CleanCommitLogService cleanCommitLogService;	//清除CommitLog文件服务
private final CleanConsumeQueueService cleanConsumeQueueService;	//清除ConsumerQueue队列文件服务
private final IndexService indexService;	//索引实现类
private final AllocateMappedFileService allocateMappedFileService;	//MappedFile分配服务
private final ReputMessageService reputMessageService;//CommitLog消息分发,根据CommitLog文件构建ConsumerQueue、IndexFile文件
private final HAService haService;	//存储HA机制
private final ScheduleMessageService scheduleMessageService;	//消息服务调度线程
private final StoreStatsService storeStatsService;	//消息存储服务
private final TransientStorePool transientStorePool;	//消息堆外内存缓存
private final BrokerStatsManager brokerStatsManager;	//Broker状态管理器
private final MessageArrivingListener messageArrivingListener;	//消息拉取长轮询模式消息达到监听器
private final BrokerConfig brokerConfig;	//Broker配置类
private StoreCheckpoint storeCheckpoint;	//文件刷盘监测点
private final LinkedList&lt;CommitLogDispatcher&gt; dispatcherList;	//CommitLog文件转发请求
</code></pre>
<h3 id="2-4-2-消息存储流程"><a href="#2-4-2-消息存储流程" class="headerlink" title="2.4.2 消息存储流程"></a>2.4.2 消息存储流程</h3><p><img src="/../imgs/blog20/%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%B5%81%E7%A8%8B.png"></p>
<p><em><strong>消息存储入口：DefaultMessageStore#putMessage</strong></em></p>
<pre><code class="java">//判断Broker角色如果是从节点,则无需写入
if (BrokerRole.SLAVE == this.messageStoreConfig.getBrokerRole()) &#123;
        long value = this.printTimes.getAndIncrement();
        if ((value % 50000) == 0) &#123;
            log.warn(&quot;message store is slave mode, so putMessage is forbidden &quot;);
        &#125;

    return new PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, null);
&#125;

//判断当前写入状态如果是正在写入,则不能继续
if (!this.runningFlags.isWriteable()) &#123;
        long value = this.printTimes.getAndIncrement();
        return new PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, null);
&#125; else &#123;
    this.printTimes.set(0);
&#125;
//判断消息主题长度是否超过最大限制
if (msg.getTopic().length() &gt; Byte.MAX_VALUE) &#123;
    log.warn(&quot;putMessage message topic length too long &quot; + msg.getTopic().length());
    return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);
&#125;
//判断消息属性长度是否超过限制
if (msg.getPropertiesString() != null &amp;&amp; msg.getPropertiesString().length() &gt; Short.MAX_VALUE) &#123;
    log.warn(&quot;putMessage message properties length too long &quot; + msg.getPropertiesString().length());
    return new PutMessageResult(PutMessageStatus.PROPERTIES_SIZE_EXCEEDED, null);
&#125;
//判断系统PageCache缓存去是否占用
if (this.isOSPageCacheBusy()) &#123;
    return new PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, null);
&#125;

//将消息写入CommitLog文件
PutMessageResult result = this.commitLog.putMessage(msg);
</code></pre>
<p><em><strong>代码：CommitLog#putMessage</strong></em></p>
<pre><code class="java">//记录消息存储时间
msg.setStoreTimestamp(beginLockTimestamp);

//判断如果mappedFile如果为空或者已满,创建新的mappedFile文件
if (null == mappedFile || mappedFile.isFull()) &#123;
    mappedFile = this.mappedFileQueue.getLastMappedFile(0); 
&#125;
//如果创建失败,直接返回
if (null == mappedFile) &#123;
    log.error(&quot;create mapped file1 error, topic: &quot; + msg.getTopic() + &quot; clientAddr: &quot; + msg.getBornHostString());
    beginTimeInLock = 0;
    return new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, null);
&#125;

//写入消息到mappedFile中
result = mappedFile.appendMessage(msg, this.appendMessageCallback);
</code></pre>
<p><em><strong>代码：MappedFile#appendMessagesInner</strong></em></p>
<pre><code class="java">//获得文件的写入指针
int currentPos = this.wrotePosition.get();

//如果指针大于文件大小则直接返回
if (currentPos &lt; this.fileSize) &#123;
    //通过writeBuffer.slice()创建一个与MappedFile共享的内存区,并设置position为当前指针
    ByteBuffer byteBuffer = writeBuffer != null ? writeBuffer.slice() : this.mappedByteBuffer.slice();
    byteBuffer.position(currentPos);
    AppendMessageResult result = null;
    if (messageExt instanceof MessageExtBrokerInner) &#123;
           //通过回调方法写入
        result = cb.doAppend(this.getFileFromOffset(), byteBuffer, this.fileSize - currentPos, (MessageExtBrokerInner) messageExt);
    &#125; else if (messageExt instanceof MessageExtBatch) &#123;
        result = cb.doAppend(this.getFileFromOffset(), byteBuffer, this.fileSize - currentPos, (MessageExtBatch) messageExt);
    &#125; else &#123;
        return new AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);
    &#125;
    this.wrotePosition.addAndGet(result.getWroteBytes());
    this.storeTimestamp = result.getStoreTimestamp();
    return result;
&#125;
</code></pre>
<p><em><strong>代码：CommitLog#doAppend</strong></em></p>
<pre><code class="java">//文件写入位置
long wroteOffset = fileFromOffset + byteBuffer.position();
//设置消息ID
this.resetByteBuffer(hostHolder, 8);
String msgId = MessageDecoder.createMessageId(this.msgIdMemory, msgInner.getStoreHostBytes(hostHolder), wroteOffset);

//获得该消息在消息队列中的偏移量
keyBuilder.setLength(0);
keyBuilder.append(msgInner.getTopic());
keyBuilder.append(&#39;-&#39;);
keyBuilder.append(msgInner.getQueueId());
String key = keyBuilder.toString();
Long queueOffset = CommitLog.this.topicQueueTable.get(key);
if (null == queueOffset) &#123;
    queueOffset = 0L;
    CommitLog.this.topicQueueTable.put(key, queueOffset);
&#125;

//获得消息属性长度
final byte[] propertiesData =msgInner.getPropertiesString() == null ? null : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8);

final int propertiesLength = propertiesData == null ? 0 : propertiesData.length;

if (propertiesLength &gt; Short.MAX_VALUE) &#123;
    log.warn(&quot;putMessage message properties length too long. length=&#123;&#125;&quot;, propertiesData.length);
    return new AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);
&#125;

//获得消息主题大小
final byte[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8);
final int topicLength = topicData.length;

//获得消息体大小
final int bodyLength = msgInner.getBody() == null ? 0 : msgInner.getBody().length;
//计算消息总长度
final int msgLen = calMsgLength(bodyLength, topicLength, propertiesLength);
</code></pre>
<p><em><strong>代码：CommitLog#calMsgLength</strong></em></p>
<pre><code class="java">protected static int calMsgLength(int bodyLength, int topicLength, int propertiesLength) &#123;
    final int msgLen = 4 //TOTALSIZE
        + 4 //MAGICCODE  
        + 4 //BODYCRC
        + 4 //QUEUEID
        + 4 //FLAG
        + 8 //QUEUEOFFSET
        + 8 //PHYSICALOFFSET
        + 4 //SYSFLAG
        + 8 //BORNTIMESTAMP
        + 8 //BORNHOST
        + 8 //STORETIMESTAMP
        + 8 //STOREHOSTADDRESS
        + 4 //RECONSUMETIMES
        + 8 //Prepared Transaction Offset
        + 4 + (bodyLength &gt; 0 ? bodyLength : 0) //BODY
        + 1 + topicLength //TOPIC
        + 2 + (propertiesLength &gt; 0 ? propertiesLength : 0) //propertiesLength
        + 0;
    return msgLen;
&#125;
</code></pre>
<p><em><strong>代码：CommitLog#doAppend</strong></em></p>
<pre><code class="java">//消息长度不能超过4M
if (msgLen &gt; this.maxMessageSize) &#123;
    CommitLog.log.warn(&quot;message size exceeded, msg total size: &quot; + msgLen + &quot;, msg body size: &quot; + bodyLength
        + &quot;, maxMessageSize: &quot; + this.maxMessageSize);
    return new AppendMessageResult(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED);
&#125;

//消息是如果没有足够的存储空间则新创建CommitLog文件
if ((msgLen + END_FILE_MIN_BLANK_LENGTH) &gt; maxBlank) &#123;
    this.resetByteBuffer(this.msgStoreItemMemory, maxBlank);
    // 1 TOTALSIZE
    this.msgStoreItemMemory.putInt(maxBlank);
    // 2 MAGICCODE
    this.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);
    // 3 The remaining space may be any value
    // Here the length of the specially set maxBlank
    final long beginTimeMills = CommitLog.this.defaultMessageStore.now();
    byteBuffer.put(this.msgStoreItemMemory.array(), 0, maxBlank);
    return new AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),
        queueOffset, CommitLog.this.defaultMessageStore.now() - beginTimeMills);
&#125;

//将消息存储到ByteBuffer中,返回AppendMessageResult
final long beginTimeMills = CommitLog.this.defaultMessageStore.now();
// Write messages to the queue buffer
byteBuffer.put(this.msgStoreItemMemory.array(), 0, msgLen);
AppendMessageResult result = new AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, 
                                                     msgLen, msgId,msgInner.getStoreTimestamp(), 
                                                     queueOffset, 
                                                     CommitLog.this.defaultMessageStore.now() 
                                                     -beginTimeMills);
switch (tranType) &#123;
    case MessageSysFlag.TRANSACTION_PREPARED_TYPE:
    case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:
        break;
    case MessageSysFlag.TRANSACTION_NOT_TYPE:
    case MessageSysFlag.TRANSACTION_COMMIT_TYPE:
        //更新消息队列偏移量
        CommitLog.this.topicQueueTable.put(key, ++queueOffset);
        break;
    default:
        break;
&#125;
</code></pre>
<p><em><strong>代码：CommitLog#putMessage</strong></em></p>
<pre><code class="java">//释放锁
putMessageLock.unlock();
//刷盘
handleDiskFlush(result, putMessageResult, msg);
//执行HA主从同步
handleHA(result, putMessageResult, msg);
</code></pre>
<h3 id="2-4-3-存储文件"><a href="#2-4-3-存储文件" class="headerlink" title="2.4.3 存储文件"></a>2.4.3 存储文件</h3><p><img src="/../imgs/blog20/%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6.png"></p>
<ul>
<li>commitLog：消息存储目录</li>
<li>config：运行期间一些配置信息</li>
<li>consumerqueue：消息消费队列存储目录</li>
<li>index：消息索引文件存储目录</li>
<li>abort：如果存在改文件寿命Broker非正常关闭</li>
<li>checkpoint：文件检查点，存储CommitLog文件最后一次刷盘时间戳、consumerquueue最后一次刷盘时间，index索引文件最后一次刷盘时间戳。</li>
</ul>
<h3 id="2-4-4-存储文件内存映射"><a href="#2-4-4-存储文件内存映射" class="headerlink" title="2.4.4 存储文件内存映射"></a>2.4.4 存储文件内存映射</h3><p>RocketMQ通过使用内存映射文件提高IO访问性能，无论是CommitLog、ConsumerQueue还是IndexFile，单个文件都被设计为固定长度，如果一个文件写满以后再创建一个新文件，文件名就为该文件第一条消息对应的全局物理偏移量。</p>
<p>####1）MappedFileQueue</p>
<p><img src="/../imgs/blog20/MappedFileQueue.png"></p>
<pre><code class="java">String storePath;	//存储目录
int mappedFileSize;	// 单个文件大小
CopyOnWriteArrayList&lt;MappedFile&gt; mappedFiles;	//MappedFile文件集合
AllocateMappedFileService allocateMappedFileService;	//创建MapFile服务类
long flushedWhere = 0;		//当前刷盘指针
long committedWhere = 0;	//当前数据提交指针,内存中ByteBuffer当前的写指针,该值大于等于flushWhere
</code></pre>
<ul>
<li>根据存储时间查询MappedFile</li>
</ul>
<pre><code class="java">public MappedFile getMappedFileByTime(final long timestamp) &#123;
    Object[] mfs = this.copyMappedFiles(0);
    
    if (null == mfs)
        return null;
    //遍历MappedFile文件数组
    for (int i = 0; i &lt; mfs.length; i++) &#123;
        MappedFile mappedFile = (MappedFile) mfs[i];
        //MappedFile文件的最后修改时间大于指定时间戳则返回该文件
        if (mappedFile.getLastModifiedTimestamp() &gt;= timestamp) &#123;
            return mappedFile;
        &#125;
    &#125;

    return (MappedFile) mfs[mfs.length - 1];
&#125;
</code></pre>
<ul>
<li>根据消息偏移量offset查找MappedFile</li>
</ul>
<pre><code class="java">public MappedFile findMappedFileByOffset(final long offset, final boolean returnFirstOnNotFound) &#123;
    try &#123;
        //获得第一个MappedFile文件
        MappedFile firstMappedFile = this.getFirstMappedFile();
        //获得最后一个MappedFile文件
        MappedFile lastMappedFile = this.getLastMappedFile();
        //第一个文件和最后一个文件均不为空,则进行处理
        if (firstMappedFile != null &amp;&amp; lastMappedFile != null) &#123;
            if (offset &lt; firstMappedFile.getFileFromOffset() || 
                offset &gt;= lastMappedFile.getFileFromOffset() + this.mappedFileSize) &#123;
            &#125; else &#123;
                //获得文件索引
                int index = (int) ((offset / this.mappedFileSize) 
                                   - (firstMappedFile.getFileFromOffset() / this.mappedFileSize));
                MappedFile targetFile = null;
                try &#123;
                    //根据索引返回目标文件
                    targetFile = this.mappedFiles.get(index);
                &#125; catch (Exception ignored) &#123;
                &#125;

                if (targetFile != null &amp;&amp; offset &gt;= targetFile.getFileFromOffset()
                    &amp;&amp; offset &lt; targetFile.getFileFromOffset() + this.mappedFileSize) &#123;
                    return targetFile;
                &#125;

                for (MappedFile tmpMappedFile : this.mappedFiles) &#123;
                    if (offset &gt;= tmpMappedFile.getFileFromOffset()
                        &amp;&amp; offset &lt; tmpMappedFile.getFileFromOffset() + this.mappedFileSize) &#123;
                        return tmpMappedFile;
                    &#125;
                &#125;
            &#125;

            if (returnFirstOnNotFound) &#123;
                return firstMappedFile;
            &#125;
        &#125;
    &#125; catch (Exception e) &#123;
        log.error(&quot;findMappedFileByOffset Exception&quot;, e);
    &#125;

    return null;
&#125;
</code></pre>
<ul>
<li>获取存储文件最小偏移量</li>
</ul>
<pre><code class="java">public long getMinOffset() &#123;

    if (!this.mappedFiles.isEmpty()) &#123;
        try &#123;
            return this.mappedFiles.get(0).getFileFromOffset();
        &#125; catch (IndexOutOfBoundsException e) &#123;
            //continue;
        &#125; catch (Exception e) &#123;
            log.error(&quot;getMinOffset has exception.&quot;, e);
        &#125;
    &#125;
    return -1;
&#125;
</code></pre>
<ul>
<li>获取存储文件最大偏移量</li>
</ul>
<pre><code class="java">public long getMaxOffset() &#123;
    MappedFile mappedFile = getLastMappedFile();
    if (mappedFile != null) &#123;
        return mappedFile.getFileFromOffset() + mappedFile.getReadPosition();
    &#125;
    return 0;
&#125;
</code></pre>
<ul>
<li>返回存储文件当前写指针</li>
</ul>
<pre><code class="java">public long getMaxWrotePosition() &#123;
    MappedFile mappedFile = getLastMappedFile();
    if (mappedFile != null) &#123;
        return mappedFile.getFileFromOffset() + mappedFile.getWrotePosition();
    &#125;
    return 0;
&#125;
</code></pre>
<p>####2）MappedFile</p>
<p><img src="/../imgs/blog20/MappedFile.png"></p>
<pre><code class="java">int OS_PAGE_SIZE = 1024 * 4;		//操作系统每页大小,默认4K
AtomicLong TOTAL_MAPPED_VIRTUAL_MEMORY = new AtomicLong(0);	//当前JVM实例中MappedFile虚拟内存
AtomicInteger TOTAL_MAPPED_FILES = new AtomicInteger(0);	//当前JVM实例中MappedFile对象个数
AtomicInteger wrotePosition = new AtomicInteger(0);	//当前文件的写指针
AtomicInteger committedPosition = new AtomicInteger(0);	//当前文件的提交指针
AtomicInteger flushedPosition = new AtomicInteger(0);	//刷写到磁盘指针
int fileSize;	//文件大小
FileChannel fileChannel;	//文件通道	
ByteBuffer writeBuffer = null;	//堆外内存ByteBuffer
TransientStorePool transientStorePool = null;	//堆外内存池
String fileName;	//文件名称
long fileFromOffset;	//该文件的处理偏移量
File file;	//物理文件
MappedByteBuffer mappedByteBuffer;	//物理文件对应的内存映射Buffer
volatile long storeTimestamp = 0;	//文件最后一次内容写入时间
boolean firstCreateInQueue = false;	//是否是MappedFileQueue队列中第一个文件
</code></pre>
<p><em><strong>MappedFile初始化</strong></em></p>
<ul>
<li>未开启<code>transientStorePoolEnable</code>。<code>transientStorePoolEnable=true</code>为<code>true</code>表示数据先存储到堆外内存，然后通过<code>Commit</code>线程将数据提交到内存映射Buffer中，再通过<code>Flush</code>线程将内存映射<code>Buffer</code>中数据持久化磁盘。</li>
</ul>
<pre><code class="java">private void init(final String fileName, final int fileSize) throws IOException &#123;
    this.fileName = fileName;
    this.fileSize = fileSize;
    this.file = new File(fileName);
    this.fileFromOffset = Long.parseLong(this.file.getName());
    boolean ok = false;
    
    ensureDirOK(this.file.getParent());

    try &#123;
        this.fileChannel = new RandomAccessFile(this.file, &quot;rw&quot;).getChannel();
        this.mappedByteBuffer = this.fileChannel.map(MapMode.READ_WRITE, 0, fileSize);
        TOTAL_MAPPED_VIRTUAL_MEMORY.addAndGet(fileSize);
        TOTAL_MAPPED_FILES.incrementAndGet();
        ok = true;
    &#125; catch (FileNotFoundException e) &#123;
        log.error(&quot;create file channel &quot; + this.fileName + &quot; Failed. &quot;, e);
        throw e;
    &#125; catch (IOException e) &#123;
        log.error(&quot;map file &quot; + this.fileName + &quot; Failed. &quot;, e);
        throw e;
    &#125; finally &#123;
        if (!ok &amp;&amp; this.fileChannel != null) &#123;
            this.fileChannel.close();
        &#125;
    &#125;
&#125;
</code></pre>
<p>开启<code>transientStorePoolEnable</code></p>
<pre><code class="java">public void init(final String fileName, final int fileSize,
    final TransientStorePool transientStorePool) throws IOException &#123;
    init(fileName, fileSize);
    this.writeBuffer = transientStorePool.borrowBuffer();	//初始化writeBuffer
    this.transientStorePool = transientStorePool;
&#125;
</code></pre>
<p><em><strong>MappedFile提交</strong></em></p>
<p>提交数据到FileChannel，commitLeastPages为本次提交最小的页数，如果待提交数据不满commitLeastPages，则不执行本次提交操作。如果writeBuffer如果为空，直接返回writePosition指针，无需执行commit操作，表名commit操作主体是writeBuffer。</p>
<pre><code class="java">public int commit(final int commitLeastPages) &#123;
    if (writeBuffer == null) &#123;
        //no need to commit data to file channel, so just regard wrotePosition as committedPosition.
        return this.wrotePosition.get();
    &#125;
    //判断是否满足提交条件
    if (this.isAbleToCommit(commitLeastPages)) &#123;
        if (this.hold()) &#123;
            commit0(commitLeastPages);
            this.release();
        &#125; else &#123;
            log.warn(&quot;in commit, hold failed, commit offset = &quot; + this.committedPosition.get());
        &#125;
    &#125;

    // 所有数据提交后,清空缓冲区
    if (writeBuffer != null &amp;&amp; this.transientStorePool != null &amp;&amp; this.fileSize == this.committedPosition.get()) &#123;
        this.transientStorePool.returnBuffer(writeBuffer);
        this.writeBuffer = null;
    &#125;

    return this.committedPosition.get();
&#125;
</code></pre>
<p><em><strong>MappedFile#isAbleToCommit</strong></em></p>
<p>判断是否执行commit操作，如果文件已满返回true；如果commitLeastpages大于0，则比较writePosition与上一次提交的指针commitPosition的差值，除以OS_PAGE_SIZE得到当前脏页的数量，如果大于commitLeastPages则返回true，如果commitLeastpages小于0表示只要存在脏页就提交。</p>
<pre><code class="java">protected boolean isAbleToCommit(final int commitLeastPages) &#123;
    //已经刷盘指针
    int flush = this.committedPosition.get();
    //文件写指针
    int write = this.wrotePosition.get();
    //写满刷盘
    if (this.isFull()) &#123;
        return true;
    &#125;

    if (commitLeastPages &gt; 0) &#123;
        //文件内容达到commitLeastPages页数,则刷盘
        return ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= commitLeastPages;
    &#125;

    return write &gt; flush;
&#125;
</code></pre>
<p><em><strong>MappedFile#commit0</strong></em></p>
<p>具体提交的实现，首先创建WriteBuffer区共享缓存区，然后将新创建的position回退到上一次提交的位置（commitPosition），设置limit为wrotePosition（当前最大有效数据指针），然后把commitPosition到wrotePosition的数据写入到FileChannel中，然后更新committedPosition指针为wrotePosition。commit的作用就是将MappedFile的writeBuffer中数据提交到文件通道FileChannel中。</p>
<pre><code class="java">protected void commit0(final int commitLeastPages) &#123;
    //写指针
    int writePos = this.wrotePosition.get();
    //上次提交指针
    int lastCommittedPosition = this.committedPosition.get();

    if (writePos - this.committedPosition.get() &gt; 0) &#123;
        try &#123;
            //复制共享内存区域
            ByteBuffer byteBuffer = writeBuffer.slice();
            //设置提交位置是上次提交位置
            byteBuffer.position(lastCommittedPosition);
            //最大提交数量
            byteBuffer.limit(writePos);
            //设置fileChannel位置为上次提交位置
            this.fileChannel.position(lastCommittedPosition);
            //将lastCommittedPosition到writePos的数据复制到FileChannel中
            this.fileChannel.write(byteBuffer);
            //重置提交位置
            this.committedPosition.set(writePos);
        &#125; catch (Throwable e) &#123;
            log.error(&quot;Error occurred when commit data to FileChannel.&quot;, e);
        &#125;
    &#125;
&#125;
</code></pre>
<p><em><strong>MappedFile#flush</strong></em></p>
<p>刷写磁盘，直接调用MappedByteBuffer或fileChannel的force方法将内存中的数据持久化到磁盘，那么flushedPosition应该等于MappedByteBuffer中的写指针；如果writeBuffer不为空，则flushPosition应该等于上一次的commit指针；因为上一次提交的数据就是进入到MappedByteBuffer中的数据；如果writeBuffer为空，数据时直接进入到MappedByteBuffer，wrotePosition代表的是MappedByteBuffer中的指针，故设置flushPosition为wrotePosition。</p>
<p><img src="/../imgs/blog20/flush.jpg"></p>
<pre><code class="java">public int flush(final int flushLeastPages) &#123;
    //数据达到刷盘条件
    if (this.isAbleToFlush(flushLeastPages)) &#123;
        //加锁，同步刷盘
        if (this.hold()) &#123;
            //获得读指针
            int value = getReadPosition();
            try &#123;
                //数据从writeBuffer提交数据到fileChannel再刷新到磁盘
                if (writeBuffer != null || this.fileChannel.position() != 0) &#123;
                    this.fileChannel.force(false);
                &#125; else &#123;
                    //从mmap刷新数据到磁盘
                    this.mappedByteBuffer.force();
                &#125;
            &#125; catch (Throwable e) &#123;
                log.error(&quot;Error occurred when force data to disk.&quot;, e);
            &#125;
            //更新刷盘位置
            this.flushedPosition.set(value);
            this.release();
        &#125; else &#123;
            log.warn(&quot;in flush, hold failed, flush offset = &quot; + this.flushedPosition.get());
            this.flushedPosition.set(getReadPosition());
        &#125;
    &#125;
    return this.getFlushedPosition();
&#125;
</code></pre>
<p><em><strong>MappedFile#getReadPosition</strong></em></p>
<p>获取当前文件最大可读指针。如果writeBuffer为空，则直接返回当前的写指针；如果writeBuffer不为空，则返回上一次提交的指针。在MappedFile设置中,只有提交了的数据（写入到MappedByteBuffer或FileChannel中的数据）才是安全的数据</p>
<pre><code class="java">public int getReadPosition() &#123;
    //如果writeBuffer为空,刷盘的位置就是应该等于上次commit的位置,如果为空则为mmap的写指针
    return this.writeBuffer == null ? this.wrotePosition.get() : this.committedPosition.get();
&#125;
</code></pre>
<p><em><strong>MappedFile#selectMappedBuffer</strong></em></p>
<p>查找pos到当前最大可读之间的数据，由于在整个写入期间都未曾改MappedByteBuffer的指针，如果mappedByteBuffer.slice()方法返回的共享缓存区空间为整个MappedFile，然后通过设置ByteBuffer的position为待查找的值，读取字节长度当前可读最大长度，最终返回的ByteBuffer的limit为size。整个共享缓存区的容量为（MappedFile#fileSize-pos）。故在操作SelectMappedBufferResult不能对包含在里面的ByteBuffer调用filp方法。</p>
<pre><code class="java">public SelectMappedBufferResult selectMappedBuffer(int pos) &#123;
    //获得最大可读指针
    int readPosition = getReadPosition();
    //pos小于最大可读指针,并且大于0
    if (pos &lt; readPosition &amp;&amp; pos &gt;= 0) &#123;
        if (this.hold()) &#123;
            //复制mappedByteBuffer读共享区
            ByteBuffer byteBuffer = this.mappedByteBuffer.slice();
            //设置读指针位置
            byteBuffer.position(pos);
            //获得可读范围
            int size = readPosition - pos;
            //设置最大刻度范围
            ByteBuffer byteBufferNew = byteBuffer.slice();
            byteBufferNew.limit(size);
            return new SelectMappedBufferResult(this.fileFromOffset + pos, byteBufferNew, size, this);
        &#125;
    &#125;

    return null;
&#125;
</code></pre>
<p><em><strong>MappedFile#shutdown</strong></em></p>
<p>MappedFile文件销毁的实现方法为public boolean destory(long intervalForcibly)，intervalForcibly表示拒绝被销毁的最大存活时间。</p>
<pre><code class="java">public void shutdown(final long intervalForcibly) &#123;
    if (this.available) &#123;
        //关闭MapedFile
        this.available = false;
        //设置当前关闭时间戳
        this.firstShutdownTimestamp = System.currentTimeMillis();
        //释放资源
        this.release();
    &#125; else if (this.getRefCount() &gt; 0) &#123;
        if ((System.currentTimeMillis() - this.firstShutdownTimestamp) &gt;= intervalForcibly) &#123;
            this.refCount.set(-1000 - this.getRefCount());
            this.release();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="3）TransientStorePool"><a href="#3）TransientStorePool" class="headerlink" title="3）TransientStorePool"></a>3）TransientStorePool</h4><p>短暂的存储池。RocketMQ单独创建一个MappedByteBuffer内存缓存池，用来临时存储数据，数据先写入该内存映射中，然后由commit线程定时将数据从该内存复制到与目标物理文件对应的内存映射中。RocketMQ引入该机制主要的原因是提供一种内存锁定，将当前堆外内存一直锁定在内存中，避免被进程将内存交换到磁盘。</p>
<p><img src="/../imgs/blog20/TransientStorePool.png"></p>
<pre><code class="java">private final int poolSize;		//availableBuffers个数
private final int fileSize;		//每隔ByteBuffer大小
private final Deque&lt;ByteBuffer&gt; availableBuffers;	//ByteBuffer容器。双端队列
</code></pre>
<p><em><strong>初始化</strong></em></p>
<pre><code class="java">public void init() &#123;
    //创建poolSize个堆外内存
    for (int i = 0; i &lt; poolSize; i++) &#123;
        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(fileSize);
        final long address = ((DirectBuffer) byteBuffer).address();
        Pointer pointer = new Pointer(address);
        //使用com.sun.jna.Library类库将该批内存锁定,避免被置换到交换区,提高存储性能
        LibC.INSTANCE.mlock(pointer, new NativeLong(fileSize));

        availableBuffers.offer(byteBuffer);
    &#125;
&#125;
</code></pre>
<h3 id="2-4-5-实时更新消息消费队列与索引文件"><a href="#2-4-5-实时更新消息消费队列与索引文件" class="headerlink" title="2.4.5 实时更新消息消费队列与索引文件"></a>2.4.5 实时更新消息消费队列与索引文件</h3><p>消息消费队文件、消息属性索引文件都是基于CommitLog文件构建的，当消息生产者提交的消息存储在CommitLog文件中，ConsumerQueue、IndexFile需要及时更新，否则消息无法及时被消费，根据消息属性查找消息也会出现较大延迟。RocketMQ通过开启一个线程ReputMessageService来准实时转发CommitLog文件更新事件，相应的任务处理器根据转发的消息及时更新ConsumerQueue、IndexFile文件。</p>
<p><img src="/../imgs/blog20/%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"></p>
<p><img src="/../imgs/blog20/%E6%9E%84%E5%BB%BA%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E9%98%9F%E5%88%97%E5%92%8C%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6.png"></p>
<p><em><strong>代码：DefaultMessageStore：start</strong></em></p>
<pre><code class="java">//设置CommitLog内存中最大偏移量
this.reputMessageService.setReputFromOffset(maxPhysicalPosInLogicQueue);
//启动
this.reputMessageService.start();
</code></pre>
<p><em><strong>代码：DefaultMessageStore：run</strong></em></p>
<pre><code class="java">public void run() &#123;
    DefaultMessageStore.log.info(this.getServiceName() + &quot; service started&quot;);
    //每隔1毫秒就继续尝试推送消息到消息消费队列和索引文件
    while (!this.isStopped()) &#123;
        try &#123;
            Thread.sleep(1);
            this.doReput();
        &#125; catch (Exception e) &#123;
            DefaultMessageStore.log.warn(this.getServiceName() + &quot; service has exception. &quot;, e);
        &#125;
    &#125;

    DefaultMessageStore.log.info(this.getServiceName() + &quot; service end&quot;);
&#125;
</code></pre>
<p><em><strong>代码：DefaultMessageStore：deReput</strong></em></p>
<pre><code class="java">//从result中循环遍历消息,一次读一条,创建DispatherRequest对象。
for (int readSize = 0; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;
    DispatchRequest dispatchRequest =                               DefaultMessageStore.this.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), false, false);
    int size = dispatchRequest.getBufferSize() == -1 ? dispatchRequest.getMsgSize() : dispatchRequest.getBufferSize();

    if (dispatchRequest.isSuccess()) &#123;
        if (size &gt; 0) &#123;
            DefaultMessageStore.this.doDispatch(dispatchRequest);
        &#125;
    &#125;
&#125;
</code></pre>
<p><em><strong>DispatchRequest</strong></em></p>
<p><img src="/../imgs/blog20/DispatchRequest.png"></p>
<pre><code class="java">String topic; //消息主题名称
int queueId;  //消息队列ID
long commitLogOffset;	//消息物理偏移量
int msgSize;	//消息长度
long tagsCode;	//消息过滤tag hashCode
long storeTimestamp;	//消息存储时间戳
long consumeQueueOffset;	//消息队列偏移量
String keys;	//消息索引key
boolean success;	//是否成功解析到完整的消息
String uniqKey;	//消息唯一键
int sysFlag;	//消息系统标记
long preparedTransactionOffset;	//消息预处理事务偏移量
Map&lt;String, String&gt; propertiesMap;	//消息属性
byte[] bitMap;	//位图
</code></pre>
<h4 id="1）转发到ConsumerQueue"><a href="#1）转发到ConsumerQueue" class="headerlink" title="1）转发到ConsumerQueue"></a>1）转发到ConsumerQueue</h4><p><img src="/../imgs/blog20/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E5%88%B0%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E9%98%9F%E5%88%97.png"></p>
<pre><code class="java">class CommitLogDispatcherBuildConsumeQueue implements CommitLogDispatcher &#123;
    @Override
    public void dispatch(DispatchRequest request) &#123;
        final int tranType = MessageSysFlag.getTransactionValue(request.getSysFlag());
        switch (tranType) &#123;
            case MessageSysFlag.TRANSACTION_NOT_TYPE:
            case MessageSysFlag.TRANSACTION_COMMIT_TYPE:
                //消息分发
                DefaultMessageStore.this.putMessagePositionInfo(request);
                break;
            case MessageSysFlag.TRANSACTION_PREPARED_TYPE:
            case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:
                break;
        &#125;
    &#125;
&#125;
</code></pre>
<p><em><strong>代码：DefaultMessageStore#putMessagePositionInfo</strong></em></p>
<pre><code class="java">public void putMessagePositionInfo(DispatchRequest dispatchRequest) &#123;
    //获得消费队列
    ConsumeQueue cq = this.findConsumeQueue(dispatchRequest.getTopic(), dispatchRequest.getQueueId());
    //消费队列分发消息
    cq.putMessagePositionInfoWrapper(dispatchRequest);
&#125;
</code></pre>
<p><em><strong>代码：DefaultMessageStore#putMessagePositionInfo</strong></em></p>
<pre><code class="java">//依次将消息偏移量、消息长度、tag写入到ByteBuffer中
this.byteBufferIndex.flip();
this.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE);
this.byteBufferIndex.putLong(offset);
this.byteBufferIndex.putInt(size);
this.byteBufferIndex.putLong(tagsCode);
//获得内存映射文件
MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile(expectLogicOffset);
if (mappedFile != null) &#123;
    //将消息追加到内存映射文件,异步输盘
    return mappedFile.appendMessage(this.byteBufferIndex.array());
&#125;
</code></pre>
<h4 id="2）转发到Index"><a href="#2）转发到Index" class="headerlink" title="2）转发到Index"></a>2）转发到Index</h4><p><img src="/../imgs/blog20/%E6%B6%88%E6%81%AF%E5%88%86%E5%8F%91%E5%88%B0%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6.png"></p>
<pre><code class="java">class CommitLogDispatcherBuildIndex implements CommitLogDispatcher &#123;

    @Override
    public void dispatch(DispatchRequest request) &#123;
        if (DefaultMessageStore.this.messageStoreConfig.isMessageIndexEnable()) &#123;
            DefaultMessageStore.this.indexService.buildIndex(request);
        &#125;
    &#125;
&#125;
</code></pre>
<p><em><strong>代码：DefaultMessageStore#buildIndex</strong></em></p>
<pre><code class="java">public void buildIndex(DispatchRequest req) &#123;
    //获得索引文件
    IndexFile indexFile = retryGetAndCreateIndexFile();
    if (indexFile != null) &#123;
        //获得文件最大物理偏移量
        long endPhyOffset = indexFile.getEndPhyOffset();
        DispatchRequest msg = req;
        String topic = msg.getTopic();
        String keys = msg.getKeys();
        //如果该消息的物理偏移量小于索引文件中的最大物理偏移量,则说明是重复数据,忽略本次索引构建
        if (msg.getCommitLogOffset() &lt; endPhyOffset) &#123;
            return;
        &#125;

        final int tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());
        switch (tranType) &#123;
            case MessageSysFlag.TRANSACTION_NOT_TYPE:
            case MessageSysFlag.TRANSACTION_PREPARED_TYPE:
            case MessageSysFlag.TRANSACTION_COMMIT_TYPE:
                break;
            case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:
                return;
        &#125;
        
        //如果消息ID不为空,则添加到Hash索引中
        if (req.getUniqKey() != null) &#123;
            indexFile = putKey(indexFile, msg, buildKey(topic, req.getUniqKey()));
            if (indexFile == null) &#123;
                return;
            &#125;
        &#125;
        //构建索引key,RocketMQ支持为同一个消息建立多个索引,多个索引键空格隔开.
        if (keys != null &amp;&amp; keys.length() &gt; 0) &#123;
            String[] keyset = keys.split(MessageConst.KEY_SEPARATOR);
            for (int i = 0; i &lt; keyset.length; i++) &#123;
                String key = keyset[i];
                if (key.length() &gt; 0) &#123;
                    indexFile = putKey(indexFile, msg, buildKey(topic, key));
                    if (indexFile == null) &#123;

                        return;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125; else &#123;
        log.error(&quot;build index error, stop building index&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="2-4-6-消息队列和索引文件恢复"><a href="#2-4-6-消息队列和索引文件恢复" class="headerlink" title="2.4.6 消息队列和索引文件恢复"></a>2.4.6 消息队列和索引文件恢复</h3><p>由于RocketMQ存储首先将消息全量存储在CommitLog文件中，然后异步生成转发任务更新ConsumerQueue和Index文件。如果消息成功存储到CommitLog文件中，转发任务未成功执行，此时消息服务器Broker由于某个愿意宕机，导致CommitLog、ConsumerQueue、IndexFile文件数据不一致。如果不加以人工修复的话，会有一部分消息即便在CommitLog中文件中存在，但由于没有转发到ConsumerQueue，这部分消息将永远复发被消费者消费。</p>
<p><img src="/../imgs/blog20/%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B.png"></p>
<p>####1）存储文件加载</p>
<p><em><strong>代码：DefaultMessageStore#load</strong></em></p>
<p>判断上一次是否异常退出。实现机制是Broker在启动时创建abort文件，在退出时通过JVM钩子函数删除abort文件。如果下次启动时存在abort文件。说明Broker时异常退出的，CommitLog与ConsumerQueue数据有可能不一致，需要进行修复。</p>
<pre><code class="java">//判断临时文件是否存在
boolean lastExitOK = !this.isTempFileExist();
//根据临时文件判断当前Broker是否异常退出
private boolean isTempFileExist() &#123;
    String fileName = StorePathConfigHelper
        .getAbortFile(this.messageStoreConfig.getStorePathRootDir());
    File file = new File(fileName);
    return file.exists();
&#125;
</code></pre>
<p><em><strong>代码：DefaultMessageStore#load</strong></em></p>
<pre><code class="java">//加载延时队列
if (null != scheduleMessageService) &#123;
    result = result &amp;&amp; this.scheduleMessageService.load();
&#125;

// 加载CommitLog文件
result = result &amp;&amp; this.commitLog.load();

// 加载消费队列文件
result = result &amp;&amp; this.loadConsumeQueue();

if (result) &#123;
    //加载存储监测点,监测点主要记录CommitLog文件、ConsumerQueue文件、Index索引文件的刷盘点
    this.storeCheckpoint =new StoreCheckpoint(StorePathConfigHelper.getStoreCheckpoint(this.messageStoreConfig.getStorePathRootDir()));
    //加载index文件
    this.indexService.load(lastExitOK);
    //根据Broker是否异常退出,执行不同的恢复策略
    this.recover(lastExitOK);
&#125;
</code></pre>
<p><em><strong>代码：MappedFileQueue#load</strong></em></p>
<p>加载CommitLog到映射文件</p>
<pre><code class="java">//指向CommitLog文件目录
File dir = new File(this.storePath);
//获得文件数组
File[] files = dir.listFiles();
if (files != null) &#123;
    // 文件排序
    Arrays.sort(files);
    //遍历文件
    for (File file : files) &#123;
        //如果文件大小和配置文件不一致,退出
        if (file.length() != this.mappedFileSize) &#123;
            
            return false;
        &#125;

        try &#123;
            //创建映射文件
            MappedFile mappedFile = new MappedFile(file.getPath(), mappedFileSize);
            mappedFile.setWrotePosition(this.mappedFileSize);
            mappedFile.setFlushedPosition(this.mappedFileSize);
            mappedFile.setCommittedPosition(this.mappedFileSize);
            //将映射文件添加到队列
            this.mappedFiles.add(mappedFile);
            log.info(&quot;load &quot; + file.getPath() + &quot; OK&quot;);
        &#125; catch (IOException e) &#123;
            log.error(&quot;load file &quot; + file + &quot; error&quot;, e);
            return false;
        &#125;
    &#125;
&#125;

return true;
</code></pre>
<p><em><strong>代码：DefaultMessageStore#loadConsumeQueue</strong></em></p>
<p>加载消息消费队列</p>
<pre><code class="java">//执行消费队列目录
File dirLogic = new File(StorePathConfigHelper.getStorePathConsumeQueue(this.messageStoreConfig.getStorePathRootDir()));
//遍历消费队列目录
File[] fileTopicList = dirLogic.listFiles();
if (fileTopicList != null) &#123;

    for (File fileTopic : fileTopicList) &#123;
        //获得子目录名称,即topic名称
        String topic = fileTopic.getName();
        //遍历子目录下的消费队列文件
        File[] fileQueueIdList = fileTopic.listFiles();
        if (fileQueueIdList != null) &#123;
            //遍历文件
            for (File fileQueueId : fileQueueIdList) &#123;
                //文件名称即队列ID
                int queueId;
                try &#123;
                    queueId = Integer.parseInt(fileQueueId.getName());
                &#125; catch (NumberFormatException e) &#123;
                    continue;
                &#125;
                //创建消费队列并加载到内存
                ConsumeQueue logic = new ConsumeQueue(
                    topic,
                    queueId,
                    StorePathConfigHelper.getStorePathConsumeQueue(this.messageStoreConfig.getStorePathRootDir()),
            this.getMessageStoreConfig().getMapedFileSizeConsumeQueue(),
                    this);
                this.putConsumeQueue(topic, queueId, logic);
                if (!logic.load()) &#123;
                    return false;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;

log.info(&quot;load logics queue all over, OK&quot;);

return true;
</code></pre>
<p><em><strong>代码：IndexService#load</strong></em></p>
<p>加载索引文件</p>
<pre><code class="java">public boolean load(final boolean lastExitOK) &#123;
    //索引文件目录
    File dir = new File(this.storePath);
    //遍历索引文件
    File[] files = dir.listFiles();
    if (files != null) &#123;
        //文件排序
        Arrays.sort(files);
        //遍历文件
        for (File file : files) &#123;
            try &#123;
                //加载索引文件
                IndexFile f = new IndexFile(file.getPath(), this.hashSlotNum, this.indexNum, 0, 0);
                f.load();

                if (!lastExitOK) &#123;
                    //索引文件上次的刷盘时间小于该索引文件的消息时间戳,该文件将立即删除
                    if (f.getEndTimestamp() &gt; this.defaultMessageStore.getStoreCheckpoint()
                        .getIndexMsgTimestamp()) &#123;
                        f.destroy(0);
                        continue;
                    &#125;
                &#125;
                //将索引文件添加到队列
                log.info(&quot;load index file OK, &quot; + f.getFileName());
                this.indexFileList.add(f);
            &#125; catch (IOException e) &#123;
                log.error(&quot;load file &#123;&#125; error&quot;, file, e);
                return false;
            &#125; catch (NumberFormatException e) &#123;
                log.error(&quot;load file &#123;&#125; error&quot;, file, e);
            &#125;
        &#125;
    &#125;

    return true;
&#125;
</code></pre>
<p><em><strong>代码：DefaultMessageStore#recover</strong></em></p>
<p>文件恢复，根据Broker是否正常退出执行不同的恢复策略</p>
<pre><code class="java">private void recover(final boolean lastExitOK) &#123;
    //获得最大的物理便宜消费队列
    long maxPhyOffsetOfConsumeQueue = this.recoverConsumeQueue();

    if (lastExitOK) &#123;
        //正常恢复
        this.commitLog.recoverNormally(maxPhyOffsetOfConsumeQueue);
    &#125; else &#123;
        //异常恢复
        this.commitLog.recoverAbnormally(maxPhyOffsetOfConsumeQueue);
    &#125;
    //在CommitLog中保存每个消息消费队列当前的存储逻辑偏移量
    this.recoverTopicQueueTable();
&#125;
</code></pre>
<p><em><strong>代码：DefaultMessageStore#recoverTopicQueueTable</strong></em></p>
<p>恢复ConsumerQueue后，将在CommitLog实例中保存每隔消息队列当前的存储逻辑偏移量，这也是消息中不仅存储主题、消息队列ID、还存储了消息队列的关键所在。</p>
<pre><code class="java">public void recoverTopicQueueTable() &#123;
    HashMap&lt;String/* topic-queueid */, Long/* offset */&gt; table = new HashMap&lt;String, Long&gt;(1024);
    //CommitLog最小偏移量
    long minPhyOffset = this.commitLog.getMinOffset();
    //遍历消费队列,将消费队列保存在CommitLog中
    for (ConcurrentMap&lt;Integer, ConsumeQueue&gt; maps : this.consumeQueueTable.values()) &#123;
        for (ConsumeQueue logic : maps.values()) &#123;
            String key = logic.getTopic() + &quot;-&quot; + logic.getQueueId();
            table.put(key, logic.getMaxOffsetInQueue());
            logic.correctMinOffset(minPhyOffset);
        &#125;
    &#125;
    this.commitLog.setTopicQueueTable(table);
&#125;
</code></pre>
<p>####2）正常恢复</p>
<p><em><strong>代码：CommitLog#recoverNormally</strong></em></p>
<pre><code class="java">public void recoverNormally(long maxPhyOffsetOfConsumeQueue) &#123;
    
    final List&lt;MappedFile&gt; mappedFiles = this.mappedFileQueue.getMappedFiles();
    if (!mappedFiles.isEmpty()) &#123;
         //Broker正常停止再重启时,从倒数第三个开始恢复,如果不足3个文件,则从第一个文件开始恢复。
        int index = mappedFiles.size() - 3;
        if (index &lt; 0)
            index = 0;
        MappedFile mappedFile = mappedFiles.get(index);
        ByteBuffer byteBuffer = mappedFile.sliceByteBuffer();
        long processOffset = mappedFile.getFileFromOffset();
        //代表当前已校验通过的offset
        long mappedFileOffset = 0;
        while (true) &#123;
            //查找消息
            DispatchRequest dispatchRequest = this.checkMessageAndReturnSize(byteBuffer, checkCRCOnRecover);
            //消息长度
            int size = dispatchRequest.getMsgSize();
               //查找结果为true,并且消息长度大于0,表示消息正确.mappedFileOffset向前移动本消息长度
            if (dispatchRequest.isSuccess() &amp;&amp; size &gt; 0) &#123;
                mappedFileOffset += size;
            &#125;
            //如果查找结果为true且消息长度等于0,表示已到该文件末尾,如果还有下一个文件,则重置processOffset和MappedFileOffset重复查找下一个文件,否则跳出循环。
            else if (dispatchRequest.isSuccess() &amp;&amp; size == 0) &#123;
              index++;
              if (index &gt;= mappedFiles.size()) &#123;
                  // Current branch can not happen
                  break;
              &#125; else &#123;
                  //取出每个文件
                  mappedFile = mappedFiles.get(index);
                  byteBuffer = mappedFile.sliceByteBuffer();
                  processOffset = mappedFile.getFileFromOffset();
                  mappedFileOffset = 0;
                  
                  &#125;
            &#125;
            // 查找结果为false，表明该文件未填满所有消息，跳出循环，结束循环
            else if (!dispatchRequest.isSuccess()) &#123;
                log.info(&quot;recover physics file end, &quot; + mappedFile.getFileName());
                break;
            &#125;
        &#125;
        //更新MappedFileQueue的flushedWhere和committedWhere指针
        processOffset += mappedFileOffset;
        this.mappedFileQueue.setFlushedWhere(processOffset);
        this.mappedFileQueue.setCommittedWhere(processOffset);
        //删除offset之后的所有文件
        this.mappedFileQueue.truncateDirtyFiles(processOffset);

        
        if (maxPhyOffsetOfConsumeQueue &gt;= processOffset) &#123;
            this.defaultMessageStore.truncateDirtyLogicFiles(processOffset);
        &#125;
    &#125; else &#123;
        this.mappedFileQueue.setFlushedWhere(0);
        this.mappedFileQueue.setCommittedWhere(0);
        this.defaultMessageStore.destroyLogics();
    &#125;
&#125;
</code></pre>
<p><em><strong>代码：MappedFileQueue#truncateDirtyFiles</strong></em></p>
<pre><code class="java">public void truncateDirtyFiles(long offset) &#123;
    List&lt;MappedFile&gt; willRemoveFiles = new ArrayList&lt;MappedFile&gt;();
    //遍历目录下文件
    for (MappedFile file : this.mappedFiles) &#123;
        //文件尾部的偏移量
        long fileTailOffset = file.getFileFromOffset() + this.mappedFileSize;
        //文件尾部的偏移量大于offset
        if (fileTailOffset &gt; offset) &#123;
            //offset大于文件的起始偏移量
            if (offset &gt;= file.getFileFromOffset()) &#123;
                //更新wrotePosition、committedPosition、flushedPosistion
                file.setWrotePosition((int) (offset % this.mappedFileSize));
                file.setCommittedPosition((int) (offset % this.mappedFileSize));
                file.setFlushedPosition((int) (offset % this.mappedFileSize));
            &#125; else &#123;
                //offset小于文件的起始偏移量,说明该文件是有效文件后面创建的,释放mappedFile占用内存,删除文件
                file.destroy(1000);
                willRemoveFiles.add(file);
            &#125;
        &#125;
    &#125;

    this.deleteExpiredFile(willRemoveFiles);
&#125;
</code></pre>
<p>####3）异常恢复</p>
<p>Broker异常停止文件恢复的实现为CommitLog#recoverAbnormally。异常文件恢复步骤与正常停止文件恢复流程基本相同，其主要差别有两个。首先，正常停止默认从倒数第三个文件开始进行恢复，而异常停止则需要从最后一个文件往前走，找到第一个消息存储正常的文件。其次，如果CommitLog目录没有消息文件，如果消息消费队列目录下存在文件，则需要销毁。</p>
<p><em><strong>代码：CommitLog#recoverAbnormally</strong></em></p>
<pre><code class="java">if (!mappedFiles.isEmpty()) &#123;
    // Looking beginning to recover from which file
    int index = mappedFiles.size() - 1;
    MappedFile mappedFile = null;
    for (; index &gt;= 0; index--) &#123;
        mappedFile = mappedFiles.get(index);
        //判断消息文件是否是一个正确的文件
        if (this.isMappedFileMatchedRecover(mappedFile)) &#123;
            log.info(&quot;recover from this mapped file &quot; + mappedFile.getFileName());
            break;
        &#125;
    &#125;
    //根据索引取出mappedFile文件
    if (index &lt; 0) &#123;
        index = 0;
        mappedFile = mappedFiles.get(index);
    &#125;
    //...验证消息的合法性,并将消息转发到消息消费队列和索引文件
       
&#125;else&#123;
    //未找到mappedFile,重置flushWhere、committedWhere都为0，销毁消息队列文件
    this.mappedFileQueue.setFlushedWhere(0);
    this.mappedFileQueue.setCommittedWhere(0);
    this.defaultMessageStore.destroyLogics();
&#125;
</code></pre>
<h3 id="2-4-7-刷盘机制"><a href="#2-4-7-刷盘机制" class="headerlink" title="2.4.7 刷盘机制"></a>2.4.7 刷盘机制</h3><p>RocketMQ的存储是基于JDK NIO的内存映射机制（MappedByteBuffer）的，消息存储首先将消息追加到内存，再根据配置的刷盘策略在不同时间进行刷写磁盘。</p>
<h4 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘"></a>同步刷盘</h4><p>消息追加到内存后，立即将数据刷写到磁盘文件</p>
<p><img src="/../imgs/blog20/%E5%90%8C%E6%AD%A5%E5%88%B7%E7%9B%98%E6%B5%81%E7%A8%8B.png"></p>
<p><em><strong>代码：CommitLog#handleDiskFlush</strong></em></p>
<pre><code class="java">//刷盘服务
final GroupCommitService service = (GroupCommitService) this.flushCommitLogService;
if (messageExt.isWaitStoreMsgOK()) &#123;
    //封装刷盘请求
    GroupCommitRequest request = new GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());
    //提交刷盘请求
    service.putRequest(request);
    //线程阻塞5秒，等待刷盘结束
    boolean flushOK = request.waitForFlush(this.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());
    if (!flushOK) &#123;
        putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);
    &#125;
</code></pre>
<p><em><strong>GroupCommitRequest</strong></em></p>
<p><img src="/../imgs/blog20/GroupCommitRequest.png"></p>
<pre><code class="java">long nextOffset;	//刷盘点偏移量
CountDownLatch countDownLatch = new CountDownLatch(1);	//倒计树锁存器
volatile boolean flushOK = false;	//刷盘结果;默认为false
</code></pre>
<p><em><strong>代码：GroupCommitService#run</strong></em></p>
<pre><code class="java">public void run() &#123;
    CommitLog.log.info(this.getServiceName() + &quot; service started&quot;);

    while (!this.isStopped()) &#123;
        try &#123;
            //线程等待10ms
            this.waitForRunning(10);
            //执行提交
            this.doCommit();
        &#125; catch (Exception e) &#123;
            CommitLog.log.warn(this.getServiceName() + &quot; service has exception. &quot;, e);
        &#125;
    &#125;
    ...
&#125;
</code></pre>
<p><em><strong>代码：GroupCommitService#doCommit</strong></em></p>
<pre><code class="java">private void doCommit() &#123;
    //加锁
    synchronized (this.requestsRead) &#123;
        if (!this.requestsRead.isEmpty()) &#123;
            //遍历requestsRead
            for (GroupCommitRequest req : this.requestsRead) &#123;
                // There may be a message in the next file, so a maximum of
                // two times the flush
                boolean flushOK = false;
                for (int i = 0; i &lt; 2 &amp;&amp; !flushOK; i++) &#123;
                    flushOK = CommitLog.this.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();
                    //刷盘
                    if (!flushOK) &#123;
                        CommitLog.this.mappedFileQueue.flush(0);
                    &#125;
                &#125;
                //唤醒发送消息客户端
                req.wakeupCustomer(flushOK);
            &#125;
            
            //更新刷盘监测点
            long storeTimestamp = CommitLog.this.mappedFileQueue.getStoreTimestamp();
            if (storeTimestamp &gt; 0) &#123;               CommitLog.this.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);
            &#125;
            
            this.requestsRead.clear();
        &#125; else &#123;
            // Because of individual messages is set to not sync flush, it
            // will come to this process
            CommitLog.this.mappedFileQueue.flush(0);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="异步刷盘"><a href="#异步刷盘" class="headerlink" title="异步刷盘"></a>异步刷盘</h4><p>在消息追加到内存后，立即返回给消息发送端。如果开启transientStorePoolEnable，RocketMQ会单独申请一个与目标物理文件（commitLog）同样大小的堆外内存，该堆外内存将使用内存锁定，确保不会被置换到虚拟内存中去，消息首先追加到堆外内存，然后提交到物理文件的内存映射中，然后刷写到磁盘。如果未开启transientStorePoolEnable，消息直接追加到物理文件直接映射文件中，然后刷写到磁盘中。</p>
<p><img src="/../imgs/blog20/%E5%BC%82%E6%AD%A5%E5%88%B7%E7%9B%98%E6%B5%81%E7%A8%8B.png"></p>
<p>开启transientStorePoolEnable后异步刷盘步骤:</p>
<ol>
<li>将消息直接追加到ByteBuffer（堆外内存）</li>
<li>CommitRealTimeService线程每隔200ms将ByteBuffer新追加内容提交到MappedByteBuffer中</li>
<li>MappedByteBuffer在内存中追加提交的内容，wrotePosition指针向后移动</li>
<li>commit操作成功返回，将committedPosition位置恢复</li>
<li>FlushRealTimeService线程默认每500ms将MappedByteBuffer中新追加的内存刷写到磁盘</li>
</ol>
<p><em><strong>代码：CommitLog$CommitRealTimeService#run</strong></em></p>
<p>提交线程工作机制</p>
<pre><code class="java">//间隔时间,默认200ms
int interval = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getCommitIntervalCommitLog();

//一次提交的至少页数
int commitDataLeastPages = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogLeastPages();

//两次真实提交的最大间隔,默认200ms
int commitDataThoroughInterval =
CommitLog.this.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogThoroughInterval();

//上次提交间隔超过commitDataThoroughInterval,则忽略提交commitDataThoroughInterval参数,直接提交
long begin = System.currentTimeMillis();
if (begin &gt;= (this.lastCommitTimestamp + commitDataThoroughInterval)) &#123;
    this.lastCommitTimestamp = begin;
    commitDataLeastPages = 0;
&#125;

//执行提交操作,将待提交数据提交到物理文件的内存映射区
boolean result = CommitLog.this.mappedFileQueue.commit(commitDataLeastPages);
long end = System.currentTimeMillis();
if (!result) &#123;
    this.lastCommitTimestamp = end; // result = false means some data committed.
    //now wake up flush thread.
    //唤醒刷盘线程
    flushCommitLogService.wakeup();
&#125;

if (end - begin &gt; 500) &#123;
    log.info(&quot;Commit data to file costs &#123;&#125; ms&quot;, end - begin);
&#125;
this.waitForRunning(interval);
</code></pre>
<p><em><strong>代码：CommitLog$FlushRealTimeService#run</strong></em></p>
<p>刷盘线程工作机制</p>
<pre><code class="java">//表示await方法等待,默认false
boolean flushCommitLogTimed = CommitLog.this.defaultMessageStore.getMessageStoreConfig().isFlushCommitLogTimed();
//线程执行时间间隔
int interval = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getFlushIntervalCommitLog();
//一次刷写任务至少包含页数
int flushPhysicQueueLeastPages = CommitLog.this.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogLeastPages();
//两次真实刷写任务最大间隔
int flushPhysicQueueThoroughInterval =
CommitLog.this.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogThoroughInterval();
...
//距离上次提交间隔超过flushPhysicQueueThoroughInterval,则本次刷盘任务将忽略flushPhysicQueueLeastPages,直接提交
long currentTimeMillis = System.currentTimeMillis();
if (currentTimeMillis &gt;= (this.lastFlushTimestamp + flushPhysicQueueThoroughInterval)) &#123;
    this.lastFlushTimestamp = currentTimeMillis;
    flushPhysicQueueLeastPages = 0;
    printFlushProgress = (printTimes++ % 10) == 0;
&#125;
...
//执行一次刷盘前,先等待指定时间间隔
if (flushCommitLogTimed) &#123;
    Thread.sleep(interval);
&#125; else &#123;
    this.waitForRunning(interval);
&#125;
...
long begin = System.currentTimeMillis();
//刷写磁盘
CommitLog.this.mappedFileQueue.flush(flushPhysicQueueLeastPages);
long storeTimestamp = CommitLog.this.mappedFileQueue.getStoreTimestamp();
if (storeTimestamp &gt; 0) &#123;
//更新存储监测点文件的时间戳
CommitLog.this.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);
</code></pre>
<h3 id="2-4-8-过期文件删除机制"><a href="#2-4-8-过期文件删除机制" class="headerlink" title="2.4.8 过期文件删除机制"></a>2.4.8 过期文件删除机制</h3><p>由于RocketMQ操作CommitLog、ConsumerQueue文件是基于内存映射机制并在启动的时候回加载CommitLog、ConsumerQueue目录下的所有文件，为了避免内存与磁盘的浪费，不可能将消息永久存储在消息服务器上，所以要引入一种机制来删除已过期的文件。RocketMQ顺序写CommitLog、ConsumerQueue文件，所有写操作全部落在最后一个CommitLog或者ConsumerQueue文件上，之前的文件在下一个文件创建后将不会再被更新。RocketMQ清除过期文件的方法时：如果当前文件在在一定时间间隔内没有再次被消费，则认为是过期文件，可以被删除，RocketMQ不会关注这个文件上的消息是否全部被消费。默认每个文件的过期时间为72小时，通过在Broker配置文件中设置fileReservedTime来改变过期时间，单位为小时。</p>
<p><em><strong>代码：DefaultMessageStore#addScheduleTask</strong></em></p>
<pre><code class="java">private void addScheduleTask() &#123;
    //每隔10s调度一次清除文件
    this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;
        @Override
        public void run() &#123;
            DefaultMessageStore.this.cleanFilesPeriodically();
        &#125;
    &#125;, 1000 * 60, this.messageStoreConfig.getCleanResourceInterval(), TimeUnit.MILLISECONDS);
    ...
&#125;
</code></pre>
<p><em><strong>代码：DefaultMessageStore#cleanFilesPeriodically</strong></em></p>
<pre><code class="java">private void cleanFilesPeriodically() &#123;
    //清除存储文件
    this.cleanCommitLogService.run();
    //清除消息消费队列文件
    this.cleanConsumeQueueService.run();
&#125;
</code></pre>
<p><em><strong>代码：DefaultMessageStore#deleteExpiredFiles</strong></em></p>
<pre><code class="java">private void deleteExpiredFiles() &#123;
    //删除的数量
    int deleteCount = 0;
    //文件保留的时间
    long fileReservedTime = DefaultMessageStore.this.getMessageStoreConfig().getFileReservedTime();
    //删除物理文件的间隔
    int deletePhysicFilesInterval = DefaultMessageStore.this.getMessageStoreConfig().getDeleteCommitLogFilesInterval();
    //线程被占用,第一次拒绝删除后能保留的最大时间,超过该时间,文件将被强制删除
    int destroyMapedFileIntervalForcibly = DefaultMessageStore.this.getMessageStoreConfig().getDestroyMapedFileIntervalForcibly();

boolean timeup = this.isTimeToDelete();
boolean spacefull = this.isSpaceToDelete();
boolean manualDelete = this.manualDeleteFileSeveralTimes &gt; 0;
if (timeup || spacefull || manualDelete) &#123;
    ...执行删除逻辑
&#125;else&#123;
    ...无作为
&#125;
</code></pre>
<p>删除文件操作的条件</p>
<ol>
<li>指定删除文件的时间点，RocketMQ通过deleteWhen设置一天的固定时间执行一次删除过期文件操作，默认4点</li>
<li>磁盘空间如果不充足，删除过期文件</li>
<li>预留，手工触发。</li>
</ol>
<p><em><strong>代码：CleanCommitLogService#isSpaceToDelete</strong></em></p>
<p>当磁盘空间不足时执行删除过期文件</p>
<pre><code class="java">private boolean isSpaceToDelete() &#123;
    //磁盘分区的最大使用量
    double ratio = DefaultMessageStore.this.getMessageStoreConfig().getDiskMaxUsedSpaceRatio() / 100.0;
    //是否需要立即执行删除过期文件操作
    cleanImmediately = false;

    &#123;
        String storePathPhysic = DefaultMessageStore.this.getMessageStoreConfig().getStorePathCommitLog();
        //当前CommitLog目录所在的磁盘分区的磁盘使用率
        double physicRatio = UtilAll.getDiskPartitionSpaceUsedPercent(storePathPhysic);
        //diskSpaceWarningLevelRatio:磁盘使用率警告阈值,默认0.90
        if (physicRatio &gt; diskSpaceWarningLevelRatio) &#123;
            boolean diskok = DefaultMessageStore.this.runningFlags.getAndMakeDiskFull();
            if (diskok) &#123;
                DefaultMessageStore.log.error(&quot;physic disk maybe full soon &quot; + physicRatio + &quot;, so mark disk full&quot;);
            &#125;
            //diskSpaceCleanForciblyRatio:强制清除阈值,默认0.85
            cleanImmediately = true;
        &#125; else if (physicRatio &gt; diskSpaceCleanForciblyRatio) &#123;
            cleanImmediately = true;
        &#125; else &#123;
            boolean diskok = DefaultMessageStore.this.runningFlags.getAndMakeDiskOK();
            if (!diskok) &#123;
            DefaultMessageStore.log.info(&quot;physic disk space OK &quot; + physicRatio + &quot;, so mark disk ok&quot;);
        &#125;
    &#125;

    if (physicRatio &lt; 0 || physicRatio &gt; ratio) &#123;
        DefaultMessageStore.log.info(&quot;physic disk maybe full soon, so reclaim space, &quot; + physicRatio);
        return true;
    &#125;
&#125;
</code></pre>
<p><em><strong>代码：MappedFileQueue#deleteExpiredFileByTime</strong></em></p>
<p>执行文件销毁和删除</p>
<pre><code class="java">for (int i = 0; i &lt; mfsLength; i++) &#123;
    //遍历每隔文件
    MappedFile mappedFile = (MappedFile) mfs[i];
    //计算文件存活时间
    long liveMaxTimestamp = mappedFile.getLastModifiedTimestamp() + expiredTime;
    //如果超过72小时,执行文件删除
    if (System.currentTimeMillis() &gt;= liveMaxTimestamp || cleanImmediately) &#123;
        if (mappedFile.destroy(intervalForcibly)) &#123;
            files.add(mappedFile);
            deleteCount++;

            if (files.size() &gt;= DELETE_FILES_BATCH_MAX) &#123;
                break;
            &#125;

            if (deleteFilesInterval &gt; 0 &amp;&amp; (i + 1) &lt; mfsLength) &#123;
                try &#123;
                    Thread.sleep(deleteFilesInterval);
                &#125; catch (InterruptedException e) &#123;
                &#125;
            &#125;
        &#125; else &#123;
            break;
        &#125;
    &#125; else &#123;
        //avoid deleting files in the middle
        break;
    &#125;
&#125;
</code></pre>
<h3 id="2-4-9-小结"><a href="#2-4-9-小结" class="headerlink" title="2.4.9 小结"></a>2.4.9 小结</h3><p>RocketMQ的存储文件包括消息文件（Commitlog）、消息消费队列文件（ConsumerQueue）、Hash索引文件（IndexFile）、监测点文件（checkPoint）、abort（关闭异常文件）。单个消息存储文件、消息消费队列文件、Hash索引文件长度固定以便使用内存映射机制进行文件的读写操作。RocketMQ组织文件以文件的起始偏移量来命令文件，这样根据偏移量能快速定位到真实的物理文件。RocketMQ基于内存映射文件机制提供了同步刷盘和异步刷盘两种机制，异步刷盘是指在消息存储时先追加到内存映射文件，然后启动专门的刷盘线程定时将内存中的文件数据刷写到磁盘。</p>
<p>CommitLog，消息存储文件，RocketMQ为了保证消息发送的高吞吐量，采用单一文件存储所有主题消息，保证消息存储是完全的顺序写，但这样给文件读取带来了不便，为此RocketMQ为了方便消息消费构建了消息消费队列文件，基于主题与队列进行组织，同时RocketMQ为消息实现了Hash索引，可以为消息设置索引键，根据所以能够快速从CommitLog文件中检索消息。</p>
<p>当消息达到CommitLog后，会通过ReputMessageService线程接近实时地将消息转发给消息消费队列文件与索引文件。为了安全起见，RocketMQ引入abort文件，记录Broker的停机是否是正常关闭还是异常关闭，在重启Broker时为了保证CommitLog文件，消息消费队列文件与Hash索引文件的正确性，分别采用不同策略来恢复文件。</p>
<p>RocketMQ不会永久存储消息文件、消息消费队列文件，而是启动文件过期机制并在磁盘空间不足或者默认凌晨4点删除过期文件，文件保存72小时并且在删除文件时并不会判断该消息文件上的消息是否被消费。</p>
<h2 id="2-5-Consumer"><a href="#2-5-Consumer" class="headerlink" title="2.5 Consumer"></a>2.5 Consumer</h2><h3 id="2-5-1-消息消费概述"><a href="#2-5-1-消息消费概述" class="headerlink" title="2.5.1 消息消费概述"></a>2.5.1 消息消费概述</h3><p>消息消费以组的模式开展，一个消费组内可以包含多个消费者，每一个消费者组可订阅多个主题，消费组之间有ff式和广播模式两种消费模式。集群模式，主题下的同一条消息只允许被其中一个消费者消费。广播模式，主题下的同一条消息，将被集群内的所有消费者消费一次。消息服务器与消费者之间的消息传递也有两种模式：推模式、拉模式。所谓的拉模式，是消费端主动拉起拉消息请求，而推模式是消息达到消息服务器后，推送给消息消费者。RocketMQ消息推模式的实现基于拉模式，在拉模式上包装一层，一个拉取任务完成后开始下一个拉取任务。</p>
<p>集群模式下，多个消费者如何对消息队列进行负载呢？消息队列负载机制遵循一个通用思想：一个消息队列同一个时间只允许被一个消费者消费，一个消费者可以消费多个消息队列。</p>
<p>RocketMQ支持局部顺序消息消费，也就是保证同一个消息队列上的消息顺序消费。不支持消息全局顺序消费，如果要实现某一个主题的全局顺序消费，可以将该主题的队列数设置为1，牺牲高可用性。</p>
<p>###2.5.2 消息消费初探</p>
<p><strong><u>消息推送模式</u></strong></p>
<p><img src="/../imgs/blog20/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81.png"></p>
<p><strong><u>消息消费重要方法</u></strong></p>
<pre><code class="java">void sendMessageBack(final MessageExt msg, final int delayLevel, final String brokerName)：发送消息确认
Set&lt;MessageQueue&gt; fetchSubscribeMessageQueues(final String topic) :获取消费者对主题分配了那些消息队列
void registerMessageListener(final MessageListenerConcurrently messageListener)：注册并发事件监听器
void registerMessageListener(final MessageListenerOrderly messageListener)：注册顺序消息事件监听器
void subscribe(final String topic, final String subExpression)：基于主题订阅消息，消息过滤使用表达式
void subscribe(final String topic, final String fullClassName,final String filterClassSource)：基于主题订阅消息，消息过滤使用类模式
void subscribe(final String topic, final MessageSelector selector) ：订阅消息，并指定队列选择器
void unsubscribe(final String topic)：取消消息订阅
</code></pre>
<p><strong><u>DefaultMQPushConsumer</u></strong></p>
<p><img src="/../imgs/blog20/DefaultMQPushConsumer.png"></p>
<pre><code class="java">//消费者组
private String consumerGroup;	
//消息消费模式
private MessageModel messageModel = MessageModel.CLUSTERING;	
//指定消费开始偏移量（最大偏移量、最小偏移量、启动时间戳）开始消费
private ConsumeFromWhere consumeFromWhere = ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET;
//集群模式下的消息队列负载策略
private AllocateMessageQueueStrategy allocateMessageQueueStrategy;
//订阅信息
private Map&lt;String /* topic */, String /* sub expression */&gt; subscription = new HashMap&lt;String, String&gt;();
//消息业务监听器
private MessageListener messageListener;
//消息消费进度存储器
private OffsetStore offsetStore;
//消费者最小线程数量
private int consumeThreadMin = 20;
//消费者最大线程数量
private int consumeThreadMax = 20;
//并发消息消费时处理队列最大跨度
private int consumeConcurrentlyMaxSpan = 2000;
//每1000次流控后打印流控日志
private int pullThresholdForQueue = 1000;
//推模式下任务间隔时间
private long pullInterval = 0;
//推模式下任务拉取的条数,默认32条
private int pullBatchSize = 32;
//每次传入MessageListener#consumerMessage中消息的数量
private int consumeMessageBatchMaxSize = 1;
//是否每次拉取消息都订阅消息
private boolean postSubscriptionWhenPull = false;
//消息重试次数,-1代表16次
private int maxReconsumeTimes = -1;
//消息消费超时时间
private long consumeTimeout = 15;
</code></pre>
<h3 id="2-5-3-消费者启动流程"><a href="#2-5-3-消费者启动流程" class="headerlink" title="2.5.3 消费者启动流程"></a>2.5.3 消费者启动流程</h3><p><img src="/../imgs/blog20/%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png"></p>
<p><em><strong>代码：DefaultMQPushConsumerImpl#start</strong></em></p>
<pre><code class="java">public synchronized void start() throws MQClientException &#123;
    switch (this.serviceState) &#123;
        case CREATE_JUST:
            
                this.defaultMQPushConsumer.getMessageModel(), this.defaultMQPushConsumer.isUnitMode());
            this.serviceState = ServiceState.START_FAILED;
            //检查消息者是否合法
            this.checkConfig();
            //构建主题订阅信息
            this.copySubscription();
            //设置消费者客户端实例名称为进程ID
            if (this.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;
                this.defaultMQPushConsumer.changeInstanceNameToPID();
            &#125;
            //创建MQClient实例
            this.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook);
            //构建rebalanceImpl
            this.rebalanceImpl.setConsumerGroup(this.defaultMQPushConsumer.getConsumerGroup());
            this.rebalanceImpl.setMessageModel(this.defaultMQPushConsumer.getMessageModel());
            this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultMQPushConsumer.getAllocateMessageQueueStrategy());
            this.rebalanceImpl.setmQClientFactory(this.mQClientFactor
            this.pullAPIWrapper = new PullAPIWrapper(
                mQClientFactory,
                this.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());
            this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookLis
            if (this.defaultMQPushConsumer.getOffsetStore() != null) &#123;
                this.offsetStore = this.defaultMQPushConsumer.getOffsetStore();
            &#125; else &#123;
                   switch (this.defaultMQPushConsumer.getMessageModel()) &#123;
               
                   case BROADCASTING:	 //消息消费广播模式,将消费进度保存在本地
                       this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());
                           break;
                       case CLUSTERING:	//消息消费集群模式,将消费进度保存在远端Broker
                           this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());
                           break;
                       default:
                           break;
                   &#125;
                   this.defaultMQPushConsumer.setOffsetStore(this.offsetStore);
               &#125;
            this.offsetStore.load
            //创建顺序消息消费服务
            if (this.getMessageListenerInner() instanceof MessageListenerOrderly) &#123;
                this.consumeOrderly = true;
                this.consumeMessageService =
                    new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());
                //创建并发消息消费服务
            &#125; else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) &#123;
                this.consumeOrderly = false;
                this.consumeMessageService =
                    new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());
            &#125;
            //消息消费服务启动
            this.consumeMessageService.start();
            //注册消费者实例
            boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPushConsumer.getConsumerGroup(), this);
            
            if (!registerOK) &#123;
                this.serviceState = ServiceState.CREATE_JUST;
                this.consumeMessageService.shutdown();
                throw new MQClientException(&quot;The consumer group[&quot; + this.defaultMQPushConsumer.getConsumerGroup()
                    + &quot;] has been created before, specify another name please.&quot; + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),
                    null);
            //启动消费者客户端
            mQClientFactory.start();
            log.info(&quot;the consumer [&#123;&#125;] start OK.&quot;, this.defaultMQPushConsumer.getConsumerGroup());
            this.serviceState = ServiceState.RUNNING;
            break;
            case RUNNING:
            case START_FAILED:
        case SHUTDOWN_ALREADY:
            throw new MQClientException(&quot;The PushConsumer service state not OK, maybe started once, &quot;
                + this.serviceState
                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),
                null);
        default:
            break;
    &#125;

    this.updateTopicSubscribeInfoWhenSubscriptionChanged();
    this.mQClientFactory.checkClientInBroker();
    this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();
    this.mQClientFactory.rebalanceImmediately();
&#125;
</code></pre>
<h3 id="2-5-4-消息拉取"><a href="#2-5-4-消息拉取" class="headerlink" title="2.5.4 消息拉取"></a>2.5.4 消息拉取</h3><p>消息消费模式有两种模式：广播模式与集群模式。广播模式比较简单，每一个消费者需要拉取订阅主题下所有队列的消息。本文重点讲解集群模式。在集群模式下，同一个消费者组内有多个消息消费者，同一个主题存在多个消费队列，消费者通过负载均衡的方式消费消息。</p>
<p>消息队列负载均衡，通常的作法是一个消息队列在同一个时间只允许被一个消费消费者消费，一个消息消费者可以同时消费多个消息队列。</p>
<h4 id="1）PullMessageService实现机制"><a href="#1）PullMessageService实现机制" class="headerlink" title="1）PullMessageService实现机制"></a>1）PullMessageService实现机制</h4><p>从MQClientInstance的启动流程中可以看出，RocketMQ使用一个单独的线程PullMessageService来负责消息的拉取。</p>
<p><img src="/../imgs/blog20/pullMessageService%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6.png"></p>
<p><em><strong>代码：PullMessageService#run</strong></em></p>
<pre><code class="java">public void run() &#123;
    log.info(this.getServiceName() + &quot; service started&quot;);
    //循环拉取消息
    while (!this.isStopped()) &#123;
        try &#123;
            //从请求队列中获取拉取消息请求
            PullRequest pullRequest = this.pullRequestQueue.take();
            //拉取消息
            this.pullMessage(pullRequest);
        &#125; catch (InterruptedException ignored) &#123;
        &#125; catch (Exception e) &#123;
            log.error(&quot;Pull Message Service Run Method exception&quot;, e);
        &#125;
    &#125;

    log.info(this.getServiceName() + &quot; service end&quot;);
&#125;
</code></pre>
<p><u><strong>PullRequest</strong></u></p>
<p><img src="/../imgs/blog20/PullRequest.png"></p>
<pre><code class="java">private String consumerGroup;	//消费者组
private MessageQueue messageQueue;	//待拉取消息队列
private ProcessQueue processQueue;	//消息处理队列
private long nextOffset;	//待拉取的MessageQueue偏移量
private boolean lockedFirst = false;	//是否被锁定
</code></pre>
<p><em><strong>代码：PullMessageService#pullMessage</strong></em></p>
<pre><code class="java">private void pullMessage(final PullRequest pullRequest) &#123;
    //获得消费者实例
    final MQConsumerInner consumer = this.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());
    if (consumer != null) &#123;
        //强转为推送模式消费者
        DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;
        //推送消息
        impl.pullMessage(pullRequest);
    &#125; else &#123;
        log.warn(&quot;No matched consumer for the PullRequest &#123;&#125;, drop it&quot;, pullRequest);
    &#125;
&#125;
</code></pre>
<p>####2）ProcessQueue实现机制</p>
<p>ProcessQueue是MessageQueue在消费端的重现、快照。PullMessageService从消息服务器默认每次拉取32条消息，按照消息的队列偏移量顺序存放在ProcessQueue中，PullMessageService然后将消息提交到消费者消费线程池，消息成功消费后从ProcessQueue中移除。</p>
<p><img src="/../imgs/blog20/ProcessQueue.png"></p>
<p><strong><u>属性</u></strong></p>
<pre><code class="java">//消息容器
private final TreeMap&lt;Long, MessageExt&gt; msgTreeMap = new TreeMap&lt;Long, MessageExt&gt;();
//读写锁
private final ReadWriteLock lockTreeMap = new ReentrantReadWriteLock();
//ProcessQueue总消息树
private final AtomicLong msgCount = new AtomicLong();
//ProcessQueue队列最大偏移量
private volatile long queueOffsetMax = 0L;
//当前ProcessQueue是否被丢弃
private volatile boolean dropped = false;
//上一次拉取时间戳
private volatile long lastPullTimestamp = System.currentTimeMillis();
//上一次消费时间戳
private volatile long lastConsumeTimestamp = System.currentTimeMillis();
</code></pre>
<p><strong><u>方法</u></strong></p>
<pre><code class="java">//移除消费超时消息
public void cleanExpiredMsg(DefaultMQPushConsumer pushConsumer)
//添加消息
public boolean putMessage(final List&lt;MessageExt&gt; msgs)
//获取消息最大间隔
public long getMaxSpan()
//移除消息
public long removeMessage(final List&lt;MessageExt&gt; msgs)
//将consumingMsgOrderlyTreeMap中消息重新放在msgTreeMap,并清空consumingMsgOrderlyTreeMap   
public void rollback() 
//将consumingMsgOrderlyTreeMap消息清除,表示成功处理该批消息
public long commit()
//重新处理该批消息
public void makeMessageToCosumeAgain(List&lt;MessageExt&gt; msgs) 
//从processQueue中取出batchSize条消息
public List&lt;MessageExt&gt; takeMessags(final int batchSize)
</code></pre>
<h4 id="3）消息拉取基本流程"><a href="#3）消息拉取基本流程" class="headerlink" title="3）消息拉取基本流程"></a>3）消息拉取基本流程</h4><p>#####1.客户端发起拉取请求</p>
<p><img src="/../imgs/blog20/%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png"></p>
<p><em><strong>代码：DefaultMQPushConsumerImpl#pullMessage</strong></em></p>
<pre><code class="java">public void pullMessage(final PullRequest pullRequest) &#123;
    //从pullRequest获得ProcessQueue
    final ProcessQueue processQueue = pullRequest.getProcessQueue();
    //如果处理队列被丢弃,直接返回
    if (processQueue.isDropped()) &#123;
        log.info(&quot;the pull request[&#123;&#125;] is dropped.&quot;, pullRequest.toString());
        return;
    &#125;
    //如果处理队列未被丢弃,更新时间戳
    pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());

    try &#123;
        this.makeSureStateOK();
    &#125; catch (MQClientException e) &#123;
        log.warn(&quot;pullMessage exception, consumer state not ok&quot;, e);
        this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);
        return;
    &#125;
    //如果处理队列被挂起,延迟1s后再执行
    if (this.isPause()) &#123;
        log.warn(&quot;consumer was paused, execute pull request later. instanceName=&#123;&#125;, group=&#123;&#125;&quot;, this.defaultMQPushConsumer.getInstanceName(), this.defaultMQPushConsumer.getConsumerGroup());
        this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);
        return;
    &#125;
    //获得最大待处理消息数量
    long cachedMessageCount = processQueue.getMsgCount().get();
    //获得最大待处理消息大小
    long cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (1024 * 1024);
    //从数量进行流控
    if (cachedMessageCount &gt; this.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;
        this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);
        if ((queueFlowControlTimes++ % 1000) == 0) &#123;
            log.warn(
                &quot;the cached message count exceeds the threshold &#123;&#125;, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;,
                this.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);
        &#125;
        return;
    &#125;
    //从消息大小进行流控
    if (cachedMessageSizeInMiB &gt; this.defaultMQPushConsumer.getPullThresholdSizeForQueue()) &#123;
        this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);
        if ((queueFlowControlTimes++ % 1000) == 0) &#123;
            log.warn(
                &quot;the cached message size exceeds the threshold &#123;&#125; MiB, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;,
                this.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);
        &#125;
        return;
    &#125;
        //获得订阅信息
         final SubscriptionData subscriptionData = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());
        if (null == subscriptionData) &#123;
            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);
            log.warn(&quot;find the consumer&#39;s subscription failed, &#123;&#125;&quot;, pullRequest);
            return;
        //与服务端交互,获取消息
        this.pullAPIWrapper.pullKernelImpl(
        pullRequest.getMessageQueue(),
        subExpression,
        subscriptionData.getExpressionType(),
        subscriptionData.getSubVersion(),
        pullRequest.getNextOffset(),
        this.defaultMQPushConsumer.getPullBatchSize(),
        sysFlag,
        commitOffsetValue,
        BROKER_SUSPEND_MAX_TIME_MILLIS,
        CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,
        CommunicationMode.ASYNC,
        pullCallback
    );
            
&#125;
</code></pre>
<p>#####2.消息服务端Broker组装消息</p>
<p><img src="/../imgs/blog20/%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1%E7%AB%AFBroker%E7%BB%84%E8%A3%85%E6%B6%88%E6%81%AF.png"></p>
<p><em><strong>代码：PullMessageProcessor#processRequest</strong></em></p>
<pre><code class="java">//构建消息过滤器
MessageFilter messageFilter;
if (this.brokerController.getBrokerConfig().isFilterSupportRetry()) &#123;
    messageFilter = new ExpressionForRetryMessageFilter(subscriptionData, consumerFilterData,
        this.brokerController.getConsumerFilterManager());
&#125; else &#123;
    messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData,
        this.brokerController.getConsumerFilterManager());
&#125;
//调用MessageStore.getMessage查找消息
final GetMessageResult getMessageResult =
    this.brokerController.getMessageStore().getMessage(
                    requestHeader.getConsumerGroup(), //消费组名称								
                    requestHeader.getTopic(),	//主题名称
                    requestHeader.getQueueId(), //队列ID
                    requestHeader.getQueueOffset(), 	//待拉取偏移量
                    requestHeader.getMaxMsgNums(), 	//最大拉取消息条数
                    messageFilter	//消息过滤器
            );
</code></pre>
<p><em><strong>代码：DefaultMessageStore#getMessage</strong></em></p>
<pre><code class="java">GetMessageStatus status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;
long nextBeginOffset = offset;	//查找下一次队列偏移量
long minOffset = 0;		//当前消息队列最小偏移量
long maxOffset = 0;		//当前消息队列最大偏移量
GetMessageResult getResult = new GetMessageResult();
final long maxOffsetPy = this.commitLog.getMaxOffset();	//当前commitLog最大偏移量
//根据主题名称和队列编号获取消息消费队列
ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);

...
minOffset = consumeQueue.getMinOffsetInQueue();
maxOffset = consumeQueue.getMaxOffsetInQueue();
//消息偏移量异常情况校对下一次拉取偏移量
if (maxOffset == 0) &#123;	//表示当前消息队列中没有消息
    status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;
    nextBeginOffset = nextOffsetCorrection(offset, 0);
&#125; else if (offset &lt; minOffset) &#123;	//待拉取消息的偏移量小于队列的其实偏移量
    status = GetMessageStatus.OFFSET_TOO_SMALL;
    nextBeginOffset = nextOffsetCorrection(offset, minOffset);
&#125; else if (offset == maxOffset) &#123;	//待拉取偏移量为队列最大偏移量
    status = GetMessageStatus.OFFSET_OVERFLOW_ONE;
    nextBeginOffset = nextOffsetCorrection(offset, offset);
&#125; else if (offset &gt; maxOffset) &#123;	//偏移量越界
    status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;
    if (0 == minOffset) &#123;
        nextBeginOffset = nextOffsetCorrection(offset, minOffset);
    &#125; else &#123;
        nextBeginOffset = nextOffsetCorrection(offset, maxOffset);
    &#125;
&#125;
...
//根据偏移量从CommitLog中拉取32条消息
SelectMappedBufferResult selectResult = this.commitLog.getMessage(offsetPy, sizePy);
</code></pre>
<p><em><strong>代码：PullMessageProcessor#processRequest</strong></em></p>
<pre><code class="java">//根据拉取结果填充responseHeader
response.setRemark(getMessageResult.getStatus().name());
responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset());
responseHeader.setMinOffset(getMessageResult.getMinOffset());
responseHeader.setMaxOffset(getMessageResult.getMaxOffset());

//判断如果存在主从同步慢,设置下一次拉取任务的ID为主节点
switch (this.brokerController.getMessageStoreConfig().getBrokerRole()) &#123;
    case ASYNC_MASTER:
    case SYNC_MASTER:
        break;
    case SLAVE:
        if (!this.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123;
            response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);
            responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);
        &#125;
        break;
&#125;
...
//GetMessageResult与Response的Code转换
switch (getMessageResult.getStatus()) &#123;
    case FOUND:			//成功
        response.setCode(ResponseCode.SUCCESS);
        break;
    case MESSAGE_WAS_REMOVING:	//消息存放在下一个commitLog中
        response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);	//消息重试
        break;
    case NO_MATCHED_LOGIC_QUEUE:	//未找到队列
    case NO_MESSAGE_IN_QUEUE:	//队列中未包含消息
        if (0 != requestHeader.getQueueOffset()) &#123;
            response.setCode(ResponseCode.PULL_OFFSET_MOVED);
            requestHeader.getQueueOffset(),
            getMessageResult.getNextBeginOffset(),
            requestHeader.getTopic(),
            requestHeader.getQueueId(),
            requestHeader.getConsumerGroup()
            );
        &#125; else &#123;
            response.setCode(ResponseCode.PULL_NOT_FOUND);
        &#125;
        break;
    case NO_MATCHED_MESSAGE:	//未找到消息
        response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);
        break;
    case OFFSET_FOUND_NULL:	//消息物理偏移量为空
        response.setCode(ResponseCode.PULL_NOT_FOUND);
        break;
    case OFFSET_OVERFLOW_BADLY:	//offset越界
        response.setCode(ResponseCode.PULL_OFFSET_MOVED);
        // XXX: warn and notify me
        log.info(&quot;the request offset: &#123;&#125; over flow badly, broker max offset: &#123;&#125;, consumer: &#123;&#125;&quot;,
                requestHeader.getQueueOffset(), getMessageResult.getMaxOffset(), channel.remoteAddress());
        break;
    case OFFSET_OVERFLOW_ONE:	//offset在队列中未找到
        response.setCode(ResponseCode.PULL_NOT_FOUND);
        break;
    case OFFSET_TOO_SMALL:	//offset未在队列中
        response.setCode(ResponseCode.PULL_OFFSET_MOVED);
        requestHeader.getConsumerGroup(), 
        requestHeader.getTopic(), 
        requestHeader.getQueueOffset(),
        getMessageResult.getMinOffset(), channel.remoteAddress());
        break;
    default:
        assert false;
        break;
&#125;
...
//如果CommitLog标记可用,并且当前Broker为主节点,则更新消息消费进度
boolean storeOffsetEnable = brokerAllowSuspend;
storeOffsetEnable = storeOffsetEnable &amp;&amp; hasCommitOffsetFlag;
storeOffsetEnable = storeOffsetEnable
    &amp;&amp; this.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE;
if (storeOffsetEnable) &#123;
    this.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),
        requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());
&#125;
</code></pre>
<p>#####3.消息拉取客户端处理消息</p>
<p><img src="/../imgs/blog20/%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF.png"></p>
<p><em><strong>代码：MQClientAPIImpl#processPullResponse</strong></em></p>
<pre><code class="java">private PullResult processPullResponse(
    final RemotingCommand response) throws MQBrokerException, RemotingCommandException &#123;
    PullStatus pullStatus = PullStatus.NO_NEW_MSG;
       //判断响应结果
    switch (response.getCode()) &#123;
        case ResponseCode.SUCCESS:
            pullStatus = PullStatus.FOUND;
            break;
        case ResponseCode.PULL_NOT_FOUND:
            pullStatus = PullStatus.NO_NEW_MSG;
            break;
        case ResponseCode.PULL_RETRY_IMMEDIATELY:
            pullStatus = PullStatus.NO_MATCHED_MSG;
            break;
        case ResponseCode.PULL_OFFSET_MOVED:
            pullStatus = PullStatus.OFFSET_ILLEGAL;
            break;

        default:
            throw new MQBrokerException(response.getCode(), response.getRemark());
    &#125;
    //解码响应头
    PullMessageResponseHeader responseHeader =
        (PullMessageResponseHeader) response.decodeCommandCustomHeader(PullMessageResponseHeader.class);
    //封装PullResultExt返回
    return new PullResultExt(pullStatus, responseHeader.getNextBeginOffset(), responseHeader.getMinOffset(),
        responseHeader.getMaxOffset(), null, responseHeader.getSuggestWhichBrokerId(), response.getBody());
&#125;
</code></pre>
<p><u><strong>PullResult类</strong></u></p>
<pre><code class="java">private final PullStatus pullStatus;	//拉取结果
private final long nextBeginOffset;	//下次拉取偏移量
private final long minOffset;	//消息队列最小偏移量
private final long maxOffset;	//消息队列最大偏移量
private List&lt;MessageExt&gt; msgFoundList;	//拉取的消息列表
</code></pre>
<p><img src="/../imgs/blog20/PullStatus.png"></p>
<p><em><strong>代码：DefaultMQPushConsumerImpl$PullCallback#OnSuccess</strong></em></p>
<pre><code class="java">//将拉取到的消息存入processQueue
boolean dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());
//将processQueue提交到consumeMessageService中供消费者消费
DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(
    pullResult.getMsgFoundList(),
    processQueue,
    pullRequest.getMessageQueue(),
    dispatchToConsume);
//如果pullInterval大于0,则等待pullInterval毫秒后将pullRequest对象放入到PullMessageService中的pullRequestQueue队列中
if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() &gt; 0) &#123;
    DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest,
        DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval());
&#125; else &#123;
    DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);
&#125;
</code></pre>
<h5 id="4-消息拉取总结"><a href="#4-消息拉取总结" class="headerlink" title="4.消息拉取总结"></a>4.消息拉取总结</h5><p><img src="/../imgs/blog20/%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93.png"></p>
<h4 id="4）消息拉取长轮询机制分析"><a href="#4）消息拉取长轮询机制分析" class="headerlink" title="4）消息拉取长轮询机制分析"></a>4）消息拉取长轮询机制分析</h4><p>RocketMQ未真正实现消息推模式，而是消费者主动向消息服务器拉取消息，RocketMQ推模式是循环向消息服务端发起消息拉取请求，如果消息消费者向RocketMQ拉取消息时，消息未到达消费队列时，如果不启用长轮询机制，则会在服务端等待shortPollingTimeMills时间后（挂起）再去判断消息是否已经到达指定消息队列，如果消息仍未到达则提示拉取消息客户端PULL—NOT—FOUND（消息不存在）；如果开启长轮询模式，RocketMQ一方面会每隔5s轮询检查一次消息是否可达，同时一有消息达到后立马通知挂起线程再次验证消息是否是自己感兴趣的消息，如果是则从CommitLog文件中提取消息返回给消息拉取客户端，否则直到挂起超时，超时时间由消息拉取方在消息拉取是封装在请求参数中，PUSH模式为15s，PULL模式通过DefaultMQPullConsumer#setBrokerSuspendMaxTimeMillis设置。RocketMQ通过在Broker客户端配置longPollingEnable为true来开启长轮询模式。</p>
<p><em><strong>代码：PullMessageProcessor#processRequest</strong></em></p>
<pre><code class="java">//当没有拉取到消息时，通过长轮询方式继续拉取消息
case ResponseCode.PULL_NOT_FOUND:
    if (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;
        long pollingTimeMills = suspendTimeoutMillisLong;
        if (!this.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;
            pollingTimeMills = this.brokerController.getBrokerConfig().getShortPollingTimeMills();
        &#125;

        String topic = requestHeader.getTopic();
        long offset = requestHeader.getQueueOffset();
        int queueId = requestHeader.getQueueId();
        //构建拉取请求对象
        PullRequest pullRequest = new PullRequest(request, channel, pollingTimeMills,
            this.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);
        //处理拉取请求
        this.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);
        response = null;
        break;
    &#125;
</code></pre>
<p><strong><u>PullRequestHoldService方式实现长轮询</u></strong></p>
<p><em><strong>代码：PullRequestHoldService#suspendPullRequest</strong></em></p>
<pre><code class="java">//将拉取消息请求，放置在ManyPullRequest集合中
public void suspendPullRequest(final String topic, final int queueId, final PullRequest pullRequest) &#123;
    String key = this.buildKey(topic, queueId);
    ManyPullRequest mpr = this.pullRequestTable.get(key);
    if (null == mpr) &#123;
        mpr = new ManyPullRequest();
        ManyPullRequest prev = this.pullRequestTable.putIfAbsent(key, mpr);
        if (prev != null) &#123;
            mpr = prev;
        &#125;
    &#125;

    mpr.addPullRequest(pullRequest);
&#125;
</code></pre>
<p><em><strong>代码：PullRequestHoldService#run</strong></em></p>
<pre><code class="java">public void run() &#123;
    log.info(&quot;&#123;&#125; service started&quot;, this.getServiceName());
    while (!this.isStopped()) &#123;
        try &#123;
            //如果开启长轮询每隔5秒判断消息是否到达
            if (this.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;
                this.waitForRunning(5 * 1000);
            &#125; else &#123;
                //没有开启长轮询,每隔1s再次尝试
              this.waitForRunning(this.brokerController.getBrokerConfig().getShortPollingTimeMills());
            &#125;

            long beginLockTimestamp = this.systemClock.now();
            this.checkHoldRequest();
            long costTime = this.systemClock.now() - beginLockTimestamp;
            if (costTime &gt; 5 * 1000) &#123;
                log.info(&quot;[NOTIFYME] check hold request cost &#123;&#125; ms.&quot;, costTime);
            &#125;
        &#125; catch (Throwable e) &#123;
            log.warn(this.getServiceName() + &quot; service has exception. &quot;, e);
        &#125;
    &#125;

    log.info(&quot;&#123;&#125; service end&quot;, this.getServiceName());
&#125;
</code></pre>
<p><em><strong>代码：PullRequestHoldService#checkHoldRequest</strong></em></p>
<pre><code class="java">//遍历拉取任务
private void checkHoldRequest() &#123;
    for (String key : this.pullRequestTable.keySet()) &#123;
        String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR);
        if (2 == kArray.length) &#123;
            String topic = kArray[0];
            int queueId = Integer.parseInt(kArray[1]);
            //获得消息偏移量
            final long offset = this.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId);
            try &#123;
                //通知有消息达到
                this.notifyMessageArriving(topic, queueId, offset);
            &#125; catch (Throwable e) &#123;
                log.error(&quot;check hold request failed. topic=&#123;&#125;, queueId=&#123;&#125;&quot;, topic, queueId, e);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><em><strong>代码：PullRequestHoldService#notifyMessageArriving</strong></em></p>
<pre><code class="java">//如果拉取消息偏移大于请求偏移量,如果消息匹配调用executeRequestWhenWakeup处理消息
if (newestOffset &gt; request.getPullFromThisOffset()) &#123;
    boolean match = request.getMessageFilter().isMatchedByConsumeQueue(tagsCode,
        new ConsumeQueueExt.CqExtUnit(tagsCode, msgStoreTime, filterBitMap));
    // match by bit map, need eval again when properties is not null.
    if (match &amp;&amp; properties != null) &#123;
        match = request.getMessageFilter().isMatchedByCommitLog(null, properties);
    &#125;

    if (match) &#123;
        try &#123;
            this.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),
                request.getRequestCommand());
        &#125; catch (Throwable e) &#123;
            log.error(&quot;execute request when wakeup failed.&quot;, e);
        &#125;
        continue;
    &#125;
&#125;
//如果过期时间超时,则不继续等待将直接返回给客户端消息未找到
if (System.currentTimeMillis() &gt;= (request.getSuspendTimestamp() + request.getTimeoutMillis())) &#123;
    try &#123;
        this.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),
            request.getRequestCommand());
    &#125; catch (Throwable e) &#123;
        log.error(&quot;execute request when wakeup failed.&quot;, e);
    &#125;
    continue;
&#125;
</code></pre>
<p>如果开启了长轮询机制，PullRequestHoldService会每隔5s被唤醒去尝试检测是否有新的消息的到来才给客户端响应，或者直到超时才给客户端进行响应，消息实时性比较差，为了避免这种情况，RocketMQ引入另外一种机制：当消息到达时唤醒挂起线程触发一次检查。</p>
<p><strong><u>DefaultMessageStore$ReputMessageService机制</u></strong></p>
<p><em><strong>代码：DefaultMessageStore#start</strong></em></p>
<pre><code class="java">//长轮询入口
this.reputMessageService.setReputFromOffset(maxPhysicalPosInLogicQueue);
this.reputMessageService.start();
</code></pre>
<p><em><strong>代码：DefaultMessageStore$ReputMessageService#run</strong></em></p>
<pre><code class="java">public void run() &#123;
    DefaultMessageStore.log.info(this.getServiceName() + &quot; service started&quot;);

    while (!this.isStopped()) &#123;
        try &#123;
            Thread.sleep(1);
            //长轮询核心逻辑代码入口
            this.doReput();
        &#125; catch (Exception e) &#123;
            DefaultMessageStore.log.warn(this.getServiceName() + &quot; service has exception. &quot;, e);
        &#125;
    &#125;

    DefaultMessageStore.log.info(this.getServiceName() + &quot; service end&quot;);
&#125;
</code></pre>
<p><em><strong>代码：DefaultMessageStore$ReputMessageService#deReput</strong></em></p>
<pre><code class="java">//当新消息达到是,进行通知监听器进行处理
if (BrokerRole.SLAVE != DefaultMessageStore.this.getMessageStoreConfig().getBrokerRole()
    &amp;&amp; DefaultMessageStore.this.brokerConfig.isLongPollingEnable()) &#123;
    DefaultMessageStore.this.messageArrivingListener.arriving(dispatchRequest.getTopic(),
        dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + 1,
        dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(),
        dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap());
&#125;
</code></pre>
<p><em><strong>代码：NotifyMessageArrivingListener#arriving</strong></em></p>
<pre><code class="java">public void arriving(String topic, int queueId, long logicOffset, long tagsCode,
    long msgStoreTime, byte[] filterBitMap, Map&lt;String, String&gt; properties) &#123;
    this.pullRequestHoldService.notifyMessageArriving(topic, queueId, logicOffset, tagsCode,
        msgStoreTime, filterBitMap, properties);
&#125;
</code></pre>
<h3 id="2-5-5-消息队列负载与重新分布机制"><a href="#2-5-5-消息队列负载与重新分布机制" class="headerlink" title="2.5.5 消息队列负载与重新分布机制"></a>2.5.5 消息队列负载与重新分布机制</h3><p>RocketMQ消息队列重新分配是由RebalanceService线程来实现。一个MQClientInstance持有一个RebalanceService实现，并随着MQClientInstance的启动而启动。</p>
<p><em><strong>代码：RebalanceService#run</strong></em></p>
<pre><code class="java">public void run() &#123;
    log.info(this.getServiceName() + &quot; service started&quot;);
    //RebalanceService线程默认每隔20s执行一次mqClientFactory.doRebalance方法
    while (!this.isStopped()) &#123;
        this.waitForRunning(waitInterval);
        this.mqClientFactory.doRebalance();
    &#125;

    log.info(this.getServiceName() + &quot; service end&quot;);
&#125;
</code></pre>
<p><em><strong>代码：MQClientInstance#doRebalance</strong></em></p>
<pre><code class="java">public void doRebalance() &#123;
    //MQClientInstance遍历以注册的消费者,对消费者执行doRebalance()方法
    for (Map.Entry&lt;String, MQConsumerInner&gt; entry : this.consumerTable.entrySet()) &#123;
        MQConsumerInner impl = entry.getValue();
        if (impl != null) &#123;
            try &#123;
                impl.doRebalance();
            &#125; catch (Throwable e) &#123;
                log.error(&quot;doRebalance exception&quot;, e);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><em><strong>代码：RebalanceImpl#doRebalance</strong></em></p>
<pre><code class="java">//遍历订阅消息对每个主题的订阅的队列进行重新负载
public void doRebalance(final boolean isOrder) &#123;
    Map&lt;String, SubscriptionData&gt; subTable = this.getSubscriptionInner();
    if (subTable != null) &#123;
        for (final Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) &#123;
            final String topic = entry.getKey();
            try &#123;
                this.rebalanceByTopic(topic, isOrder);
            &#125; catch (Throwable e) &#123;
                if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;
                    log.warn(&quot;rebalanceByTopic Exception&quot;, e);
                &#125;
            &#125;
        &#125;
    &#125;

    this.truncateMessageQueueNotMyTopic();
&#125;
</code></pre>
<p><em><strong>代码：RebalanceImpl#rebalanceByTopic</strong></em></p>
<pre><code class="java">//从主题订阅消息缓存表中获取主题的队列信息
Set&lt;MessageQueue&gt; mqSet = this.topicSubscribeInfoTable.get(topic);
//查找该主题订阅组所有的消费者ID
List&lt;String&gt; cidAll = this.mQClientFactory.findConsumerIdList(topic, consumerGroup);

//给消费者重新分配队列
if (mqSet != null &amp;&amp; cidAll != null) &#123;
    List&lt;MessageQueue&gt; mqAll = new ArrayList&lt;MessageQueue&gt;();
    mqAll.addAll(mqSet);

    Collections.sort(mqAll);
    Collections.sort(cidAll);

    AllocateMessageQueueStrategy strategy = this.allocateMessageQueueStrategy;

    List&lt;MessageQueue&gt; allocateResult = null;
    try &#123;
        allocateResult = strategy.allocate(
            this.consumerGroup,
            this.mQClientFactory.getClientId(),
            mqAll,
            cidAll);
    &#125; catch (Throwable e) &#123;
        log.error(&quot;AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;&quot;, strategy.getName(),
            e);
        return;
    &#125;
</code></pre>
<p>RocketMQ默认提供5中负载均衡分配算法</p>
<pre><code class="java">AllocateMessageQueueAveragely:平均分配
举例:8个队列q1,q2,q3,q4,q5,a6,q7,q8,消费者3个:c1,c2,c3
分配如下:
c1:q1,q2,q3
c2:q4,q5,a6
c3:q7,q8
AllocateMessageQueueAveragelyByCircle:平均轮询分配
举例:8个队列q1,q2,q3,q4,q5,a6,q7,q8,消费者3个:c1,c2,c3
分配如下:
c1:q1,q4,q7
c2:q2,q5,a8
c3:q3,q6
</code></pre>
<p>注意：消息队列的分配遵循一个消费者可以分配到多个队列，但同一个消息队列只会分配给一个消费者，故如果出现消费者个数大于消息队列数量，则有些消费者无法消费消息。</p>
<h3 id="2-5-6-消息消费过程"><a href="#2-5-6-消息消费过程" class="headerlink" title="2.5.6 消息消费过程"></a>2.5.6 消息消费过程</h3><p>PullMessageService负责对消息队列进行消息拉取，从远端服务器拉取消息后将消息存储ProcessQueue消息队列处理队列中，然后调用ConsumeMessageService#submitConsumeRequest方法进行消息消费，使用线程池来消费消息，确保了消息拉取与消息消费的解耦。ConsumeMessageService支持顺序消息和并发消息，核心类图如下：</p>
<p><img src="/../imgs/blog20/ConsumeMessageService.png"></p>
<p><strong><u>并发消息消费</u></strong></p>
<p><em><strong>代码：ConsumeMessageConcurrentlyService#submitConsumeRequest</strong></em></p>
<pre><code class="java">//消息批次单次
final int consumeBatchSize = this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();
//msgs.size()默认最多为32条。
//如果msgs.size()小于consumeBatchSize,则直接将拉取到的消息放入到consumeRequest,然后将consumeRequest提交到消费者线程池中
if (msgs.size() &lt;= consumeBatchSize) &#123;
    ConsumeRequest consumeRequest = new ConsumeRequest(msgs, processQueue, messageQueue);
    try &#123;
        this.consumeExecutor.submit(consumeRequest);
    &#125; catch (RejectedExecutionException e) &#123;
        this.submitConsumeRequestLater(consumeRequest);
    &#125;
&#125;else&#123;	//如果拉取的消息条数大于consumeBatchSize,则对拉取消息进行分页
       for (int total = 0; total &lt; msgs.size(); ) &#123;
               List&lt;MessageExt&gt; msgThis = new ArrayList&lt;MessageExt&gt;(consumeBatchSize);
               for (int i = 0; i &lt; consumeBatchSize; i++, total++) &#123;
                   if (total &lt; msgs.size()) &#123;
                       msgThis.add(msgs.get(total));
                   &#125; else &#123;
                       break;
                   &#125;
           
               ConsumeRequest consumeRequest = new ConsumeRequest(msgThis, processQueue, messageQueue);
               try &#123;
                   this.consumeExecutor.submit(consumeRequest);
               &#125; catch (RejectedExecutionException e) &#123;
                   for (; total &lt; msgs.size(); total++) &#123;
                       msgThis.add(msgs.get(total));
            
                   this.submitConsumeRequestLater(consumeRequest);
               &#125;
           &#125;
&#125;
</code></pre>
<p><em><strong>代码：ConsumeMessageConcurrentlyService$ConsumeRequest#run</strong></em></p>
<pre><code class="java">//检查processQueue的dropped,如果为true,则停止该队列消费。
if (this.processQueue.isDropped()) &#123;
    log.info(&quot;the message queue not be able to consume, because it&#39;s dropped. group=&#123;&#125; &#123;&#125;&quot;, ConsumeMessageConcurrentlyService.this.consumerGroup, this.messageQueue);
    return;
&#125;

...
//执行消息处理的钩子函数
if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) &#123;
    consumeMessageContext = new ConsumeMessageContext();
    consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace());
    consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());
    consumeMessageContext.setProps(new HashMap&lt;String, String&gt;());
    consumeMessageContext.setMq(messageQueue);
    consumeMessageContext.setMsgList(msgs);
    consumeMessageContext.setSuccess(false);
    ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);
&#125;
...
//调用应用程序消息监听器的consumeMessage方法,进入到具体的消息消费业务处理逻辑
status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);

//执行消息处理后的钩子函数
if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) &#123;
    consumeMessageContext.setStatus(status.toString());
    consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status);
    ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);
&#125;
</code></pre>
<h3 id="2-5-7-定时消息机制"><a href="#2-5-7-定时消息机制" class="headerlink" title="2.5.7 定时消息机制"></a>2.5.7 定时消息机制</h3><p>定时消息是消息发送到Broker后，并不立即被消费者消费而是要等到特定的时间后才能被消费，RocketMQ并不支持任意的时间精度，如果要支持任意时间精度定时调度，不可避免地需要在Broker层做消息排序，再加上持久化方面的考量，将不可避免的带来巨大的性能消耗，所以RocketMQ只支持特定级别的延迟消息。消息延迟级别在Broker端通过messageDelayLevel配置，默认为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，delayLevel&#x3D;1表示延迟消息1s,delayLevel&#x3D;2表示延迟5s,依次类推。</p>
<p>RocketMQ定时消息实现类为ScheduleMessageService，该类在DefaultMessageStore中创建。通过在DefaultMessageStore中调用load方法加载该类并调用start方法启动。</p>
<p><em><strong>代码：ScheduleMessageService#load</strong></em></p>
<pre><code class="java">//加载延迟消息消费进度的加载与delayLevelTable的构造。延迟消息的进度默认存储路径为/store/config/delayOffset.json
public boolean load() &#123;
    boolean result = super.load();
    result = result &amp;&amp; this.parseDelayLevel();
    return result;
&#125;
</code></pre>
<p><em><strong>代码：ScheduleMessageService#start</strong></em></p>
<pre><code class="java">//遍历延迟队列创建定时任务,遍历延迟级别，根据延迟级别level从offsetTable中获取消费队列的消费进度。如果不存在，则使用0
for (Map.Entry&lt;Integer, Long&gt; entry : this.delayLevelTable.entrySet()) &#123;
    Integer level = entry.getKey();
    Long timeDelay = entry.getValue();
    Long offset = this.offsetTable.get(level);
    if (null == offset) &#123;
        offset = 0L;
    &#125;

    if (timeDelay != null) &#123;
        this.timer.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);
    &#125;
&#125;

//每隔10s持久化一次延迟队列的消息消费进度
this.timer.scheduleAtFixedRate(new TimerTask() &#123;

    @Override
    public void run() &#123;
        try &#123;
            if (started.get()) ScheduleMessageService.this.persist();
        &#125; catch (Throwable e) &#123;
            log.error(&quot;scheduleAtFixedRate flush exception&quot;, e);
        &#125;
    &#125;
&#125;, 10000, this.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval());
</code></pre>
<p><strong><u>调度机制</u></strong></p>
<p>ScheduleMessageService的start方法启动后，会为每一个延迟级别创建一个调度任务，每一个延迟级别对应SCHEDULE_TOPIC_XXXX主题下的一个消息消费队列。定时调度任务的实现类为DeliverDelayedMessageTimerTask，核心实现方法为executeOnTimeup</p>
<p><em><strong>代码：ScheduleMessageService$DeliverDelayedMessageTimerTask#executeOnTimeup</strong></em></p>
<pre><code class="java">//根据队列ID与延迟主题查找消息消费队列
ConsumeQueue cq =
    ScheduleMessageService.this.defaultMessageStore.findConsumeQueue(SCHEDULE_TOPIC,
        delayLevel2QueueId(delayLevel));
...
//根据偏移量从消息消费队列中获取当前队列中所有有效的消息
SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(this.offset);

...
//遍历ConsumeQueue,解析消息队列中消息
for (; i &lt; bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;
    long offsetPy = bufferCQ.getByteBuffer().getLong();
    int sizePy = bufferCQ.getByteBuffer().getInt();
    long tagsCode = bufferCQ.getByteBuffer().getLong();

    if (cq.isExtAddr(tagsCode)) &#123;
        if (cq.getExt(tagsCode, cqExtUnit)) &#123;
            tagsCode = cqExtUnit.getTagsCode();
        &#125; else &#123;
            //can&#39;t find ext content.So re compute tags code.
            log.error(&quot;[BUG] can&#39;t find consume queue extend file content!addr=&#123;&#125;, offsetPy=&#123;&#125;, sizePy=&#123;&#125;&quot;,
                tagsCode, offsetPy, sizePy);
            long msgStoreTime = defaultMessageStore.getCommitLog().pickupStoreTimestamp(offsetPy, sizePy);
            tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime);
        &#125;
    &#125;

    long now = System.currentTimeMillis();
    long deliverTimestamp = this.correctDeliverTimestamp(now, tagsCode);
    
    ...
    //根据消息偏移量与消息大小,从CommitLog中查找消息.
      MessageExt msgExt =
   ScheduleMessageService.this.defaultMessageStore.lookMessageByOffset(
       offsetPy, sizePy);
&#125; 
</code></pre>
<h3 id="2-5-8-顺序消息"><a href="#2-5-8-顺序消息" class="headerlink" title="2.5.8 顺序消息"></a>2.5.8 顺序消息</h3><p>顺序消息实现类是org.apache.rocketmq.client.impl.consumer.ConsumeMessageOrderlyService</p>
<p><em><strong>代码：ConsumeMessageOrderlyService#start</strong></em></p>
<pre><code class="java">public void start() &#123;
    //如果消息模式为集群模式，启动定时任务，默认每隔20s执行一次锁定分配给自己的消息消费队列
    if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())) &#123;
        this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;
            @Override
            public void run() &#123;
                ConsumeMessageOrderlyService.this.lockMQPeriodically();
            &#125;
        &#125;, 1000 * 1, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);
    &#125;
&#125;
</code></pre>
<p><em><strong>代码：ConsumeMessageOrderlyService#submitConsumeRequest</strong></em></p>
<pre><code class="java">//构建消息任务,并提交消费线程池中
public void submitConsumeRequest(
    final List&lt;MessageExt&gt; msgs,
    final ProcessQueue processQueue,
    final MessageQueue messageQueue,
    final boolean dispathToConsume) &#123;
    if (dispathToConsume) &#123;
        ConsumeRequest consumeRequest = new ConsumeRequest(processQueue, messageQueue);
        this.consumeExecutor.submit(consumeRequest);
    &#125;
&#125;
</code></pre>
<p><em><strong>代码：ConsumeMessageOrderlyService$ConsumeRequest#run</strong></em></p>
<pre><code class="java">//如果消息队列为丢弃,则停止本次消费任务
if (this.processQueue.isDropped()) &#123;
    log.warn(&quot;run, the message queue not be able to consume, because it&#39;s dropped. &#123;&#125;&quot;, this.messageQueue);
    return;
&#125;
//从消息队列中获取一个对象。然后消费消息时先申请独占objLock锁。顺序消息一个消息消费队列同一时刻只会被一个消费线程池处理
final Object objLock = messageQueueLock.fetchLockObject(this.messageQueue);
synchronized (objLock) &#123;
    ...
&#125;
</code></pre>
<h3 id="2-5-9-小结"><a href="#2-5-9-小结" class="headerlink" title="2.5.9 小结"></a>2.5.9 小结</h3><p>RocketMQ消息消费方式分别为集群模式、广播模式。</p>
<p>消息队列负载由RebalanceService线程默认每隔20s进行一次消息队列负载，根据当前消费者组内消费者个数与主题队列数量按照某一种负载算法进行队列分配，分配原则为同一个消费者可以分配多个消息消费队列，同一个消息消费队列同一个时间只会分配给一个消费者。</p>
<p>消息拉取由PullMessageService线程根据RebalanceService线程创建的拉取任务进行拉取，默认每次拉取32条消息，提交给消费者消费线程后继续下一次消息拉取。如果消息消费过慢产生消息堆积会触发消息消费拉取流控。 </p>
<p>并发消息消费指消费线程池中的线程可以并发对同一个消息队列的消息进行消费，消费成功后，取出消息队列中最小的消息偏移量作为消息消费进度偏移量存储在于消息消费进度存储文件中，集群模式消息消费进度存储在Broker（消息服务器），广播模式消息消费进度存储在消费者端。</p>
<p>RocketMQ不支持任意精度的定时调度消息，只支持自定义的消息延迟级别，例如1s、2s、5s等，可通过在broker配置文件中设置messageDelayLevel。</p>
<p>顺序消息一般使用集群模式，是指对消息消费者内的线程池中的线程对消息消费队列只能串行消费。并并发消息消费最本质的区别是消息消费时必须成功锁定消息消费队列，在Broker端会存储消息消费队列的锁占用情况。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Mercury</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/06/20/blog20/">http://example.com/2023/06/20/blog20/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Mercury个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/21/blog21/" title="分布式ID"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">分布式ID</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/19/blog19/" title="RocketMQ消费者负载均衡"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">RocketMQ消费者负载均衡</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/19/blog18/" title="RocketMQ事务消息"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-19</div><div class="title">RocketMQ事务消息</div></div></a></div><div><a href="/2023/06/19/blog19/" title="RocketMQ消费者负载均衡"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-19</div><div class="title">RocketMQ消费者负载均衡</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODUzMS8zNDk5NA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Mercury</div><div class="author-info__description">我不知将去何方，但我已在路上</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Mercury4915"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">java学习日记，不定时更新</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD"><span class="toc-number">1.</span> <span class="toc-text">1. 高级功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 消息存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1 存储介质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3-%E6%B6%88%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E5%8F%91%E9%80%81"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.3 消息的存储和发送</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1）消息存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-4-%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.1.4 消息存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-5-%E5%88%B7%E7%9B%98%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.1.5 刷盘机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E5%90%8C%E6%AD%A5%E5%88%B7%E7%9B%98"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1）同步刷盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%BC%82%E6%AD%A5%E5%88%B7%E7%9B%98"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">2）异步刷盘</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 高可用性机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1 消息消费高可用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2 消息发送高可用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E6%B6%88%E6%81%AF%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2.3 消息主从复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-Producer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1 Producer负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-Consumer%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2 Consumer负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">1）集群模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 消息重试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%8D%E8%AF%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.4.1 顺序消息的重试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E6%97%A0%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%8D%E8%AF%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.4.2 无序消息的重试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">1）重试次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">2）配置方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 死信队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-%E6%AD%BB%E4%BF%A1%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.5.1 死信特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-%E6%9F%A5%E7%9C%8B%E6%AD%BB%E4%BF%A1%E4%BF%A1%E6%81%AF"><span class="toc-number">1.5.2.</span> <span class="toc-text">1.5.2 查看死信信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E6%B6%88%E8%B4%B9%E5%B9%82%E7%AD%89"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 消费幂等</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-1-%E6%B6%88%E8%B4%B9%E5%B9%82%E7%AD%89%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.6.1 消费幂等的必要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-2-%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.2.</span> <span class="toc-text">1.6.2 处理方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">2. 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E6%BA%90%E7%A0%81%E6%8B%89%E5%8F%96"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1 源码拉取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E8%B0%83%E8%AF%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.3 调试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E5%90%AF%E5%8A%A8NameServer"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">1）启动NameServer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%90%AF%E5%8A%A8Broker"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">2）启动Broker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">4）消费消息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-NameServer"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 NameServer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 架构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%BA%8C"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">步骤二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%89"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">步骤三</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3 路由管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-1-%E8%B7%AF%E7%94%B1%E5%85%83%E4%BF%A1%E6%81%AF"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">2.2.3.1 路由元信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-2-%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%86%8C"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">2.2.3.2 路由注册</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E5%A4%84%E7%90%86%E5%BF%83%E8%B7%B3%E5%8C%85"><span class="toc-number">2.2.3.2.1.</span> <span class="toc-text">2）处理心跳包</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-3-%E8%B7%AF%E7%94%B1%E5%88%A0%E9%99%A4"><span class="toc-number">2.2.3.3.</span> <span class="toc-text">2.2.3.3 路由删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-4-%E8%B7%AF%E7%94%B1%E5%8F%91%E7%8E%B0"><span class="toc-number">2.2.3.4.</span> <span class="toc-text">2.2.3.4 路由发现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E5%B0%8F%E7%BB%93"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.2.4 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Producer"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 Producer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.2 启动流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.3 消息发送</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E9%80%89%E6%8B%A9%E9%98%9F%E5%88%97"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">3）选择队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.4 批量消息发送</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 消息存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.2 消息存储流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.3 存储文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">2.4.3.</span> <span class="toc-text">2.4.4 存储文件内存映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89TransientStorePool"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">3）TransientStorePool</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-5-%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E9%98%9F%E5%88%97%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="toc-number">2.4.4.</span> <span class="toc-text">2.4.5 实时更新消息消费队列与索引文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E8%BD%AC%E5%8F%91%E5%88%B0ConsumerQueue"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">1）转发到ConsumerQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E8%BD%AC%E5%8F%91%E5%88%B0Index"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">2）转发到Index</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-6-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D"><span class="toc-number">2.4.5.</span> <span class="toc-text">2.4.6 消息队列和索引文件恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-7-%E5%88%B7%E7%9B%98%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.6.</span> <span class="toc-text">2.4.7 刷盘机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%88%B7%E7%9B%98"><span class="toc-number">2.4.6.1.</span> <span class="toc-text">同步刷盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%88%B7%E7%9B%98"><span class="toc-number">2.4.6.2.</span> <span class="toc-text">异步刷盘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-8-%E8%BF%87%E6%9C%9F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.7.</span> <span class="toc-text">2.4.8 过期文件删除机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-9-%E5%B0%8F%E7%BB%93"><span class="toc-number">2.4.8.</span> <span class="toc-text">2.4.9 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-Consumer"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 Consumer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E6%A6%82%E8%BF%B0"><span class="toc-number">2.5.1.</span> <span class="toc-text">2.5.1 消息消费概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-%E6%B6%88%E8%B4%B9%E8%80%85%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">2.5.3 消费者启动流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-4-%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96"><span class="toc-number">2.5.3.</span> <span class="toc-text">2.5.4 消息拉取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89PullMessageService%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">1）PullMessageService实现机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">2.5.3.2.</span> <span class="toc-text">3）消息拉取基本流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E6%80%BB%E7%BB%93"><span class="toc-number">2.5.3.2.1.</span> <span class="toc-text">4.消息拉取总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E9%95%BF%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90"><span class="toc-number">2.5.3.3.</span> <span class="toc-text">4）消息拉取长轮询机制分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-5-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%B4%9F%E8%BD%BD%E4%B8%8E%E9%87%8D%E6%96%B0%E5%88%86%E5%B8%83%E6%9C%BA%E5%88%B6"><span class="toc-number">2.5.4.</span> <span class="toc-text">2.5.5 消息队列负载与重新分布机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-6-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%BF%87%E7%A8%8B"><span class="toc-number">2.5.5.</span> <span class="toc-text">2.5.6 消息消费过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-7-%E5%AE%9A%E6%97%B6%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6"><span class="toc-number">2.5.6.</span> <span class="toc-text">2.5.7 定时消息机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-8-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">2.5.7.</span> <span class="toc-text">2.5.8 顺序消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-9-%E5%B0%8F%E7%BB%93"><span class="toc-number">2.5.8.</span> <span class="toc-text">2.5.9 小结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/01/blog31/" title="常见的Server的并发模型">常见的Server的并发模型</a><time datetime="2023-08-01T03:52:17.000Z" title="发表于 2023-08-01 11:52:17">2023-08-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/16/blog30/" title="Mysql Explain之type详解">Mysql Explain之type详解</a><time datetime="2023-07-16T11:29:46.000Z" title="发表于 2023-07-16 19:29:46">2023-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/16/blog29/" title="Java常见数据结构源码分析">Java常见数据结构源码分析</a><time datetime="2023-07-16T02:14:57.000Z" title="发表于 2023-07-16 10:14:57">2023-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/13/blog28/" title="线段树">线段树</a><time datetime="2023-07-13T01:13:59.000Z" title="发表于 2023-07-13 09:13:59">2023-07-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/02/blog27/" title="JAVA IO">JAVA IO</a><time datetime="2023-07-02T12:58:44.000Z" title="发表于 2023-07-02 20:58:44">2023-07-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Mercury</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !true) {
  if (true) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>