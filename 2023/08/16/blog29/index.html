<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java常见数据结构源码分析 | Mercury个人博客</title><meta name="author" content="Mercury"><meta name="copyright" content="Mercury"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.数据结构  2. 一维数组2.1 数组的特点 在Java中，数组是用来存放同一种数据类型的集合，注意只能存放同一种数据类型。  &#x2F;&#x2F;只声明了类型和长度 数据类型[]  数组名称 &#x3D; new 数据类型[数组长度];  &#x2F;&#x2F;声明了类型，初始化赋值，大小由元素个数决定 数据类型[] 数组名称 &#x3D; &amp;#123;数组元素1，数组元素2，......&amp;#125;  例如：整型数组   例如：对象数组">
<meta property="og:type" content="article">
<meta property="og:title" content="Java常见数据结构源码分析">
<meta property="og:url" content="http://example.com/2023/08/16/blog29/index.html">
<meta property="og:site_name" content="Mercury个人博客">
<meta property="og:description" content="1.数据结构  2. 一维数组2.1 数组的特点 在Java中，数组是用来存放同一种数据类型的集合，注意只能存放同一种数据类型。  &#x2F;&#x2F;只声明了类型和长度 数据类型[]  数组名称 &#x3D; new 数据类型[数组长度];  &#x2F;&#x2F;声明了类型，初始化赋值，大小由元素个数决定 数据类型[] 数组名称 &#x3D; &amp;#123;数组元素1，数组元素2，......&amp;#125;  例如：整型数组   例如：对象数组">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2023-08-16T02:14:57.000Z">
<meta property="article:modified_time" content="2023-12-20T02:28:25.829Z">
<meta property="article:author" content="Mercury">
<meta property="article:tag" content="算法和数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/08/16/blog29/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java常见数据结构源码分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-20 10:28:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/themes/butterfly/source/css/mouse.css?1"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_top_img.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Mercury个人博客"><span class="site-name">Mercury个人博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java常见数据结构源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-16T02:14:57.000Z" title="发表于 2023-08-16 10:14:57">2023-08-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-20T02:28:25.829Z" title="更新于 2023-12-20 10:28:25">2023-12-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java常见数据结构源码分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h2><img src="../imgs/blog29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="数据结构" style="zoom: 40%;" />

<h2 id="2-一维数组"><a href="#2-一维数组" class="headerlink" title="2. 一维数组"></a>2. 一维数组</h2><h3 id="2-1-数组的特点"><a href="#2-1-数组的特点" class="headerlink" title="2.1 数组的特点"></a>2.1 数组的特点</h3><ul>
<li>在Java中，数组是用来存放同一种数据类型的集合，注意只能存放同一种数据类型。</li>
</ul>
<pre><code class="java">//只声明了类型和长度
数据类型[]  数组名称 = new 数据类型[数组长度];

//声明了类型，初始化赋值，大小由元素个数决定
数据类型[] 数组名称 = &#123;数组元素1，数组元素2，......&#125;
</code></pre>
<p>例如：整型数组</p>
<img src="../imgs/blog29/1563432676234.png" alt="1563432676234" style="zoom: 80%;" />

<p>例如：对象数组</p>
<img src="../imgs/blog29/1563432696340.png" alt="1563432696340" style="zoom:80%;" />

<ul>
<li>物理结构特点：<ul>
<li>申请内存：一次申请一大段连续的空间，一旦申请到了，内存就固定了。</li>
<li>不能动态扩展(初始化给大了，浪费；给小了，不够用)，插入快，删除和查找慢。</li>
<li>存储特点：所有数据存储在这个连续的空间中，数组中的每一个元素都是一个具体的数据（或对象），所有数据都紧密排布，不能有间隔。</li>
</ul>
</li>
<li>具体的，如下图：</li>
</ul>
<img src="../imgs/blog29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84.png" alt="数据结构-一维数组" style="zoom: 50%;" />

<h3 id="2-2-自定义数组"><a href="#2-2-自定义数组" class="headerlink" title="2.2 自定义数组"></a>2.2 自定义数组</h3><pre><code class="java">package com.atguigu01.overview.array;

/**
 * @author 尚硅谷-宋红康
 * @create 14:39
 */
class Array &#123;
    private Object[] elementData;

    private int size;

    public Array(int capacity)&#123;
        elementData = new Object[capacity];
    &#125;

    /**
     * 添加元素
     * @param value
     */
    public void add(Object value)&#123;
        if(size &gt;= elementData.length)&#123;
            throw new RuntimeException(&quot;数组已满，不可添加&quot;);
        &#125;
        elementData[size] = value;
        size++;
    &#125;

    /**
     * 查询元素value在数组中的索引位置
     * @param value
     * @return
     */
    public int find(Object value)&#123;
        for (int i = 0; i &lt; size; i++) &#123;
            if(elementData[i].equals(value))&#123;
                return i;
            &#125;
        &#125;
        return -1;
    &#125;

    /**
     * 从当前数组中移除首次出现的value元素
     * @param value
     * @return
     */
    public boolean delete(Object value)&#123;
        int index = find(value);
        if(index == -1)&#123;
            return false;
        &#125;

        for(int i = index;i &lt; size - 1;i++)&#123;
            elementData[i] = elementData[i + 1];
        &#125;
        elementData[size - 1] = null;
        size--;
        return true;
    &#125;

    /**
     * 将数组中首次出现的oldValue替换为newValue
     * @param oldValue
     * @param newValue
     * @return
     */
    public boolean update(Object oldValue,Object newValue)&#123;
        int index = find(oldValue);
        if(index == -1)&#123;
            return false;
        &#125;
        elementData[index] = newValue;
        return true;

    &#125;

    /**
     * 遍历数组中所有数据
     */
    public void print()&#123;
        System.out.print(&quot;&#123;&quot;);
        for (int i = 0; i &lt; size; i++) &#123;
            if(i == size - 1)&#123;
                System.out.println(elementData[i] + &quot;&#125;&quot;);
                break;
            &#125;
            System.out.print(elementData[i] + &quot;,&quot;);
        &#125;
    &#125;
&#125;

//测试类
public class ArrayTest &#123;
    public static void main(String[] args) &#123;
        Array arr = new Array(10);

        arr.add(123);
        arr.add(&quot;AA&quot;);
        arr.add(345);
        arr.add(345);
        arr.add(&quot;BB&quot;);

        arr.delete(345);

        arr.update(345,444);

        arr.print();
    &#125;
&#125;
</code></pre>
<h2 id="3-链表"><a href="#3-链表" class="headerlink" title="3. 链表"></a>3. 链表</h2><h3 id="3-1-链表的特点"><a href="#3-1-链表的特点" class="headerlink" title="3.1 链表的特点"></a>3.1 链表的特点</h3><ul>
<li><p>逻辑结构：线性结构</p>
</li>
<li><p>物理结构：不要求连续的存储空间</p>
</li>
<li><p>存储特点：链表由一系列结点node（链表中每一个元素称为结点）组成，结点可以在代码执行过程中动态创建。每个结点包括两个部分：一个是存储数据元素的<code>数据域</code>，另一个是存储下一个结点地址的<code>指针域</code>。</p>
</li>
</ul>
<p><img src="/../imgs/blog29/image-20220511113744772-1661445988505.png" alt="image-20220511113744772"></p>
<ul>
<li>常见的链表结构有如下的形式：</li>
</ul>
<p><img src="/../imgs/blog29/1563448858180-1661445988506.png" alt="1563448858180"></p>
<img src="../imgs/blog29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8.png" alt="数据结构-链表" style="zoom:50%;" />

<h3 id="3-2-自定义链表"><a href="#3-2-自定义链表" class="headerlink" title="3.2 自定义链表"></a>3.2 自定义链表</h3><h4 id="3-2-1-自定义单向链表"><a href="#3-2-1-自定义单向链表" class="headerlink" title="3.2.1 自定义单向链表"></a>3.2.1 自定义单向链表</h4><p><img src="/../imgs/blog29/image-20221028195106363.png" alt="image-20221028195106363"></p>
<pre><code class="java">/*
单链表中的节点。
节点是单向链表中基本的单元。
每一个节点Node都有两个属性：
    一个属性：是存储的数据。
    另一个属性：是下一个节点的内存地址。
 */
public class Node &#123;

    // 存储的数据
    Object data;

    // 下一个节点的内存地址
    Node next;

    public Node()&#123;

    &#125;

    public Node(Object data, Node next)&#123;
        this.data = data;
        this.next = next;
    &#125;
&#125;
</code></pre>
<pre><code class="java">/*
链表类(单向链表)
 */
public class Link&lt;E&gt; &#123;

    // 头节点
    Node header;

    private int size = 0;

    public int size()&#123;
        return size;
    &#125;

    // 向链表中添加元素的方法（向末尾添加）
    public void add(E data)&#123;
    //public void add(Object data)&#123;
        // 创建一个新的节点对象
        // 让之前单链表的末尾节点next指向新节点对象。
        // 有可能这个元素是第一个，也可能是第二个，也可能是第三个。
        if(header == null)&#123;
            // 说明还没有节点。
            // new一个新的节点对象，作为头节点对象。
            // 这个时候的头节点既是一个头节点，又是一个末尾节点。
            header = new Node(data, null);
        &#125;else &#123;
            // 说明头不是空！
            // 头节点已经存在了！
            // 找出当前末尾节点，让当前末尾节点的next是新节点。
            Node currentLastNode = findLast(header);
            currentLastNode.next = new Node(data, null);
        &#125;
        size++;
    &#125;

    /**
     * 专门查找末尾节点的方法。
     */
    private Node findLast(Node node) &#123;
        if(node.next == null) &#123;
            // 如果一个节点的next是null
            // 说明这个节点就是末尾节点。
            return node;
        &#125;
        // 程序能够到这里说明：node不是末尾节点。
        return findLast(node.next); // 递归算法！
    &#125;

    /*// 删除链表中某个数据的方法
    public void remove(Object obj)&#123;
        //略
    &#125;

    // 修改链表中某个数据的方法
    public void modify(Object newObj)&#123;
        //略
    &#125;

    // 查找链表中某个元素的方法。
    public int find(Object obj)&#123;
        //略
    &#125;*/
&#125;
</code></pre>
<h4 id="3-2-2-自定义双向链表"><a href="#3-2-2-自定义双向链表" class="headerlink" title="3.2.2 自定义双向链表"></a>3.2.2 自定义双向链表</h4><p><img src="/../imgs/blog29/image-20220514165707977-1661448081075.png" alt="image-20220514165707977"></p>
<pre><code class="java">/*
双向链表中的节点。
 */
public class Node&lt;E&gt; &#123;
    Node prev;
    E data;
    Node next;

    Node(Node prev, E data, Node next) &#123;
        this.prev = prev;
        this.data = data;
        this.next = next;
    &#125;
&#125;
</code></pre>
<pre><code class="java">/**
 * 链表类(双向链表)
 * @author 尚硅谷-宋红康
 * @create 15:05
 */
public class MyLinkedList&lt;E&gt; implements Iterable&lt;E&gt;&#123;
    private Node first;  //链表的首元素
    private Node last;   //链表的尾元素
    private int total;

    public void add(E e)&#123;
        Node newNode = new Node(last, e, null);

        if(first == null)&#123;
            first = newNode;
        &#125;else&#123;
            last.next = newNode;
        &#125;
        last = newNode;
        total++;
    &#125;

    public int size()&#123;
        return total;
    &#125;

    public void delete(Object obj)&#123;
        Node find = findNode(obj);
        if(find != null)&#123;
            if(find.prev != null)&#123;
                find.prev.next = find.next;
            &#125;else&#123;
                first = find.next;
            &#125;
            if(find.next != null)&#123;
                find.next.prev = find.prev;
            &#125;else&#123;
                last = find.prev;
            &#125;

            find.prev = null;
            find.next = null;
            find.data = null;

            total--;
        &#125;
    &#125;

    private Node findNode(Object obj)&#123;
        Node node = first;
        Node find = null;

        if(obj == null)&#123;
            while(node != null)&#123;
                if(node.data == null)&#123;
                    find = node;
                    break;
                &#125;
                node = node.next;
            &#125;
        &#125;else&#123;
            while(node != null)&#123;
                if(obj.equals(node.data))&#123;
                    find = node;
                    break;
                &#125;
                node = node.next;
            &#125;
        &#125;
        return find;
    &#125;

    public boolean contains(Object obj)&#123;
        return findNode(obj) != null;
    &#125;

    public void update(E old, E value)&#123;
        Node find = findNode(old);
        if(find != null)&#123;
            find.data = value;
        &#125;
    &#125;

    @Override
    public Iterator&lt;E&gt; iterator() &#123;
        return new Itr();
    &#125;

    private class Itr implements Iterator&lt;E&gt;&#123;
        private Node&lt;E&gt; node = first;

        @Override
        public boolean hasNext() &#123;
            return node!=null;
        &#125;

        @Override
        public E next() &#123;
            E value = node.data;
            node = node.next;
            return value;
        &#125;
    &#125;
&#125;
</code></pre>
<p>自定义双链表测试：</p>
<pre><code class="java">package com.atguigu.list;

public class MyLinkedListTest &#123;
    public static void main(String[] args) &#123;
        MyLinkedList&lt;String&gt; my = new MyLinkedList&lt;&gt;();
        my.add(&quot;hello&quot;);
        my.add(&quot;world&quot;);
        my.add(null);
        my.add(null);
        my.add(&quot;java&quot;);
        my.add(&quot;java&quot;);
        my.add(&quot;atguigu&quot;);

        System.out.println(&quot;一共有：&quot; + my.size());
        System.out.println(&quot;所有元素：&quot;);
        for (String s : my) &#123;
            System.out.println(s);
        &#125;
        System.out.println(&quot;-------------------------------------&quot;);
        System.out.println(&quot;查找java,null,haha的结果：&quot;);
        System.out.println(my.contains(&quot;java&quot;));
        System.out.println(my.contains(null));
        System.out.println(my.contains(&quot;haha&quot;));

        System.out.println(&quot;-------------------------------------&quot;);
        System.out.println(&quot;替换java,null后：&quot;);
        my.update(&quot;java&quot;,&quot;JAVA&quot;);
        my.update(null,&quot;songhk&quot;);
        System.out.println(&quot;所有元素：&quot;);
        for (String s : my) &#123;
            System.out.println(s);
        &#125;
        System.out.println(&quot;-------------------------------------&quot;);
        System.out.println(&quot;删除hello，JAVA,null，atguigu后：&quot;);
        my.delete(&quot;hello&quot;);
        my.delete(&quot;JAVA&quot;);
        my.delete(null);
        my.delete(&quot;atguigu&quot;);
        System.out.println(&quot;所有元素：&quot;);
        for (String s : my) &#123;
            System.out.println(s);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="4-栈"><a href="#4-栈" class="headerlink" title="4. 栈"></a>4. 栈</h2><h3 id="4-1-栈的特点"><a href="#4-1-栈的特点" class="headerlink" title="4.1 栈的特点"></a>4.1 栈的特点</h3><ul>
<li><p>栈（Stack）又称为堆栈或堆叠，是限制仅在表的一端进行插入和删除运算的线性表。</p>
</li>
<li><p>栈按照<code>先进后出(FILO,first in last out)</code>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶。每次删除（退栈）的总是删除当前栈中最后插入（进栈）的元素，而最先插入的是被放在栈的底部，要到最后才能删除。</p>
<p><img src="/../imgs/blog29/image-20221028192349993.png" alt="image-20221028192349993"></p>
</li>
<li><p>核心类库中的栈结构有Stack和LinkedList。</p>
<ul>
<li>Stack就是顺序栈，它是Vector的子类。</li>
<li>LinkedList是链式栈。</li>
</ul>
</li>
<li><p>体现栈结构的操作方法：</p>
<ul>
<li>peek()方法：查看栈顶元素，不弹出</li>
<li>pop()方法：弹出栈</li>
<li>push(E e)方法：压入栈</li>
</ul>
</li>
<li><p>时间复杂度:</p>
<ul>
<li>索引: <code>O(n)</code></li>
<li>搜索: <code>O(n)</code></li>
<li>插入: <code>O(1)</code></li>
<li>移除: <code>O(1)</code></li>
</ul>
</li>
<li><p>图示：</p>
</li>
</ul>
<img src="../imgs/blog29/image-20220826010258638.png" alt="image-20220826010258638" style="zoom:80%;" />

<img src="../imgs/blog29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88.png" alt="数据结构-栈" style="zoom:50%;" />

<h3 id="4-2-Stack使用举例"><a href="#4-2-Stack使用举例" class="headerlink" title="4.2 Stack使用举例"></a>4.2 Stack使用举例</h3><pre><code class="java">/**
 * @author 尚硅谷-宋红康
 * @create 15:44
 */
public class TestStack &#123;
    /*
    * 测试Stack
    * */
    @Test
    public void test1()&#123;
        Stack&lt;Integer&gt; list = new Stack&lt;&gt;();
        list.push(1);
        list.push(2);
        list.push(3);

        System.out.println(&quot;list = &quot; + list);

        System.out.println(&quot;list.peek()=&quot; + list.peek());
        System.out.println(&quot;list.peek()=&quot; + list.peek());
        System.out.println(&quot;list.peek()=&quot; + list.peek());

/*
        System.out.println(&quot;list.pop() =&quot; + list.pop());
        System.out.println(&quot;list.pop() =&quot; + list.pop());
        System.out.println(&quot;list.pop() =&quot; + list.pop());
        System.out.println(&quot;list.pop() =&quot; + list.pop());//java.util.NoSuchElementException
*/

        while(!list.empty())&#123;
            System.out.println(&quot;list.pop() =&quot; + list.pop());
        &#125;
    &#125;

    /*
    * 测试LinkedList
    * */
    @Test
    public void test2()&#123;
        LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;();
        list.push(1);
        list.push(2);
        list.push(3);

        System.out.println(&quot;list = &quot; + list);

        System.out.println(&quot;list.peek()=&quot; + list.peek());
        System.out.println(&quot;list.peek()=&quot; + list.peek());
        System.out.println(&quot;list.peek()=&quot; + list.peek());

/*
        System.out.println(&quot;list.pop() =&quot; + list.pop());
        System.out.println(&quot;list.pop() =&quot; + list.pop());
        System.out.println(&quot;list.pop() =&quot; + list.pop());
        System.out.println(&quot;list.pop() =&quot; + list.pop());//java.util.NoSuchElementException
*/
        while(!list.isEmpty())&#123;
            System.out.println(&quot;list.pop() =&quot; + list.pop());
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="4-3-自定义栈"><a href="#4-3-自定义栈" class="headerlink" title="4.3 自定义栈"></a>4.3 自定义栈</h3><pre><code class="java">public class MyStack &#123;
    // 向栈当中存储元素，我们这里使用一维数组模拟。存到栈中，就表示存储到数组中。
    // 为什么选择Object类型数组？因为这个栈可以存储java中的任何引用类型的数据
    private Object[] elements;

    // 栈帧，永远指向栈顶部元素
    // 那么这个默认初始值应该是多少。注意：最初的栈是空的，一个元素都没有。
    //private int index = 0; // 如果index采用0，表示栈帧指向了顶部元素的上方。
    //private int index = -1; // 如果index采用-1，表示栈帧指向了顶部元素。
    private int index;

    /**
     * 无参数构造方法。默认初始化栈容量10.
     */
    public MyStack() &#123;
        // 一维数组动态初始化
        // 默认初始化容量是10.
        this.elements = new Object[10];
        // 给index初始化
        this.index = -1;
    &#125;

    /**
     * 压栈的方法
     * @param obj 被压入的元素
     */
    public void push(Object obj) throws Exception &#123;
        if(index &gt;= elements.length - 1)&#123;
            //方式1：
            //System.out.println(&quot;压栈失败，栈已满！&quot;);
            //return;
            //方式2：
            throw new Exception(&quot;压栈失败，栈已满！&quot;);
        &#125;
        // 程序能够走到这里，说明栈没满
        // 向栈中加1个元素，栈帧向上移动一个位置。
        index++;
        elements[index] = obj;
        System.out.println(&quot;压栈&quot; + obj + &quot;元素成功，栈帧指向&quot; + index);
    &#125;

    /**
     * 弹栈的方法，从数组中往外取元素。每取出一个元素，栈帧向下移动一位。
     * @return
     */
    public Object pop() throws Exception &#123;
        if (index &lt; 0) &#123;
            //方式1：
            //System.out.println(&quot;弹栈失败，栈已空！&quot;);
            //return;
            //方式2：
            throw new Exception(&quot;弹栈失败，栈已空！&quot;);
        &#125;
        // 程序能够执行到此处说明栈没有空。
        Object obj = elements[index];
        System.out.print(&quot;弹栈&quot; + obj + &quot;元素成功，&quot;);
        elements[index] = null;
        // 栈帧向下移动一位。
        index--;
        return obj;
    &#125;

    // set和get也许用不上，但是你必须写上，这是规矩。你使用IDEA生成就行了。
    // 封装：第一步：属性私有化，第二步：对外提供set和get方法。
    public Object[] getElements() &#123;
        return elements;
    &#125;

    public void setElements(Object[] elements) &#123;
        this.elements = elements;
    &#125;

    public int getIndex() &#123;
        return index;
    &#125;

    public void setIndex(int index) &#123;
        this.index = index;
    &#125;
&#125;
</code></pre>
<h2 id="5-队列"><a href="#5-队列" class="headerlink" title="5. 队列"></a>5. 队列</h2><ul>
<li><p>队列（Queue）是只允许在一端进行插入，而在另一端进行删除的运算受限的线性表。</p>
</li>
<li><p>队列是逻辑结构，其物理结构可以是数组，也可以是链表。</p>
</li>
<li><p>队列的修改原则：队列的修改是依<code>先进先出（FIFO）的原则</code>进行的。新来的成员总是加入队尾（即不允许”加塞”），每次离开的成员总是队列头上的（不允许中途离队），即当前”最老的”成员离队。</p>
</li>
<li><p>图示：</p>
</li>
</ul>
<p><img src="/../imgs/blog29/image-20220826010241172.png" alt="image-20220826010241172"></p>
<img src="../imgs/blog29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97.png" alt="数据结构-队列" style="zoom:50%;" />

<h2 id="6-树与二叉树"><a href="#6-树与二叉树" class="headerlink" title="6. 树与二叉树"></a>6. 树与二叉树</h2><h3 id="6-1-树的理解"><a href="#6-1-树的理解" class="headerlink" title="6.1 树的理解"></a>6.1 树的理解</h3><img src="../imgs/blog29/image-20220521111904272.png" alt="image-20220521111904272" style="zoom:67%;" />

<p><strong>专有名词解释：</strong></p>
<p><code>结点</code>：树中的数据元素都称之为结点</p>
<p><code>根节点</code>：最上面的结点称之为根，一颗树只有一个根且由根发展而来，从另外一个角度来说，每个结点都可以认为是其子树的根</p>
<p><code>父节点</code>：结点的上层结点，如图中，结点K的父节点是E、结点L的父节点是G</p>
<p><code>子节点</code>：节点的下层结点，如图中，节点E的子节点是K节点、节点G的子节点是L节点</p>
<p><code>兄弟节点</code>：具有相同父节点的结点称为兄弟节点，图中F、G、H互为兄弟节点</p>
<p><code>结点的度数</code>：每个结点所拥有的子树的个数称之为结点的度，如结点B的度为3</p>
<p><code>树叶</code>：度数为0的结点，也叫作终端结点，图中D、K、F、L、H、I、J都是树叶</p>
<p><code>非终端节点（或分支节点）</code>：树叶以外的节点，或度数不为0的节点。图中根、A、B、C、E、G都是</p>
<p><code>树的深度（或高度）</code>：树中结点的最大层次数，图中树的深度为4</p>
<p><code>结点的层数</code>：从根节点到树中某结点所经路径上的分支树称为该结点的层数，根节点的层数规定为1，其余结点的层数等于其父亲结点的层数+1</p>
<p><code>同代</code>：在同一棵树中具有相同层数的节点</p>
<h3 id="6-2-二叉树的基本概念"><a href="#6-2-二叉树的基本概念" class="headerlink" title="6.2 二叉树的基本概念"></a>6.2 二叉树的基本概念</h3><p>二叉树（Binary tree）是树形结构的一个重要类型。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。许多实际问题抽象出来的数据结构往往是二叉树形式，二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。</p>
<p><img src="/../imgs/blog29/1563449427345-1661447692846.png" alt="1563449427345"></p>
<h3 id="6-3-二叉树的遍历"><a href="#6-3-二叉树的遍历" class="headerlink" title="6.3 二叉树的遍历"></a>6.3 二叉树的遍历</h3><ul>
<li><p><strong>前序遍历：中左右（根左右）</strong></p>
<p>即先访问根结点，再前序遍历左子树，最后再前序遍历右子 树。前序遍历运算访问二叉树各结点是以根、左、右的顺序进行访问的。</p>
</li>
<li><p><strong>中序遍历：左中右（左根右）</strong></p>
<p>即先中前序遍历左子树，然后再访问根结点，最后再中序遍 历右子树。中序遍历运算访问二叉树各结点是以左、根、右的顺序进行访问的。</p>
</li>
<li><p><strong>后序遍历：左右中（左右根）</strong></p>
<p>即先后序遍历左子树，然后再后序遍历右子树，最后访问根 结点。后序遍历运算访问二叉树各结点是以左、右、根的顺序进行访问的。</p>
</li>
</ul>
<img src="../imgs/blog29/1574575739236-1661447692846.png" alt="1574575739236" style="zoom:80%;" />

<p>前序遍历：ABDHIECFG</p>
<p>中序遍历：HDIBEAFCG</p>
<p>后序遍历：HIDEBFGCA</p>
<h3 id="6-4-经典二叉树"><a href="#6-4-经典二叉树" class="headerlink" title="6.4 经典二叉树"></a>6.4 经典二叉树</h3><img src="../imgs/blog29/image-20220521153016348.png" alt="image-20220521153016348" style="zoom: 67%;" />

<p>1、<code>满二叉树</code>： 除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。 第n层的结点数是2的n-1次方，总的结点个数是2的n次方-1</p>
<p><img src="/../imgs/blog29/1574575163883-1661447692846.png" alt="1574575163883"></p>
<p>2、<code>完全二叉树</code>： 叶结点只能出现在最底层的两层，且最底层叶结点均处于次底层叶结点的左侧。</p>
<p><img src="/../imgs/blog29/1574575180247-1661447692846.png" alt="1574575180247"></p>
<p>3、<code>二叉排序/查找/搜索树</code>：即为BST  (binary search&#x2F;sort tree)。满足如下性质：<br>（1）若它的左子树不为空，则左子树上所有结点的值均小于它的根节点的值；<br>（2）若它的右子树上所有结点的值均大于它的根节点的值；<br>（3）它的左、右子树也分别为二叉排序&#x2F;查找&#x2F;搜索树。</p>
<img src="../imgs/blog29/image-20220521145208018.png" alt="image-20220521145208018" style="zoom: 67%;" />

<blockquote>
<p>对二叉查找树进行中序遍历，得到有序集合。便于检索。</p>
</blockquote>
<p>4、<code>平衡二叉树</code>：（Self-balancing binary search tree，AVL）首先是二叉排序树，此外具有以下性质：<br>（1）它是一棵空树或它的左右两个子树的高度差的绝对值不超过1<br>（2）并且左右两个子树也都是一棵平衡二叉树<br>（3）不要求非叶节点都有两个子结点 </p>
<blockquote>
<p>平衡二叉树的目的是为了减少二叉查找树的层次，提高查找速度。平衡二叉树的常用实现有红黑树、AVL、替罪羊树、Treap、伸展树等。</p>
</blockquote>
<img src="../imgs/blog29/image-20220521150151219.png" alt="image-20220521150151219" style="zoom: 50%;" />



<p>6、<code>红黑树</code>：即Red-Black Tree。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。 </p>
<p>红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，它是在 1972 年由 Rudolf Bayer 发明的。红黑树是复杂的，但它的操作有着<code>良好的最坏情况运行时间</code>，并且在<code>实践中是高效的</code>：它可以在 O(log n)时间内做查找，插入和删除， 这里的 n 是树中元素的数目。</p>
<p>红黑树的特性：</p>
<ul>
<li><p>每个节点是红色或者黑色</p>
</li>
<li><p>根节点是黑色</p>
</li>
<li><p>每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点）</p>
</li>
<li><p>每个红色节点的两个子节点都是黑色的。(从每个叶子到根的所有路径上不能有两个连续的红色节点) </p>
</li>
<li><p>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点（确保没有一条路径会比其他路径长出2倍）</p>
</li>
</ul>
<p><img src="/../imgs/blog29/%E7%BA%A2%E9%BB%91%E6%A0%91-1661447692846.jpeg"></p>
<p>当我们插入或删除节点时，可能会破坏已有的红黑树，使得它不满足以上5个要求，那么此时就需要进行处理，使得它继续满足以上的5个要求：</p>
<p>1、<code>recolor</code> ：将某个节点变红或变黑</p>
<p>2、<code>rotation</code> ：将红黑树某些结点分支进行旋转（左旋或右旋）</p>
<p> <img src="/../imgs/blog29/image-20221208212053079.png" alt="image-20221208212053079"></p>
<blockquote>
<p>红黑树可以通过红色节点和黑色节点尽可能的保证二叉树的平衡。主要是用它来存储有序的数据，它的时间复杂度是O(logN)，效率非常之高。</p>
</blockquote>
<h3 id="6-5-二叉树及其结点的表示"><a href="#6-5-二叉树及其结点的表示" class="headerlink" title="6.5 二叉树及其结点的表示"></a>6.5 二叉树及其结点的表示</h3><p>普通二叉树：</p>
<pre><code class="java">public class BinaryTree&lt;E&gt;&#123;
    private TreeNode root; //二叉树的根结点
    private int total;//结点总个数
    
    private class TreeNode&#123;
        //至少有以下几个部分
        TreeNode parent;
        TreeNode left;
        E data;
        TreeNode right;
        
        public TreeNode(TreeNode parent, TreeNode left, E data, TreeNode right) &#123;
            this.parent = parent;
            this.left = left;
            this.data = data;
            this.right = right;
        &#125;
    &#125;
&#125;
</code></pre>
<p>TreeMap红黑树：</p>
<pre><code class="java">public class TreeMap&lt;K,V&gt; &#123;
    private transient Entry&lt;K,V&gt; root;
    private transient int size = 0;
    
    static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;
        K key;
        V value;
        Entry&lt;K,V&gt; left;
        Entry&lt;K,V&gt; right;
        Entry&lt;K,V&gt; parent;
        boolean color = BLACK;

        /**
         * Make a new cell with given key, value, and parent, and with
         * &#123;@code null&#125; child links, and BLACK color.
         */
        Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;
            this.key = key;
            this.value = value;
            this.parent = parent;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="7-List接口分析"><a href="#7-List接口分析" class="headerlink" title="7. List接口分析"></a>7. List接口分析</h2><h3 id="7-1-List接口特点"><a href="#7-1-List接口特点" class="headerlink" title="7.1 List接口特点"></a>7.1 List接口特点</h3><ul>
<li>List集合所有的元素是以一种<code>线性方式</code>进行存储的，例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li>
<li>它是一个元素<code>存取有序</code>的集合。即元素的存入顺序和取出顺序有保证。</li>
<li>它是一个<code>带有索引</code>的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li>
<li>集合中可以有<code>重复</code>的元素，通过元素的equals方法，来比较是否为重复的元素。</li>
</ul>
<p><img src="/../imgs/blog29/1563549818689-1661447917313.png" alt="1563549818689"></p>
<blockquote>
<p>注意：</p>
<p>List集合关心元素是否有序，而不关心是否重复，请大家记住这个原则。例如“张三”可以领取两个号。</p>
</blockquote>
<ul>
<li>List接口的主要实现类<ul>
<li>ArrayList：动态数组</li>
<li>Vector：动态数组</li>
<li>LinkedList：双向链表</li>
<li>Stack：栈</li>
</ul>
</li>
</ul>
<h3 id="7-2-动态数组ArrayList与Vector"><a href="#7-2-动态数组ArrayList与Vector" class="headerlink" title="7.2 动态数组ArrayList与Vector"></a>7.2 动态数组ArrayList与Vector</h3><p>Java的List接口的实现类中有两个动态数组的实现：ArrayList 和 Vector。</p>
<h4 id="7-2-1-ArrayList与Vector的区别"><a href="#7-2-1-ArrayList与Vector的区别" class="headerlink" title="7.2.1 ArrayList与Vector的区别"></a>7.2.1 ArrayList与Vector的区别</h4><p>它们的底层物理结构都是数组，我们称为动态数组。</p>
<ul>
<li>ArrayList是新版的动态数组，线程不安全，效率高，Vector是旧版的动态数组，线程安全，效率低。</li>
<li>动态数组的扩容机制不同，ArrayList默认扩容为原来的1.5倍，Vector默认扩容增加为原来的2倍。</li>
<li>数组的初始化容量，如果在构建ArrayList与Vector的集合对象时，没有显式指定初始化容量，那么Vector的内部数组的初始容量默认为10，而ArrayList在JDK 6.0 及之前的版本也是10，JDK8.0 之后的版本ArrayList初始化为长度为0的空数组，之后在添加第一个元素时，再创建长度为10的数组。原因：<ul>
<li>用的时候，再创建数组，避免浪费。因为很多方法的返回值是ArrayList类型，需要返回一个ArrayList的对象，例如：后期从数据库查询对象的方法，返回值很多就是ArrayList。有可能你要查询的数据不存在，要么返回null，要么返回一个没有元素的ArrayList对象。</li>
</ul>
</li>
</ul>
<h4 id="7-2-2-ArrayList部分源码分析"><a href="#7-2-2-ArrayList部分源码分析" class="headerlink" title="7.2.2 ArrayList部分源码分析"></a>7.2.2 ArrayList部分源码分析</h4><p><strong>JDK1.7.0_07中：</strong></p>
<pre><code class="java">//属性
private transient Object[] elementData; //存储底层数组元素
private int size; //记录数组中存储的元素的个数

//构造器
public ArrayList() &#123;
    this(10); //指定初始容量为10
&#125;

public ArrayList(int initialCapacity) &#123;
    super();
    //检查初始容量的合法性
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity);
    //数组初始化为长度为initialCapacity的数组
    this.elementData = new Object[initialCapacity]; 
&#125;

//方法：add()相关方法
public boolean add(E e) &#123;
    ensureCapacityInternal(size + 1);  //查看当前数组是否够多存一个元素
    elementData[size++] = e; //将元素e添加到elementData数组中
    return true;
&#125;

private void ensureCapacityInternal(int minCapacity) &#123;
    modCount++;
    // 如果if条件满足，则进行数组的扩容
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
&#125;

private void grow(int minCapacity) &#123;
    // overflow-conscious code
    int oldCapacity = elementData.length; //当前数组容量
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //新数组容量是旧数组容量的1.5倍
    if (newCapacity - minCapacity &lt; 0)  //判断旧数组的1.5倍是否够
        newCapacity = minCapacity;
    //判断旧数组的1.5倍是否超过最大数组限制
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    //复制一个新数组
    elementData = Arrays.copyOf(elementData, newCapacity);
&#125;

//方法：remove()相关方法
public E remove(int index) &#123;
    rangeCheck(index); //判断index是否在有效的范围内

    modCount++; //修改次数加1
    //取出[index]位置的元素，[index]位置的元素就是要被删除的元素，用于最后返回被删除的元素
    E oldValue = elementData(index); 

    int numMoved = size - index - 1; //确定要移动的次数
    //如果需要移动元素，就用System.arraycopy移动元素
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index, numMoved);
    //将elementData[size-1]位置置空，让GC回收空间，元素个数减少
    elementData[--size] = null; 

    return oldValue;
&#125;

private void rangeCheck(int index) &#123;
    if (index &gt;= size) //index不合法的情况
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
&#125;

E elementData(int index) &#123; //返回指定位置的元素
    return (E) elementData[index];
&#125;

//方法：set()方法相关
public E set(int index, E element) &#123;
    rangeCheck(index); //检验index是否合法
    
    //取出[index]位置的元素，[index]位置的元素就是要被替换的元素，用于最后返回被替换的元素
    E oldValue = elementData(index);
    //用element替换[index]位置的元素
    elementData[index] = element;
    return oldValue;
&#125;

//方法：get()相关方法
public E get(int index) &#123;
    rangeCheck(index); //检验index是否合法

    return elementData(index); //返回[index]位置的元素
&#125;

//方法：indexOf()
public int indexOf(Object o) &#123;
    //分为o是否为空两种情况
    if (o == null) &#123;
        //从前往后找
        for (int i = 0; i &lt; size; i++)
            if (elementData[i]==null)
                return i;
    &#125; else &#123;
        for (int i = 0; i &lt; size; i++)
            if (o.equals(elementData[i]))
                return i;
    &#125;
    return -1;
&#125;

//方法：lastIndexOf()
public int lastIndexOf(Object o) &#123;
    //分为o是否为空两种情况
    if (o == null) &#123;
        //从后往前找
        for (int i = size-1; i &gt;= 0; i--)
            if (elementData[i]==null)
                return i;
    &#125; else &#123;
        for (int i = size-1; i &gt;= 0; i--)
            if (o.equals(elementData[i]))
                return i;
    &#125;
    return -1;
&#125;
</code></pre>
<p><strong>jdk1.8.0_271中：</strong></p>
<pre><code class="java">//属性
transient Object[] elementData;
private int size;
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;

//构造器
public ArrayList() &#123;
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  //初始化为空数组
&#125;

//方法:add()相关方法
public boolean add(E e) &#123;
    //查看当前数组是否够多存一个元素
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    //存入新元素到[size]位置，然后size自增1
    elementData[size++] = e;
    return true;
&#125;

private void ensureCapacityInternal(int minCapacity) &#123;
    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
&#125;

private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;
    //如果当前数组还是空数组
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;
        //那么minCapacity取DEFAULT_CAPACITY与minCapacity的最大值
        return Math.max(DEFAULT_CAPACITY, minCapacity);
    &#125;
    return minCapacity;
&#125;

//查看是否需要扩容
private void ensureExplicitCapacity(int minCapacity) &#123;
    modCount++;  //修改次数加1

    //如果需要的最小容量比当前数组的长度大，即当前数组不够存，就扩容
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
&#125;

private void grow(int minCapacity) &#123;
    // overflow-conscious code
    int oldCapacity = elementData.length; //当前数组容量
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //新数组容量是旧数组容量的1.5倍
    //看旧数组的1.5倍是否够
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    //看旧数组的1.5倍是否超过最大数组限制
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    //复制一个新数组
    elementData = Arrays.copyOf(elementData, newCapacity);
&#125;
</code></pre>
<h4 id="7-2-3-ArrayList相关方法图示"><a href="#7-2-3-ArrayList相关方法图示" class="headerlink" title="7.2.3 ArrayList相关方法图示"></a>7.2.3 ArrayList相关方法图示</h4><ul>
<li><strong>ArrayList采用数组作为底层实现</strong></li>
</ul>
<img src="../imgs/blog29/image-20221029112037297.png" alt="image-20221029112037297" style="zoom:80%;" />

<ul>
<li><strong>ArrayList自动扩容过程</strong></li>
</ul>
<img src="../imgs/blog29/image-20221029112107691.png" alt="image-20221029112107691" style="zoom:80%;" />

<ul>
<li><strong>ArrayList的add(E e)方法</strong></li>
</ul>
<img src="../imgs/blog29/image-20221029112129161.png" alt="image-20221029112129161" style="zoom:80%;" />

<ul>
<li><strong>ArrayList的add(int index,E e)方法</strong></li>
</ul>
<img src="../imgs/blog29/image-20221029112157007.png" alt="image-20221029112157007" style="zoom:80%;" />

<h4 id="7-2-4-Vector部分源码分析"><a href="#7-2-4-Vector部分源码分析" class="headerlink" title="7.2.4 Vector部分源码分析"></a>7.2.4 Vector部分源码分析</h4><p><strong>jdk1.8.0_271中：</strong></p>
<pre><code class="java">//属性
protected Object[] elementData;
protected int elementCount;

//构造器
public Vector() &#123;
    this(10); //指定初始容量initialCapacity为10
&#125;

public Vector(int initialCapacity) &#123;
    this(initialCapacity, 0); //指定capacityIncrement增量为0
&#125;

public Vector(int initialCapacity, int capacityIncrement) &#123;
    super();
    //判断了形参初始容量initialCapacity的合法性
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity);
    //创建了一个Object[]类型的数组
    this.elementData = new Object[initialCapacity];
    //增量，默认是0，如果是0，后面就按照2倍增加，如果不是0，后面就按照你指定的增量进行增量
    this.capacityIncrement = capacityIncrement;
&#125;

//方法：add()相关方法
//synchronized意味着线程安全的   
public synchronized boolean add(E e) &#123;
    modCount++;
    //看是否需要扩容
    ensureCapacityHelper(elementCount + 1);
    //把新的元素存入[elementCount]，存入后，elementCount元素的个数增1
    elementData[elementCount++] = e;
    return true;
&#125;

private void ensureCapacityHelper(int minCapacity) &#123;
     //看是否超过了当前数组的容量
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity); //扩容
&#125;

private void grow(int minCapacity) &#123;
    // overflow-conscious code
    int oldCapacity = elementData.length; //获取目前数组的长度
    //如果capacityIncrement增量是0，新容量 = oldCapacity的2倍
    //如果capacityIncrement增量是不是0，新容量 = oldCapacity + capacityIncrement增量;
    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?
                                     capacityIncrement : oldCapacity);
    //如果按照上面计算的新容量还不够，就按照你指定的需要的最小容量来扩容minCapacity
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    //如果新容量超过了最大数组限制，那么单独处理
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    //把旧数组中的数据复制到新数组中，新数组的长度为newCapacity
    elementData = Arrays.copyOf(elementData, newCapacity);
&#125;

//方法：remove()相关方法
public boolean remove(Object o) &#123;
    return removeElement(o);
&#125;
public synchronized boolean removeElement(Object obj) &#123;
    modCount++;
    //查找obj在当前Vector中的下标
    int i = indexOf(obj);
    //如果i&gt;=0，说明存在，删除[i]位置的元素
    if (i &gt;= 0) &#123;
        removeElementAt(i);
        return true;
    &#125;
    return false;
&#125;

//方法：indexOf()
public int indexOf(Object o) &#123;
    return indexOf(o, 0);
&#125;
public synchronized int indexOf(Object o, int index) &#123;
    if (o == null) &#123;//要查找的元素是null值
        for (int i = index ; i &lt; elementCount ; i++)
            if (elementData[i]==null)//如果是null值，用==null判断
                return i;
    &#125; else &#123;//要查找的元素是非null值
        for (int i = index ; i &lt; elementCount ; i++)
            if (o.equals(elementData[i]))//如果是非null值，用equals判断
                return i;
    &#125;
    return -1;
&#125;

//方法：removeElementAt()
public synchronized void removeElementAt(int index) &#123;
    modCount++;
    //判断下标的合法性
    if (index &gt;= elementCount) &#123;
        throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; +
                                                 elementCount);
    &#125;
    else if (index &lt; 0) &#123;
        throw new ArrayIndexOutOfBoundsException(index);
    &#125;

    //j是要移动的元素的个数
    int j = elementCount - index - 1;
    //如果需要移动元素，就调用System.arraycopy进行移动
    if (j &gt; 0) &#123;
        //把index+1位置以及后面的元素往前移动
        //index+1的位置的元素移动到index位置，依次类推
        //一共移动j个
        System.arraycopy(elementData, index + 1, elementData, index, j);
    &#125;
    //元素的总个数减少
    elementCount--;
    //将elementData[elementCount]这个位置置空，用来添加新元素，位置的元素等着被GC回收
    elementData[elementCount] = null; /* to let gc do its work */
&#125;
</code></pre>
<h3 id="7-3-链表LinkedList"><a href="#7-3-链表LinkedList" class="headerlink" title="7.3 链表LinkedList"></a>7.3 链表LinkedList</h3><p>Java中有双链表的实现：LinkedList，它是List接口的实现类。</p>
<p>LinkedList是一个<code>双向链表</code>，如图所示：</p>
<p><img src="/../imgs/blog29/image-20220514165707977-1661448081075.png" alt="image-20220514165707977"></p>
<h4 id="7-3-1-链表与动态数组的区别"><a href="#7-3-1-链表与动态数组的区别" class="headerlink" title="7.3.1 链表与动态数组的区别"></a>7.3.1 链表与动态数组的区别</h4><p>动态数组底层的物理结构是数组，因此根据索引访问的效率非常高。但是非末尾位置的插入和删除效率不高，因为涉及到移动元素。另外添加操作时涉及到扩容问题，就会增加时空消耗。</p>
<p>链表底层的物理结构是链表，因此根据索引访问的效率不高，即查找元素慢。但是插入和删除不需要移动元素，只需要修改前后元素的指向关系即可，所以插入、删除元素快。而且链表的添加不会涉及到扩容问题。</p>
<h4 id="7-3-2-LinkedList源码分析"><a href="#7-3-2-LinkedList源码分析" class="headerlink" title="7.3.2 LinkedList源码分析"></a>7.3.2 LinkedList源码分析</h4><p><strong>jdk1.8.0_271中：</strong></p>
<pre><code class="java">//属性
transient Node&lt;E&gt; first; //记录第一个结点的位置
transient Node&lt;E&gt; last; //记录当前链表的尾元素
transient int size = 0; //记录最后一个结点的位置

//构造器
public LinkedList() &#123;
&#125;

//方法：add()相关方法
public boolean add(E e) &#123;
    linkLast(e); //默认把新元素链接到链表尾部
    return true;
&#125;

void linkLast(E e) &#123;
    final Node&lt;E&gt; l = last; //用 l 记录原来的最后一个结点
    //创建新结点
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
    //现在的新结点是最后一个结点了
    last = newNode;
    //如果l==null，说明原来的链表是空的
    if (l == null)
        //那么新结点同时也是第一个结点
        first = newNode;
    else
        //否则把新结点链接到原来的最后一个结点的next中
        l.next = newNode;
    //元素个数增加
    size++;
    //修改次数增加
    modCount++;
&#125;

//其中，Node类定义如下
private static class Node&lt;E&gt; &#123;
    E item; //元素数据
    Node&lt;E&gt; next; //下一个结点
    Node&lt;E&gt; prev; //前一个结点

    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;
        this.item = element;
        this.next = next;
        this.prev = prev;
    &#125;
&#125;
//方法：获取get()相关方法
public E get(int index) &#123;
    checkElementIndex(index);
    return node(index).item;
&#125; 

//方法：插入add()相关方法
public void add(int index, E element) &#123;
    checkPositionIndex(index);//检查index范围

    if (index == size)//如果index==size，连接到当前链表的尾部
        linkLast(element);
    else
        linkBefore(element, node(index));
&#125;

Node&lt;E&gt; node(int index) &#123;
    // assert isElementIndex(index);
    /*
    index &lt; (size &gt;&gt; 1)采用二分思想，先将index与长度size的一半比较，如果index&lt;size/2，就只从位置0
    往后遍历到位置index处，而如果index&gt;size/2，就只从位置size往前遍历到位置index处。这样可以减少一部
    分不必要的遍历。
    */
    //如果index&lt;size/2，就从前往后找目标结点
    if (index &lt; (size &gt;&gt; 1)) &#123;
        Node&lt;E&gt; x = first;
        for (int i = 0; i &lt; index; i++)
            x = x.next;
        return x;
    &#125; else &#123;//否则从后往前找目标结点
        Node&lt;E&gt; x = last;
        for (int i = size - 1; i &gt; index; i--)
            x = x.prev;
        return x;
    &#125;
&#125;

//把新结点插入到[index]位置的结点succ前面
void linkBefore(E e, Node&lt;E&gt; succ) &#123;//succ是[index]位置对应的结点
    // assert succ != null;
    final Node&lt;E&gt; pred = succ.prev; //[index]位置的前一个结点

    //新结点的prev是原来[index]位置的前一个结点
    //新结点的next是原来[index]位置的结点
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);

    //[index]位置对应的结点的prev指向新结点
    succ.prev = newNode;

    //如果原来[index]位置对应的结点是第一个结点，那么现在新结点是第一个结点
    if (pred == null)
        first = newNode;
    else
        pred.next = newNode;//原来[index]位置的前一个结点的next指向新结点
    size++;
    modCount++;
&#125;

//方法：remove()相关方法
public boolean remove(Object o) &#123;
    //分o是否为空两种情况
    if (o == null) &#123;
        //找到o对应的结点x
        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;
            if (x.item == null) &#123;
                unlink(x);//删除x结点
                return true;
            &#125;
        &#125;
    &#125; else &#123;
        //找到o对应的结点x
        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;
            if (o.equals(x.item)) &#123;
                unlink(x);//删除x结点
                return true;
            &#125;
        &#125;
    &#125;
    return false;
&#125;
E unlink(Node&lt;E&gt; x) &#123;//x是要被删除的结点
    // assert x != null;
    final E element = x.item;//被删除结点的数据
    final Node&lt;E&gt; next = x.next;//被删除结点的下一个结点
    final Node&lt;E&gt; prev = x.prev;//被删除结点的上一个结点

    //如果被删除结点的前面没有结点，说明被删除结点是第一个结点
    if (prev == null) &#123;
        //那么被删除结点的下一个结点变为第一个结点
        first = next;
    &#125; else &#123;//被删除结点不是第一个结点
        //被删除结点的上一个结点的next指向被删除结点的下一个结点
        prev.next = next;
        //断开被删除结点与上一个结点的链接
        x.prev = null;//使得GC回收
    &#125;

    //如果被删除结点的后面没有结点，说明被删除结点是最后一个结点
    if (next == null) &#123;
        //那么被删除结点的上一个结点变为最后一个结点
        last = prev;
    &#125; else &#123;//被删除结点不是最后一个结点
        //被删除结点的下一个结点的prev执行被删除结点的上一个结点
        next.prev = prev;
        //断开被删除结点与下一个结点的连接
        x.next = null;//使得GC回收
    &#125;
    //把被删除结点的数据也置空，使得GC回收
    x.item = null;
    //元素个数减少
    size--;
    //修改次数增加
    modCount++;
    //返回被删除结点的数据
    return element;
&#125;

public E remove(int index) &#123; //index是要删除元素的索引位置
    checkElementIndex(index);
    return unlink(node(index));
&#125;
</code></pre>
<h4 id="7-3-3-LinkedList相关方法图示"><a href="#7-3-3-LinkedList相关方法图示" class="headerlink" title="7.3.3 LinkedList相关方法图示"></a>7.3.3 LinkedList相关方法图示</h4><ul>
<li><strong>只有1个元素的LinkedList</strong></li>
</ul>
<img src="../imgs/blog29/image-20221029134437888.png" alt="image-20221029134437888" style="zoom:80%;" />

<ul>
<li><strong>包含4个元素的LinkedList</strong></li>
</ul>
<img src="../imgs/blog29/image-20221029134534198.png" alt="image-20221029134534198" style="zoom:80%;" />

<ul>
<li><strong>add(E e)方法</strong></li>
</ul>
<img src="../imgs/blog29/image-20221029135013377.png" alt="image-20221029135013377" style="zoom:80%;" />

<ul>
<li><strong>add(int index,E e)方法</strong></li>
</ul>
<img src="../imgs/blog29/image-20221029135045120.png" alt="image-20221029135045120" style="zoom:80%;" />

<ul>
<li><strong>remove(Object obj)方法</strong></li>
</ul>
<img src="../imgs/blog29/image-20221029134721089.png" alt="image-20221029134721089" style="zoom:80%;" />

<ul>
<li><strong>remove(int index)方法</strong></li>
</ul>
<img src="../imgs/blog29/image-20221029134807613.png" alt="image-20221029134807613" style="zoom:80%;" />



<h2 id="8-Map接口分析"><a href="#8-Map接口分析" class="headerlink" title="8. Map接口分析"></a>8. Map接口分析</h2><h3 id="8-1-哈希表的物理结构"><a href="#8-1-哈希表的物理结构" class="headerlink" title="8.1 哈希表的物理结构"></a>8.1 哈希表的物理结构</h3><p>HashMap和Hashtable底层都是哈希表（也称散列表），其中维护了一个长度为<strong>2的幂次方</strong>的Entry类型的数组table，数组的每一个索引位置被称为一个桶(bucket)，你添加的映射关系(key,value)最终都被封装为一个Map.Entry类型的对象，放到某个table[index]桶中。</p>
<p>使用数组的目的是查询和添加的效率高，可以根据索引直接定位到某个table[index]。</p>
<img src="../imgs/blog29/image-20221029144811305.png" alt="image-20221029144811305" style="zoom:80%;" />

<h3 id="8-2-HashMap中数据添加过程"><a href="#8-2-HashMap中数据添加过程" class="headerlink" title="8.2 HashMap中数据添加过程"></a>8.2 HashMap中数据添加过程</h3><h4 id="8-2-1-JDK7中过程分析"><a href="#8-2-1-JDK7中过程分析" class="headerlink" title="8.2.1 JDK7中过程分析"></a>8.2.1 JDK7中过程分析</h4><pre><code class="java">// 在底层创建了长度为16的Entry[] table的数组
HashMap map = new HashMap(); 
</code></pre>
<pre><code class="java">map.put(key1,value1);
/*
分析过程如下：

将(key1,value1)添加到当前hashmap的对象中。首先会调用key1所在类的hashCode()方法，计算key1的哈希值1，
此哈希值1再经过某种运算(hash())，得到哈希值2。此哈希值2再经过某种运算(indexFor())，确定在底层table数组中的索引位置i。
   （1）如果数组索引为i上的数据为空，则(key1,value1)直接添加成功   ------位置1
   （2）如果数组索引为i上的数据不为空，有(key2,value2)，则需要进一步判断：
       判断key1的哈希值2与key2的哈希值是否相同：
         （3） 如果哈希值不同，则(key1,value1)直接添加成功   ------位置2
              如果哈希值相同，则需要继续调用key1所在类的equals()方法，将key2放入equals()形参进行判断
                （4） equals方法返回false : 则(key1,value1)直接添加成功   ------位置3
                      equals方法返回true : 默认情况下，value1会覆盖value2。

位置1：直接将(key1,value1)以Entry对象的方式存放到table数组索引i的位置。
位置2、位置3：(key1,value1) 与现有的元素以链表的方式存储在table数组索引i的位置，新添加的元素指向旧添加的元素。

...
在不断的添加的情况下，满足如下条件的情况下，会进行扩容:
if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) :
默认情况下，当要添加的元素个数超过12(即：数组的长度 * loadFactor得到的结果)时，就要考虑扩容。

补充：jdk7源码中定义的：
static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;
*/
</code></pre>
<pre><code class="java">map.get(key1);
/*
① 计算key1的hash值，用这个方法hash(key1)

② 找index = table.length-1 &amp; hash;

③ 如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就返回它的value
*/
</code></pre>
<pre><code class="java">map.remove(key1);
/*
① 计算key1的hash值，用这个方法hash(key1)

② 找index = table.length-1 &amp; hash;

③ 如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next
*/
</code></pre>
<h4 id="8-2-2-JDK8中过程分析"><a href="#8-2-2-JDK8中过程分析" class="headerlink" title="8.2.2 JDK8中过程分析"></a>8.2.2 JDK8中过程分析</h4><p>下面说明是JDK8相较于JDK7的不同之处：</p>
<pre><code class="java">/*
①
使用HashMap()的构造器创建对象时，并没有在底层初始化长度为16的table数组。

②
jdk8中添加的key,value封装到了HashMap.Node类的对象中。而非jdk7中的HashMap.Entry。

③
jdk8中新增的元素所在的索引位置如果有其他元素。在经过一系列判断后，如果能添加，则是旧的元素指向新的元素。而非jdk7中的新的元素指向旧的元素。“七上八下”

④
jdk7时底层的数据结构是：数组+单向链表。 而jdk8时，底层的数据结构是：数组+单向链表+红黑树。
红黑树出现的时机：当某个索引位置i上的链表的长度达到8，且数组的长度超过64时，此索引位置上的元素要从单向链表改为红黑树。
如果索引i位置是红黑树的结构，当不断删除元素的情况下，当前索引i位置上的元素的个数低于6时，要从红黑树改为单向链表。

*/
</code></pre>
<h3 id="8-3-HashMap源码剖析"><a href="#8-3-HashMap源码剖析" class="headerlink" title="8.3 HashMap源码剖析"></a>8.3 HashMap源码剖析</h3><h4 id="8-3-1-JDK1-7-0-07中源码"><a href="#8-3-1-JDK1-7-0-07中源码" class="headerlink" title="8.3.1 JDK1.7.0_07中源码"></a>8.3.1 JDK1.7.0_07中源码</h4><p><img src="/../imgs/blog29/image-20220514190849626-1661448231966.png" alt="image-20220514190849626"></p>
<h5 id="1、Entry"><a href="#1、Entry" class="headerlink" title="1、Entry"></a><strong>1、Entry</strong></h5><p>key-value被封装为HashMap.Entry类型，而这个类型实现了Map.Entry接口。</p>
<pre><code class="java">public class HashMap&lt;K,V&gt;&#123;
    transient Entry&lt;K,V&gt;[] table;
    
    static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;
        final K key;
        V value;
        Entry&lt;K,V&gt; next;
        int hash;

        /**
         * Creates new entry.
         */
        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;
            value = v;
            next = n;
            key = k;
            hash = h;
        &#125;
        //略
    &#125;
&#125;
</code></pre>
<h5 id="2、属性"><a href="#2、属性" class="headerlink" title="2、属性"></a><strong>2、属性</strong></h5><pre><code class="java">//table数组的默认初始化长度
static final int DEFAULT_INITIAL_CAPACITY = 16;
//哈希表
transient Entry&lt;K,V&gt;[] table;
//哈希表中key-value的个数
transient int size;
//临界值、阈值（扩容的临界值）
int threshold;
//加载因子
final float loadFactor;
//默认加载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;
</code></pre>
<h5 id="3、构造器"><a href="#3、构造器" class="headerlink" title="3、构造器"></a><strong>3、构造器</strong></h5><pre><code class="java">public HashMap() &#123;
    //DEFAULT_INITIAL_CAPACITY：默认初始容量16
      //DEFAULT_LOAD_FACTOR：默认加载因子0.75
    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
&#125;
</code></pre>
<pre><code class="java">public HashMap(int initialCapacity, float loadFactor) &#123;
    //校验initialCapacity合法性
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity);
    //校验initialCapacity合法性 
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    //校验loadFactor合法性
    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor);

    //计算得到table数组的长度（保证capacity是2的整次幂）
    int capacity = 1;
    while (capacity &lt; initialCapacity)
        capacity &lt;&lt;= 1;
    //加载因子，初始化为0.75
    this.loadFactor = loadFactor;
    // threshold 初始为默认容量
    threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
    //初始化table数组
    table = new Entry[capacity];
    useAltHashing = sun.misc.VM.isBooted() &amp;&amp;
                                       (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);
    init();
&#125;
</code></pre>
<h5 id="4、put-方法"><a href="#4、put-方法" class="headerlink" title="4、put()方法"></a><strong>4、put()方法</strong></h5><pre><code class="java">public V put(K key, V value) &#123;
    //如果key是null，单独处理，存储到table[0]中，如果有另一个key为null，value覆盖
    if (key == null)
        return putForNullKey(value);
    //对key的hashCode进行干扰，算出一个hash值
    /*
      hashCode值        xxxxxxxxxx
      table.length-1    000001111
   
      hashCode值 xxxxxxxxxx  无符号右移几位和原来的hashCode值做^运算，使得hashCode高位二进制值参与计算，
                            也发挥作用，降低index冲突的概率。
    */
    int hash = hash(key);
    //计算新的映射关系应该存到table[i]位置，
    //i = hash &amp; table.length-1，可以保证i在[0,table.length-1]范围内
    int i = indexFor(hash, table.length);
    //检查table[i]下面有没有key与我新的映射关系的key重复，如果重复替换value
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        &#125;
    &#125;

    modCount++;
    //添加新的映射关系
    addEntry(hash, key, value, i);
    return null;
&#125;
</code></pre>
<p>其中，</p>
<pre><code class="java">//如果key是null，直接存入[0]的位置
private V putForNullKey(V value) &#123;
    //判断是否有重复的key，如果有重复的，就替换value
    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;
        if (e.key == null) &#123;
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        &#125;
    &#125;
    modCount++;
    //把新的映射关系存入[0]的位置，而且key的hash值用0表示
    addEntry(0, null, value, 0);
    return null;
&#125;
</code></pre>
<pre><code class="java">final int hash(Object k) &#123;
    int h = 0;
    if (useAltHashing) &#123;
        if (k instanceof String) &#123;
            return sun.misc.Hashing.stringHash32((String) k);
        &#125;
        h = hashSeed;
    &#125;

    h ^= k.hashCode();

    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).
    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
&#125;
</code></pre>
<pre><code class="java">static int indexFor(int h, int length) &#123;
    return h &amp; (length-1);
&#125;
</code></pre>
<pre><code class="java">void addEntry(int hash, K key, V value, int bucketIndex) &#123;
    //判断是否需要库容
    //扩容：（1）size达到阈值（2）table[i]正好非空
    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;
        //table扩容为原来的2倍，并且扩容后，会重新调整所有key-value的存储位置
        resize(2 * table.length); 
        //新的key-value的hash和index也会重新计算
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    &#125;
    //存入table中
    createEntry(hash, key, value, bucketIndex);
&#125;
</code></pre>
<pre><code class="java">void createEntry(int hash, K key, V value, int bucketIndex) &#123;
    Entry&lt;K,V&gt; e = table[bucketIndex];
    //原来table[i]下面的映射关系作为新的映射关系next
    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
    //个数增加
    size++; 
&#125;
</code></pre>
<h4 id="8-3-2-JDK1-8-0-271中源码"><a href="#8-3-2-JDK1-8-0-271中源码" class="headerlink" title="8.3.2 JDK1.8.0_271中源码"></a>8.3.2 JDK1.8.0_271中源码</h4><h5 id="1、Node"><a href="#1、Node" class="headerlink" title="1、Node"></a><strong>1、Node</strong></h5><p>key-value被封装为HashMap.Node类型或HashMap.TreeNode类型，它俩都直接或间接的实现了Map.Entry接口。</p>
<p>存储到table数组的可能是Node结点对象，也可能是TreeNode结点对象，它们也是Map.Entry接口的实现类。即table[index]下的映射关系可能串起来一个链表或一棵红黑树。</p>
<p><img src="/../imgs/blog29/image-20220514190904009-1661448231966.png" alt="image-20220514190904009"></p>
<pre><code class="java">public class HashMap&lt;K,V&gt;&#123;
    transient Node&lt;K,V&gt;[] table;
    
    //Node类
    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;
        final int hash;
        final K key;
        V value;
        Node&lt;K,V&gt; next;

        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        &#125;
        // 其它结构：略
    &#125;
    
    //TreeNode类
    static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;
        TreeNode&lt;K,V&gt; parent;
        TreeNode&lt;K,V&gt; left;
        TreeNode&lt;K,V&gt; right;
        TreeNode&lt;K,V&gt; prev;
        boolean red; //是红结点还是黑结点
        TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;
            super(hash, key, val, next);
        &#125;
    &#125;
    
    //....
&#125;
</code></pre>
<h5 id="2、属性-1"><a href="#2、属性-1" class="headerlink" title="2、属性"></a><strong>2、属性</strong></h5><pre><code class="java">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 默认的初始容量 16
static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //最大容量  1 &lt;&lt; 30
static final float DEFAULT_LOAD_FACTOR = 0.75f;  //默认加载因子
static final int TREEIFY_THRESHOLD = 8; //默认树化阈值8，当链表的长度达到这个值后，要考虑树化
static final int UNTREEIFY_THRESHOLD = 6;//默认反树化阈值6，当树中结点的个数达到此阈值后，要考虑变为链表

//当单个的链表的结点个数达到8，并且table的长度达到64，才会树化。
//当单个的链表的结点个数达到8，但是table的长度未达到64，会先扩容
static final int MIN_TREEIFY_CAPACITY = 64; //最小树化容量64

transient Node&lt;K,V&gt;[] table; //数组
transient int size;  //记录有效映射关系的对数，也是Entry对象的个数
int threshold; //阈值，当size达到阈值时，考虑扩容
final float loadFactor; //加载因子，影响扩容的频率
</code></pre>
<h5 id="3、构造器-1"><a href="#3、构造器-1" class="headerlink" title="3、构造器"></a><strong>3、构造器</strong></h5><pre><code class="java">public HashMap() &#123;
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted (其他字段都是默认值)
&#125;
</code></pre>
<h5 id="4、put-方法-1"><a href="#4、put-方法-1" class="headerlink" title="4、put()方法"></a><strong>4、put()方法</strong></h5><pre><code>public V put(K key, V value) &#123;
    return putVal(hash(key), key, value, false, true);
&#125;
</code></pre>
<p>其中，</p>
<pre><code class="java">static final int hash(Object key) &#123;
    int h;
    //如果key是null，hash是0
    //如果key非null，用key的hashCode值 与 key的hashCode值高16进行异或
    //		即就是用key的hashCode值高16位与低16位进行了异或的干扰运算
        
    /*
    index = hash &amp; table.length-1
    如果用key的原始的hashCode值  与 table.length-1 进行按位与，那么基本上高16没机会用上。
    这样就会增加冲突的概率，为了降低冲突的概率，把高16位加入到hash信息中。
    */
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
&#125;
</code></pre>
<pre><code class="java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) &#123;
    Node&lt;K,V&gt;[] tab; //数组
    Node&lt;K,V&gt; p;  //一个结点
    int n, i; //n是数组的长度   i是下标
    
    //tab和table等价
    //如果table是空的
    if ((tab = table) == null || (n = tab.length) == 0)&#123;
        n = (tab = resize()).length;
        /*
        tab = resize();
        n = tab.length;*/
        /*
        如果table是空的，resize()完成了①创建了一个长度为16的数组②threshold = 12
        n = 16
        */
    &#125;
    //i = (n - 1) &amp; hash ，下标 = 数组长度-1 &amp; hash
    //p = tab[i] 第1个结点
    //if(p==null) 条件满足的话说明 table[i]还没有元素
    if ((p = tab[i = (n - 1) &amp; hash]) == null)&#123;
        //把新的映射关系直接放入table[i]
        tab[i] = newNode(hash, key, value, null);
        //newNode（）方法就创建了一个Node类型的新结点，新结点的next是null
    &#125;else &#123;
        Node&lt;K,V&gt; e; K k;
        //p是table[i]中第一个结点
        //if(table[i]的第一个结点与新的映射关系的key重复)
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;//用e记录这个table[i]的第一个结点
        else if (p instanceof TreeNode)&#123; //如果table[i]第一个结点是一个树结点
            //单独处理树结点
            //如果树结点中，有key重复的，就返回那个重复的结点用e接收，即e!=null
            //如果树结点中，没有key重复的，就把新结点放到树中，并且返回null，即e=null
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        &#125;else &#123;
            //table[i]的第一个结点不是树结点，也与新的映射关系的key不重复
            //binCount记录了table[i]下面的结点的个数
            for (int binCount = 0; ; ++binCount) &#123;
                //如果p的下一个结点是空的，说明当前的p是最后一个结点
                if ((e = p.next) == null) &#123;
                    //把新的结点连接到table[i]的最后
                    p.next = newNode(hash, key, value, null);
                    //如果binCount&gt;=8-1，达到7个时
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        //要么扩容，要么树化
                        treeifyBin(tab, hash);
                    break;
                &#125;
                //如果key重复了，就跳出for循环，此时e结点记录的就是那个key重复的结点
                if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;//下一次循环，e=p.next，就类似于e=e.next，往链表下移动
            &#125;
        &#125;
        //如果这个e不是null，说明有key重复，就考虑替换原来的value
        if (e != null) &#123; // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e); //什么也没干
            return oldValue;
        &#125;
    &#125;
    ++modCount;
    
    //元素个数增加
    //size达到阈值
    if (++size &gt; threshold)
        resize(); //一旦扩容，重新调整所有映射关系的位置
    afterNodeInsertion(evict); //什么也没干
    return null;
&#125;
</code></pre>
<pre><code class="java">final Node&lt;K,V&gt;[] resize() &#123;
    Node&lt;K,V&gt;[] oldTab = table; //oldTab原来的table
    //oldCap：原来数组的长度
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    //oldThr：原来的阈值
    int oldThr = threshold;//最开始threshold是0
    
    //newCap，新容量
    //newThr：新阈值
    int newCap, newThr = 0;
    if (oldCap &gt; 0) &#123; //说明原来不是空数组
        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; //是否达到数组最大限制
            threshold = Integer.MAX_VALUE;
            return oldTab;
        &#125;
        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            //newCap = 旧的容量*2 ，新容量&lt;最大数组容量限制
            //新容量：32,64，...
            //oldCap &gt;= 初始容量16
            //新阈值重新算 = 24，48 ....
            newThr = oldThr &lt;&lt; 1; // double threshold
    &#125;
    else if (oldThr &gt; 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else &#123;               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY; //新容量是默认初始化容量16
        //新阈值= 默认的加载因子 * 默认的初始化容量 = 0.75*16 = 12
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    &#125;
    if (newThr == 0) &#123;
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    &#125;
    threshold = newThr; //阈值赋值为新阈值12，24.。。。
    //创建了一个新数组，长度为newCap，16，32,64.。。
    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
    table = newTab;
    if (oldTab != null) &#123; //原来不是空数组
        //把原来的table中映射关系，倒腾到新的table中
        for (int j = 0; j &lt; oldCap; ++j) &#123;
            Node&lt;K,V&gt; e;
            if ((e = oldTab[j]) != null) &#123;//e是table下面的结点
                oldTab[j] = null; //把旧的table[j]位置清空
                if (e.next == null) //如果是最后一个结点
                    newTab[e.hash &amp; (newCap - 1)] = e; //重新计算e的在新table中的存储位置，然后放入
                else if (e instanceof TreeNode) //如果e是树结点
                    //把原来的树拆解，放到新的table
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                else &#123; // preserve order
                    Node&lt;K,V&gt; loHead = null, loTail = null;
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;
                    Node&lt;K,V&gt; next;
                    //把原来table[i]下面的整个链表，重新挪到了新的table中
                    do &#123;
                        next = e.next;
                        if ((e.hash &amp; oldCap) == 0) &#123;
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        &#125;
                        else &#123;
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        &#125;
                    &#125; while ((e = next) != null);
                    if (loTail != null) &#123;
                        loTail.next = null;
                        newTab[j] = loHead;
                    &#125;
                    if (hiTail != null) &#123;
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    return newTab;
&#125;
</code></pre>
<pre><code class="java">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;
    //创建一个新结点
    return new Node&lt;&gt;(hash, key, value, next);
&#125;
</code></pre>
<pre><code class="java">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;
    int n, index; 
    Node&lt;K,V&gt; e;
    //MIN_TREEIFY_CAPACITY：最小树化容量64
    //如果table是空的，或者  table的长度没有达到64
    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
        resize();//先扩容
    else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;
        //用e记录table[index]的结点的地址
        TreeNode&lt;K,V&gt; hd = null, tl = null;
        /*
            do...while，把table[index]链表的Node结点变为TreeNode类型的结点
            */
        do &#123;
            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;//hd记录根结点
            else &#123;
                p.prev = tl;
                tl.next = p;
            &#125;
            tl = p;
        &#125; while ((e = e.next) != null);

        //如果table[index]下面不是空
        if ((tab[index] = hd) != null)
            hd.treeify(tab);//将table[index]下面的链表进行树化
    &#125;
&#125;	
</code></pre>
<p>小结：</p>
<p><img src="/../imgs/blog29/image-20220524142524796-1661448231966.png" alt="image-20220524142524796"></p>
<h3 id="8-4-LinkedHashMap源码剖析"><a href="#8-4-LinkedHashMap源码剖析" class="headerlink" title="8.4 LinkedHashMap源码剖析"></a>8.4 LinkedHashMap源码剖析</h3><h4 id="8-4-1-源码"><a href="#8-4-1-源码" class="headerlink" title="8.4.1 源码"></a>8.4.1 源码</h4><p>内部定义的Entry如下：</p>
<pre><code class="java">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;
    Entry&lt;K,V&gt; before, after;
    
    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;
        super(hash, key, value, next);
    &#125;
&#125;
</code></pre>
<p>LinkedHashMap重写了HashMap中的newNode()方法：</p>
<pre><code class="java">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;
    LinkedHashMap.Entry&lt;K,V&gt; p =
        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);
    linkNodeLast(p);
    return p;
&#125;
</code></pre>
<pre><code class="java">TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;
    TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(hash, key, value, next);
    linkNodeLast(p);
    return p;
&#125;
</code></pre>
<h4 id="8-4-2-图示"><a href="#8-4-2-图示" class="headerlink" title="8.4.2 图示"></a>8.4.2 图示</h4><img src="../imgs/blog29/image-20221029145708224.png" alt="image-20221029145708224" style="zoom:80%;" />

<h2 id="9-Set接口分析"><a href="#9-Set接口分析" class="headerlink" title="9. Set接口分析"></a>9. Set接口分析</h2><h3 id="9-1-Set集合与Map集合的关系"><a href="#9-1-Set集合与Map集合的关系" class="headerlink" title="9.1 Set集合与Map集合的关系"></a>9.1 Set集合与Map集合的关系</h3><p>Set的内部实现其实是一个Map，Set中的元素，存储在HashMap的key中。即HashSet的内部实现是一个HashMap，TreeSet的内部实现是一个TreeMap，LinkedHashSet的内部实现是一个LinkedHashMap。</p>
<h3 id="9-2-源码剖析"><a href="#9-2-源码剖析" class="headerlink" title="9.2 源码剖析"></a>9.2 源码剖析</h3><p><strong>HashSet源码：</strong></p>
<pre><code class="java">//构造器
public HashSet() &#123;
    map = new HashMap&lt;&gt;();
&#125;

public HashSet(int initialCapacity, float loadFactor) &#123;
    map = new HashMap&lt;&gt;(initialCapacity, loadFactor);
&#125;

public HashSet(int initialCapacity) &#123;
    map = new HashMap&lt;&gt;(initialCapacity);
&#125;

//这个构造器是给子类LinkedHashSet调用的
HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;
    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);
&#125;

//add()方法：
public boolean add(E e) &#123;
    return map.put(e, PRESENT)==null;
&#125;
//其中，
private transient HashMap&lt;E,Object&gt; map;
private static final Object PRESENT = new Object();

//iterator()方法：
public Iterator&lt;E&gt; iterator() &#123;
    return map.keySet().iterator();
&#125;
</code></pre>
<p><strong>LinkedHashSet源码：</strong></p>
<pre><code class="java">//构造器
public LinkedHashSet() &#123;
    super(16, .75f, true);
&#125; 
public LinkedHashSet(int initialCapacity) &#123;
    super(initialCapacity, .75f, true);//调用HashSet的某个构造器
&#125;
public LinkedHashSet(int initialCapacity, float loadFactor) &#123;
    super(initialCapacity, loadFactor, true);//调用HashSet的某个构造器
&#125; 
</code></pre>
<p><strong>TreeSet源码：</strong></p>
<pre><code class="java">public TreeSet() &#123;
    this(new TreeMap&lt;E,Object&gt;());
&#125;

TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;
    this.m = m;
&#125;
//其中，
private transient NavigableMap&lt;E,Object&gt; m;

//add()方法：
public boolean add(E e) &#123;
    return m.put(e, PRESENT)==null;
&#125;
//其中，
private static final Object PRESENT = new Object();
</code></pre>
<h2 id="10-【拓展】HashMap的相关问题"><a href="#10-【拓展】HashMap的相关问题" class="headerlink" title="10. 【拓展】HashMap的相关问题"></a>10. 【拓展】HashMap的相关问题</h2><h4 id="1、说说你理解的哈希算法"><a href="#1、说说你理解的哈希算法" class="headerlink" title="1、说说你理解的哈希算法"></a>1、说说你理解的哈希算法</h4><p>hash算法是一种可以从任何数据中提取出其“指纹”的数据摘要算法，它将任意大小的数据映射到一个固定大小的序列上，这个序列被称为hash code、数据摘要或者指纹。比较出名的hash算法有MD5、SHA。hash是具有唯一性且不可逆的，唯一性是指相同的“对象”产生的hash code永远是一样的。</p>
<p><img src="/../imgs/blog29/1563797150134-1661448231965.png" alt="1563797150134"></p>
<h4 id="2、Entry中的hash属性为什么不直接使用key的hashCode-返回值呢？"><a href="#2、Entry中的hash属性为什么不直接使用key的hashCode-返回值呢？" class="headerlink" title="2、Entry中的hash属性为什么不直接使用key的hashCode()返回值呢？"></a>2、Entry中的hash属性为什么不直接使用key的hashCode()返回值呢？</h4><p>不管是JDK1.7还是JDK1.8中，都不是直接用key的hashCode值直接与table.length-1计算求下标的，而是先对key的hashCode值进行了一个运算，JDK1.7和JDK1.8关于hash()的实现代码不一样，但是不管怎么样都是为了提高hash code值与 (table.length-1)的按位与完的结果，尽量的均匀分布。</p>
<p><img src="/../imgs/blog29/image-20220514190454633-1661448231965.png" alt="image-20220514190454633"></p>
<p>JDK1.7：</p>
<pre><code class="java">    final int hash(Object k) &#123;
        int h = hashSeed;
        if (0 != h &amp;&amp; k instanceof String) &#123;
            return sun.misc.Hashing.stringHash32((String) k);
        &#125;

        h ^= k.hashCode();
        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
    &#125;
</code></pre>
<p>JDK1.8：</p>
<pre><code class="java">    static final int hash(Object key) &#123;
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    &#125;
</code></pre>
<p>虽然算法不同，但是思路都是将hashCode值的高位二进制与低位二进制值进行了异或，然高位二进制参与到index的计算中。</p>
<p>为什么要hashCode值的二进制的高位参与到index计算呢？</p>
<p>因为一个HashMap的table数组一般不会特别大，至少在不断扩容之前，那么table.length-1的大部分高位都是0，直接用hashCode和table.length-1进行&amp;运算的话，就会导致总是只有最低的几位是有效的，那么就算你的hashCode()实现的再好也难以避免发生碰撞，这时让高位参与进来的意义就体现出来了。它对hashcode的低位添加了随机性并且混合了高位的部分特征，显著减少了碰撞冲突的发生。</p>
<h4 id="3、HashMap是如何决定某个key-value存在哪个桶的呢？"><a href="#3、HashMap是如何决定某个key-value存在哪个桶的呢？" class="headerlink" title="3、HashMap是如何决定某个key-value存在哪个桶的呢？"></a>3、HashMap是如何决定某个key-value存在哪个桶的呢？</h4><p>因为hash值是一个整数，而数组的长度也是一个整数，有两种思路：</p>
<p>①hash 值 % table.length会得到一个[0,table.length-1]范围的值，正好是下标范围，但是用%运算效率没有位运算符&amp;高。</p>
<p>②hash 值 &amp; (table.length-1)，任何数 &amp; (table.length-1)的结果也一定在[0, table.length-1]范围。</p>
<p><img src="/../imgs/blog29/1563800372286-1661448231966.png" alt="1563800372286"></p>
<p>JDK1.7：</p>
<pre><code class="java">static int indexFor(int h, int length) &#123;
    // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;
    return h &amp; (length-1); //此处h就是hash
&#125;
</code></pre>
<p>JDK1.8：</p>
<pre><code class="java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) &amp; hash]) == null)  // i = (n - 1) &amp; hash
        tab[i] = newNode(hash, key, value, null);
    //....省略大量代码
&#125;
</code></pre>
<h4 id="4、为什么要保持table数组一直是2的n次幂呢？"><a href="#4、为什么要保持table数组一直是2的n次幂呢？" class="headerlink" title="4、为什么要保持table数组一直是2的n次幂呢？"></a>4、为什么要保持table数组一直是2的n次幂呢？</h4><p>因为如果数组的长度为2的n次幂，那么table.length-1的二进制就是一个高位全是0，低位全是1的数字，这样才能保证每一个下标位置都有机会被用到。</p>
<p>举例1：</p>
<pre><code class="java">hashCode值是   ？
table.length是10
table.length-1是9

？   ????????
9	 00001001
&amp;_____________
     00000000	[0]
     00000001	[1]
     00001000	[8]
     00001001	[9]
     一定[0]~[9]
</code></pre>
<p>举例2：</p>
<pre><code class="java">hashCode值是   ？
table.length是16
table.length-1是15

？   ????????
15	 00001111
&amp;_____________
     00000000	[0]
     00000001	[1]
     00000010	[2]
     00000011	[3]
     ...
     00001111    [15]
     范围是[0,15]，一定在[0,table.length-1]范围内
</code></pre>
<h4 id="5、解决-index-冲突问题"><a href="#5、解决-index-冲突问题" class="headerlink" title="5、解决[index]冲突问题"></a>5、解决[index]冲突问题</h4><p>虽然从设计hashCode()到上面HashMap的hash()函数，都尽量减少冲突，但是仍然存在两个不同的对象返回的hashCode值相同，或者hashCode值就算不同，通过hash()函数计算后，得到的index也会存在大量的相同，因此key分布完全均匀的情况是不存在的。那么发生碰撞冲突时怎么办？</p>
<p>JDK1.8之间使用：数组+链表的结构。</p>
<p><img src="/../imgs/blog29/1563802656661-1661448231966.png" alt="1563802656661"></p>
<p>JDK1.8之后使用：数组+链表&#x2F;红黑树的结构。</p>
<p><img src="/../imgs/blog29/1563802665708-1661448231966.png" alt="1563802665708"></p>
<p>即hash相同或hash&amp;(table.lengt-1)的值相同，那么就存入同一个“桶”table[index]中，使用链表或红黑树连接起来。</p>
<h4 id="6、为什么JDK1-8会出现红黑树和链表共存呢？"><a href="#6、为什么JDK1-8会出现红黑树和链表共存呢？" class="headerlink" title="6、为什么JDK1.8会出现红黑树和链表共存呢？"></a>6、为什么JDK1.8会出现红黑树和链表共存呢？</h4><p>因为当冲突比较严重时，table[index]下面的链表就会很长，那么会导致查找效率大大降低，而如果此时选用二叉树可以大大提高查询效率。</p>
<p>但是二叉树的结构又过于复杂，占用内存也较多，如果结点个数比较少的时候，那么选择链表反而更简单。所以会出现红黑树和链表共存。</p>
<h4 id="7、加载因子的值大小有什么关系？"><a href="#7、加载因子的值大小有什么关系？" class="headerlink" title="7、加载因子的值大小有什么关系？"></a>7、加载因子的值大小有什么关系？</h4><p>如果太大，threshold就会很大，那么如果冲突比较严重的话，就会导致table[index]下面的结点个数很多，影响效率。</p>
<p>如果太小，threshold就会很小，那么数组扩容的频率就会提高，数组的使用率也会降低，那么会造成空间的浪费。</p>
<h4 id="8、什么时候树化？什么时候反树化？"><a href="#8、什么时候树化？什么时候反树化？" class="headerlink" title="8、什么时候树化？什么时候反树化？"></a>8、什么时候树化？什么时候反树化？</h4><pre><code class="java">static final int TREEIFY_THRESHOLD = 8;//树化阈值
static final int UNTREEIFY_THRESHOLD = 6;//反树化阈值
static final int MIN_TREEIFY_CAPACITY = 64;//最小树化容量
</code></pre>
<ul>
<li><p>当某table[index]下的链表的结点个数达到8，并且table.length&gt;&#x3D;64，那么如果新Entry对象还添加到该table[index]中，那么就会将table[index]的链表进行树化。</p>
</li>
<li><p>当某table[index]下的红黑树结点个数少于6个，此时，</p>
<ul>
<li>当继续删除table[index]下的树结点，最后这个根结点的左右结点有null，或根结点的左结点的左结点为null，会反树化</li>
<li>当重新添加新的映射关系到map中，导致了map重新扩容了，这个时候如果table[index]下面还是小于等于6的个数，那么会反树化</li>
</ul>
</li>
</ul>
<pre><code class="java">package com.atguigu.map;

public class MyKey&#123;
    int num;

    public MyKey(int num) &#123;
        super();
        this.num = num;
    &#125;

    @Override
    public int hashCode() &#123;
        if(num&lt;=20)&#123;
            return 1;
        &#125;else&#123;
            final int prime = 31;
            int result = 1;
            result = prime * result + num;
            return result;
        &#125;
    &#125;

    @Override
    public boolean equals(Object obj) &#123;
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        MyKey other = (MyKey) obj;
        if (num != other.num)
            return false;
        return true;
    &#125;

&#125;
</code></pre>
<pre><code class="java">package com.atguigu.map;

import org.junit.Test;

import java.util.HashMap;

public class TestHashMapMyKey &#123;
    @Test
    public void test1()&#123;
        //这里为了演示的效果，我们造一个特殊的类，这个类的hashCode（）方法返回固定值1
        //因为这样就可以造成冲突问题，使得它们都存到table[1]中
        HashMap&lt;MyKey, String&gt; map = new HashMap&lt;&gt;();
        for (int i = 1; i &lt;= 11; i++) &#123;
            map.put(new MyKey(i), &quot;value&quot;+i);//树化演示
        &#125;
    &#125;
    @Test
    public void test2()&#123;
        HashMap&lt;MyKey, String&gt; map = new HashMap&lt;&gt;();
        for (int i = 1; i &lt;= 11; i++) &#123;
            map.put(new MyKey(i), &quot;value&quot;+i);
        &#125;
        for (int i = 1; i &lt;=11; i++) &#123;
            map.remove(new MyKey(i));//反树化演示
        &#125;
    &#125;
    @Test
    public void test3()&#123;
        HashMap&lt;MyKey, String&gt; map = new HashMap&lt;&gt;();
        for (int i = 1; i &lt;= 11; i++) &#123;
            map.put(new MyKey(i), &quot;value&quot;+i);
        &#125;

        for (int i = 1; i &lt;=5; i++) &#123;
            map.remove(new MyKey(i));
        &#125;//table[1]下剩余6个结点

        for (int i = 21; i &lt;= 100; i++) &#123;
            map.put(new MyKey(i), &quot;value&quot;+i);//添加到扩容时，反树化
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="9、key-value中的key是否可以修改？"><a href="#9、key-value中的key是否可以修改？" class="headerlink" title="9、key-value中的key是否可以修改？"></a>9、key-value中的key是否可以修改？</h4><p>key-value存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的key-value，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。</p>
<p>这个规则也同样适用于LinkedHashMap、HashSet、LinkedHashSet、Hashtable等所有散列存储结构的集合。</p>
<h4 id="10、JDK1-7中HashMap的循环链表是怎么回事？如何解决？"><a href="#10、JDK1-7中HashMap的循环链表是怎么回事？如何解决？" class="headerlink" title="10、JDK1.7中HashMap的循环链表是怎么回事？如何解决？"></a>10、JDK1.7中HashMap的循环链表是怎么回事？如何解决？</h4><p><img src="/../imgs/blog29/HashMap%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98.jpg" alt="HashMap的循环引用问题"></p>
<p>避免HashMap发生死循环的常用解决方案：</p>
<ul>
<li>多线程环境下，使用线程安全的ConcurrentHashMap替代HashMap，推荐</li>
<li>多线程环境下，使用synchronized或Lock加锁，但会影响性能，不推荐</li>
<li>多线程环境下，使用线程安全的Hashtable替代，性能低，不推荐</li>
</ul>
<p>HashMap死循环只会发生在JDK1.7版本中，主要原因：头插法+链表+多线程并发+扩容。</p>
<p>在JDK1.8中，HashMap改用尾插法，解决了链表死循环的问题。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Mercury</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/08/16/blog29/">http://example.com/2023/08/16/blog29/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Mercury个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法和数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/22/blog41/" title="innodb行锁实现方式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">innodb行锁实现方式</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/12/blog14/" title="从链表中删去总和值为零的连续节点"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">从链表中删去总和值为零的连续节点</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/07/blog13/" title="老鼠和奶酪"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-07</div><div class="title">老鼠和奶酪</div></div></a></div><div><a href="/2023/08/12/blog14/" title="从链表中删去总和值为零的连续节点"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-12</div><div class="title">从链表中删去总和值为零的连续节点</div></div></a></div><div><a href="/2023/11/30/blog28/" title="线段树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-30</div><div class="title">线段树</div></div></a></div><div><a href="/2023/07/21/blog3/" title="无重复字符的最长子串"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">无重复字符的最长子串</div></div></a></div><div><a href="/2023/07/01/blog5/" title="礼盒的最大甜蜜度"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-01</div><div class="title">礼盒的最大甜蜜度</div></div></a></div><div><a href="/2023/08/02/blog7/" title="统计范围内的元音字符串数"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-02</div><div class="title">统计范围内的元音字符串数</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODUzMS8zNDk5NA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Mercury</div><div class="author-info__description">与谁同坐。明月清风我</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Mercury4915"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">java学习日记，不定时更新</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">1.数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text">2. 一维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 数组的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 自定义数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">3. 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%93%BE%E8%A1%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 链表的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 自定义链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 自定义单向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 自定义双向链表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%A0%88"><span class="toc-number">4.</span> <span class="toc-text">4. 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%A0%88%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 栈的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Stack%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 Stack使用举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%88"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 自定义栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%98%9F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">5. 队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">6. 树与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%A0%91%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 树的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 二叉树的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 二叉树的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E7%BB%8F%E5%85%B8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 经典二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E7%BB%93%E7%82%B9%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">6.5.</span> <span class="toc-text">6.5 二叉树及其结点的表示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-List%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90"><span class="toc-number">7.</span> <span class="toc-text">7. List接口分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-List%E6%8E%A5%E5%8F%A3%E7%89%B9%E7%82%B9"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 List接口特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84ArrayList%E4%B8%8EVector"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 动态数组ArrayList与Vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-ArrayList%E4%B8%8EVector%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.2.1.</span> <span class="toc-text">7.2.1 ArrayList与Vector的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-ArrayList%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">7.2.2.</span> <span class="toc-text">7.2.2 ArrayList部分源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-ArrayList%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%E5%9B%BE%E7%A4%BA"><span class="toc-number">7.2.3.</span> <span class="toc-text">7.2.3 ArrayList相关方法图示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-4-Vector%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">7.2.4.</span> <span class="toc-text">7.2.4 Vector部分源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E9%93%BE%E8%A1%A8LinkedList"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 链表LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.3.1.</span> <span class="toc-text">7.3.1 链表与动态数组的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">7.3.2.</span> <span class="toc-text">7.3.2 LinkedList源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-LinkedList%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%E5%9B%BE%E7%A4%BA"><span class="toc-number">7.3.3.</span> <span class="toc-text">7.3.3 LinkedList相关方法图示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Map%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90"><span class="toc-number">8.</span> <span class="toc-text">8. Map接口分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 哈希表的物理结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-HashMap%E4%B8%AD%E6%95%B0%E6%8D%AE%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 HashMap中数据添加过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-JDK7%E4%B8%AD%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">8.2.1.</span> <span class="toc-text">8.2.1 JDK7中过程分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-JDK8%E4%B8%AD%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">8.2.2.</span> <span class="toc-text">8.2.2 JDK8中过程分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-HashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">8.3.</span> <span class="toc-text">8.3 HashMap源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1-JDK1-7-0-07%E4%B8%AD%E6%BA%90%E7%A0%81"><span class="toc-number">8.3.1.</span> <span class="toc-text">8.3.1 JDK1.7.0_07中源码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81Entry"><span class="toc-number">8.3.1.1.</span> <span class="toc-text">1、Entry</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%B1%9E%E6%80%A7"><span class="toc-number">8.3.1.2.</span> <span class="toc-text">2、属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">8.3.1.3.</span> <span class="toc-text">3、构造器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81put-%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.1.4.</span> <span class="toc-text">4、put()方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-JDK1-8-0-271%E4%B8%AD%E6%BA%90%E7%A0%81"><span class="toc-number">8.3.2.</span> <span class="toc-text">8.3.2 JDK1.8.0_271中源码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81Node"><span class="toc-number">8.3.2.1.</span> <span class="toc-text">1、Node</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%B1%9E%E6%80%A7-1"><span class="toc-number">8.3.2.2.</span> <span class="toc-text">2、属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8-1"><span class="toc-number">8.3.2.3.</span> <span class="toc-text">3、构造器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81put-%E6%96%B9%E6%B3%95-1"><span class="toc-number">8.3.2.4.</span> <span class="toc-text">4、put()方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-LinkedHashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">8.4.</span> <span class="toc-text">8.4 LinkedHashMap源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-1-%E6%BA%90%E7%A0%81"><span class="toc-number">8.4.1.</span> <span class="toc-text">8.4.1 源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-%E5%9B%BE%E7%A4%BA"><span class="toc-number">8.4.2.</span> <span class="toc-text">8.4.2 图示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Set%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90"><span class="toc-number">9.</span> <span class="toc-text">9. Set接口分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-Set%E9%9B%86%E5%90%88%E4%B8%8EMap%E9%9B%86%E5%90%88%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 Set集合与Map集合的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 源码剖析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E3%80%90%E6%8B%93%E5%B1%95%E3%80%91HashMap%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">10.</span> <span class="toc-text">10. 【拓展】HashMap的相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-number">10.0.1.</span> <span class="toc-text">1、说说你理解的哈希算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Entry%E4%B8%AD%E7%9A%84hash%E5%B1%9E%E6%80%A7%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8key%E7%9A%84hashCode-%E8%BF%94%E5%9B%9E%E5%80%BC%E5%91%A2%EF%BC%9F"><span class="toc-number">10.0.2.</span> <span class="toc-text">2、Entry中的hash属性为什么不直接使用key的hashCode()返回值呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81HashMap%E6%98%AF%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E6%9F%90%E4%B8%AAkey-value%E5%AD%98%E5%9C%A8%E5%93%AA%E4%B8%AA%E6%A1%B6%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">10.0.3.</span> <span class="toc-text">3、HashMap是如何决定某个key-value存在哪个桶的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BF%9D%E6%8C%81table%E6%95%B0%E7%BB%84%E4%B8%80%E7%9B%B4%E6%98%AF2%E7%9A%84n%E6%AC%A1%E5%B9%82%E5%91%A2%EF%BC%9F"><span class="toc-number">10.0.4.</span> <span class="toc-text">4、为什么要保持table数组一直是2的n次幂呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E8%A7%A3%E5%86%B3-index-%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="toc-number">10.0.5.</span> <span class="toc-text">5、解决[index]冲突问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88JDK1-8%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8C%E9%93%BE%E8%A1%A8%E5%85%B1%E5%AD%98%E5%91%A2%EF%BC%9F"><span class="toc-number">10.0.6.</span> <span class="toc-text">6、为什么JDK1.8会出现红黑树和链表共存呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90%E7%9A%84%E5%80%BC%E5%A4%A7%E5%B0%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">10.0.7.</span> <span class="toc-text">7、加载因子的值大小有什么关系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%A0%91%E5%8C%96%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%8D%E6%A0%91%E5%8C%96%EF%BC%9F"><span class="toc-number">10.0.8.</span> <span class="toc-text">8、什么时候树化？什么时候反树化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81key-value%E4%B8%AD%E7%9A%84key%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%EF%BC%9F"><span class="toc-number">10.0.9.</span> <span class="toc-text">9、key-value中的key是否可以修改？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81JDK1-7%E4%B8%ADHashMap%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">10.0.10.</span> <span class="toc-text">10、JDK1.7中HashMap的循环链表是怎么回事？如何解决？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/18/blog30/" title="Mysql Explain之type详解">Mysql Explain之type详解</a><time datetime="2023-12-18T11:29:46.000Z" title="发表于 2023-12-18 19:29:46">2023-12-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/16/blog15/" title="IO模型">IO模型</a><time datetime="2023-12-16T10:21:45.000Z" title="发表于 2023-12-16 18:21:45">2023-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/15/blog38/" title="TLAB简介">TLAB简介</a><time datetime="2023-12-15T12:54:54.000Z" title="发表于 2023-12-15 20:54:54">2023-12-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/09/blog35/" title="使用canal和RabbitMQ实现缓存数据同步">使用canal和RabbitMQ实现缓存数据同步</a><time datetime="2023-12-09T09:01:31.000Z" title="发表于 2023-12-09 17:01:31">2023-12-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/09/blog34/" title="使用canal实现MySQL和ES数据同步">使用canal实现MySQL和ES数据同步</a><time datetime="2023-12-09T09:01:31.000Z" title="发表于 2023-12-09 17:01:31">2023-12-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Mercury</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !true) {
  if (true) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>