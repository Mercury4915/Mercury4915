<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JAVA IO | Mercury个人博客</title><meta name="author" content="Mercury"><meta name="copyright" content="Mercury"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1 IO介绍​			在Java的软件设计开发中，通信架构是不可避免的，我们在进行不同系统或者不同进程之间的数据交互，或者在高并发下的通信场景下都需要用到网络通信相关的技术，对于一些经验丰富的程序员来说，Java早期的网络通信架构存在一些缺陷，其中最令人恼火的是基于性能低下的同步阻塞式的I&#x2F;O通信（BIO），随着互联网开发下通信性能的高要求，Java在2002年开始支持了非阻塞式的I&amp;#x">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA IO">
<meta property="og:url" content="http://example.com/2023/09/02/blog27/index.html">
<meta property="og:site_name" content="Mercury个人博客">
<meta property="og:description" content="1 IO介绍​			在Java的软件设计开发中，通信架构是不可避免的，我们在进行不同系统或者不同进程之间的数据交互，或者在高并发下的通信场景下都需要用到网络通信相关的技术，对于一些经验丰富的程序员来说，Java早期的网络通信架构存在一些缺陷，其中最令人恼火的是基于性能低下的同步阻塞式的I&#x2F;O通信（BIO），随着互联网开发下通信性能的高要求，Java在2002年开始支持了非阻塞式的I&amp;#x">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2023-09-02T12:58:44.000Z">
<meta property="article:modified_time" content="2023-12-20T02:27:49.111Z">
<meta property="article:author" content="Mercury">
<meta property="article:tag" content="IO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/09/02/blog27/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JAVA IO',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-20 10:27:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/themes/butterfly/source/css/mouse.css?1"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_top_img.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Mercury个人博客"><span class="site-name">Mercury个人博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于作者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JAVA IO</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-02T12:58:44.000Z" title="发表于 2023-09-02 20:58:44">2023-09-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-20T02:27:49.111Z" title="更新于 2023-12-20 10:27:49">2023-12-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JAVA IO"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-IO介绍"><a href="#1-IO介绍" class="headerlink" title="1 IO介绍"></a>1 IO介绍</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>​			在Java的软件设计开发中，通信架构是不可避免的，我们在进行不同系统或者不同进程之间的数据交互，或者在高并发下的通信场景下都需要用到网络通信相关的技术，对于一些经验丰富的程序员来说，Java早期的网络通信架构存在一些缺陷，<strong>其中最令人恼火的是基于性能低下的同步阻塞式的I&#x2F;O通信（BIO）</strong>，随着互联网开发下通信性能的高要求，Java在2002年开始支持了非阻塞式的I&#x2F;O通信技术(NIO)。大多数读者在学习网络通信相关技术的时候，都只是接触到零碎的通信技术点，没有完整的技术体系架构，以至于对于Java的通信场景总是没有清晰的解决方案。本次课程将通过大量清晰直接的案例从最基础的BIO式通信开始介绍到NIO , AIO，读者可以清晰的了解到阻塞、同步、异步的现象、概念和特征以及优缺点。本课程结合了大量的案例让读者可以快速了解每种通信架构的使用。</p>
<h2 id="通信技术整体解决的问题"><a href="#通信技术整体解决的问题" class="headerlink" title="通信技术整体解决的问题"></a>通信技术整体解决的问题</h2><ul>
<li>局域网内的通信要求。</li>
<li>多系统间的底层消息传递机制。</li>
<li>高并发下，大数据量的通信场景需要。</li>
<li>游戏行业。无论是手游服务端，还是大型的网络游戏，Java语言都得到越来越广泛的应用。</li>
</ul>
<h1 id="2-Java的I-x2F-O演进之路"><a href="#2-Java的I-x2F-O演进之路" class="headerlink" title="2 Java的I&#x2F;O演进之路"></a>2 Java的I&#x2F;O演进之路</h1><h2 id="2-1-I-x2F-O-模型基本说明"><a href="#2-1-I-x2F-O-模型基本说明" class="headerlink" title="2.1 I&#x2F;O 模型基本说明"></a>2.1 I&#x2F;O 模型基本说明</h2><p>I&#x2F;O 模型：就是用什么样的通道或者说是通信模式和架构进行数据的传输和接收，很大程度上决定了程序通信的性能，Java 共支持 3 种网络编程的&#x2F;IO 模型：<strong>BIO、NIO、AIO</strong><br>实际通信需求下，要根据不同的业务场景和性能需求决定选择不同的I&#x2F;O模型</p>
<h2 id="2-2-I-x2F-O模型"><a href="#2-2-I-x2F-O模型" class="headerlink" title="2.2 I&#x2F;O模型"></a>2.2 I&#x2F;O模型</h2><h4 id="Java-BIO"><a href="#Java-BIO" class="headerlink" title="Java BIO"></a>Java BIO</h4><p>同步并阻塞(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器<br>端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销 【简单示意图</p>
<p><img src="/../imgs/BLOG28/image-20200615181255063.png" alt="image-20200615181255063"></p>
<h4 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h4><p>Java NIO ： 同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注<br>册到多路复用器上，多路复用器轮询到连接有 I&#x2F;O 请求就进行处理 【简单示意图】</p>
<p><img src="/../imgs/BLOG28/image-20200615180441015.png" alt="image-20200615180441015"></p>
<h4 id="Java-AIO"><a href="#Java-AIO" class="headerlink" title="Java AIO"></a>Java AIO</h4><p>Java AIO(NIO.2) ： 异步 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，一般适用于连接数较<br>多且连接时间较长的应用</p>
<h2 id="2-3-BIO、NIO、AIO-适用场景分析"><a href="#2-3-BIO、NIO、AIO-适用场景分析" class="headerlink" title="2.3 BIO、NIO、AIO 适用场景分析"></a>2.3 BIO、NIO、AIO 适用场景分析</h2><p>1、<strong>BIO</strong> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。<br>2、<strong>NIO</strong> 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。<br>编程比较复杂，JDK1.4 开始支持。</p>
<p>3、AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，<br>编程比较复杂，JDK7 开始支持。</p>
<h1 id="3-JAVA-BIO深入剖析"><a href="#3-JAVA-BIO深入剖析" class="headerlink" title="3 JAVA BIO深入剖析"></a>3 JAVA BIO深入剖析</h1><h2 id="3-1-Java-BIO-基本介绍"><a href="#3-1-Java-BIO-基本介绍" class="headerlink" title="3.1 Java BIO 基本介绍"></a>3.1 Java BIO 基本介绍</h2><ul>
<li>Java BIO 就是传统的 java io  编程，其相关的类和接口在 java.io</li>
<li>BIO(blocking I&#x2F;O) ： 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需<br>要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善(实现多个客户连接服务器).</li>
</ul>
<h2 id="3-2-Java-BIO-工作机制"><a href="#3-2-Java-BIO-工作机制" class="headerlink" title="3.2 Java BIO 工作机制"></a>3.2 Java BIO 工作机制</h2><p><img src="/../imgs/BLOG28/image-20200618222916021.png" alt="image-20200618222916021"></p>
<p>对 对 BIO  编程流程的梳理</p>
<ol>
<li>服务器端启动一个 <strong>ServerSocket</strong>，注册端口，调用accpet方法监听客户端的Socket连接。</li>
<li>客户端启动 <strong>Socket</strong> 对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯</li>
</ol>
<h2 id="3-3-传统的BIO编程实例回顾"><a href="#3-3-传统的BIO编程实例回顾" class="headerlink" title="3.3  传统的BIO编程实例回顾"></a>3.3  传统的BIO编程实例回顾</h2><p>​		网络编程的基本模型是Client&#x2F;Server模型，也就是两个进程之间进行相互通信，其中服务端提供位置信（绑定IP地址和端口），客户端通过连接操作向服务端监听的端口地址发起连接请求，基于TCP协议下进行三次握手连接，连接成功后，双方通过网络套接字（Socket）进行通信。</p>
<p>​		传统的同步阻塞模型开发中，服务端ServerSocket负责绑定IP地址，启动监听端口；客户端Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信。<br>​	 	基于BIO模式下的通信，客户端 - 服务端是完全同步，完全耦合的。	  </p>
<h3 id="客户端案例如下"><a href="#客户端案例如下" class="headerlink" title="客户端案例如下"></a>客户端案例如下</h3><pre><code class="java">package com.itheima._02bio01;

import java.io.OutputStream;
import java.io.PrintStream;
import java.net.Socket;
/**
    目标: Socket网络编程。

    Java提供了一个包：java.net下的类都是用于网络通信。
    Java提供了基于套接字（端口）Socket的网络通信模式，我们基于这种模式就可以直接实现TCP通信。
    只要用Socket通信，那么就是基于TCP可靠传输通信。

    功能1：客户端发送一个消息，服务端接口一个消息，通信结束！！

    创建客户端对象：
        （1）创建一个Socket的通信管道，请求与服务端的端口连接。
        （2）从Socket管道中得到一个字节输出流。
        （3）把字节流改装成自己需要的流进行数据的发送
    创建服务端对象：
        （1）注册端口
        （2）开始等待接收客户端的连接,得到一个端到端的Socket管道
        （3）从Socket管道中得到一个字节输入流。
        （4）把字节输入流包装成自己需要的流进行数据的读取。

    Socket的使用：
        构造器：public Socket(String host, int port)
        方法：  public OutputStream getOutputStream()：获取字节输出流
               public InputStream getInputStream() :获取字节输入流

    ServerSocket的使用：
        构造器：public ServerSocket(int port)

    小结：
        通信是很严格的，对方怎么发你就怎么收，对方发多少你就只能收多少！！

 */
public class ClientDemo &#123;
    public static void main(String[] args) throws Exception &#123;
        System.out.println(&quot;==客户端的启动==&quot;);
        // （1）创建一个Socket的通信管道，请求与服务端的端口连接。
        Socket socket = new Socket(&quot;127.0.0.1&quot;,8888);
        // （2）从Socket通信管道中得到一个字节输出流。
        OutputStream os = socket.getOutputStream();
        // （3）把字节流改装成自己需要的流进行数据的发送
        PrintStream ps = new PrintStream(os);
        // （4）开始发送消息
        ps.println(&quot;我是客户端，我想约你吃小龙虾！！！&quot;);
        ps.flush();
    &#125;
&#125;
</code></pre>
<h3 id="服务端案例如下"><a href="#服务端案例如下" class="headerlink" title="服务端案例如下"></a>服务端案例如下</h3><pre><code class="java">package com.itheima._02bio01;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * 服务端
 */
public class ServerDemo &#123;
    public static void main(String[] args) throws Exception &#123;
        System.out.println(&quot;==服务器的启动==&quot;);
        // （1）注册端口
        ServerSocket serverSocket = new ServerSocket(8888);
        //（2）开始在这里暂停等待接收客户端的连接,得到一个端到端的Socket管道
        Socket socket = serverSocket.accept();
        //（3）从Socket管道中得到一个字节输入流。
        InputStream is = socket.getInputStream();
        //（4）把字节输入流包装成自己需要的流进行数据的读取。
        BufferedReader br = new BufferedReader(new InputStreamReader(is));
        //（5）读取数据
        String line ;
        while((line = br.readLine())!=null)&#123;
            System.out.println(&quot;服务端收到：&quot;+line);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>在以上通信中，服务端会一致等待客户端的消息，如果客户端没有进行消息的发送，服务端将一直进入阻塞状态。</li>
<li>同时服务端是按照行获取消息的，这意味着客户端也必须按照行进行消息的发送，否则服务端将进入等待消息的阻塞状态！</li>
</ul>
<h2 id="3-4-BIO模式下多发和多收消息"><a href="#3-4-BIO模式下多发和多收消息" class="headerlink" title="3.4 BIO模式下多发和多收消息"></a>3.4 BIO模式下多发和多收消息</h2><p>​		在1.3的案例中，<strong>只能实现客户端发送消息，服务端接收消息</strong>，并不能实现反复的收消息和反复的发消息，我们只需要在客户端案例中，加上反复按照行发送消息的逻辑即可！案例代码如下：</p>
<h3 id="客户端代码如下"><a href="#客户端代码如下" class="headerlink" title="客户端代码如下"></a>客户端代码如下</h3><pre><code class="java">package com.itheima._03bio02;

import java.io.OutputStream;
import java.io.PrintStream;
import java.net.Socket;
import java.util.Scanner;

/**
    目标: Socket网络编程。

    功能1：客户端可以反复发消息，服务端可以反复收消息

    小结：
        通信是很严格的，对方怎么发你就怎么收，对方发多少你就只能收多少！！

 */
public class ClientDemo &#123;
    public static void main(String[] args) throws Exception &#123;
        System.out.println(&quot;==客户端的启动==&quot;);
        // （1）创建一个Socket的通信管道，请求与服务端的端口连接。
        Socket socket = new Socket(&quot;127.0.0.1&quot;,8888);
        // （2）从Socket通信管道中得到一个字节输出流。
        OutputStream os = socket.getOutputStream();
        // （3）把字节流改装成自己需要的流进行数据的发送
        PrintStream ps = new PrintStream(os);
        // （4）开始发送消息
        Scanner sc = new Scanner(System.in);
        while(true)&#123;
            System.out.print(&quot;请说:&quot;);
            String msg = sc.nextLine();
            ps.println(msg);
            ps.flush();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="服务端代码如下"><a href="#服务端代码如下" class="headerlink" title="服务端代码如下"></a>服务端代码如下</h3><pre><code class="java">package com.itheima._03bio02;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * 服务端
 */
public class ServerDemo &#123;
    public static void main(String[] args) throws Exception &#123;
        String s = &quot;886&quot;;
        System.out.println(&quot;886&quot;.equals(s));
        System.out.println(&quot;==服务器的启动==&quot;);
        //（1）注册端口
        ServerSocket serverSocket = new ServerSocket(8888);
        //（2）开始在这里暂停等待接收客户端的连接,得到一个端到端的Socket管道
        Socket socket = serverSocket.accept();
        //（3）从Socket管道中得到一个字节输入流。
        InputStream is = socket.getInputStream();
        //（4）把字节输入流包装成  自己需要的流进行数据的读取。
        BufferedReader br = new BufferedReader(new InputStreamReader(is));
        //（5）读取数据
        String line ;
        while((line = br.readLine())!=null)&#123;
            System.out.println(&quot;服务端收到：&quot;+line);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li>本案例中确实可以实现客户端多发多收</li>
<li>但是服务端只能处理一个客户端的请求，因为服务端是单线程的。一次只能与一个客户端进行消息通信。</li>
</ul>
<h2 id="3-5-BIO模式下接收多个客户端"><a href="#3-5-BIO模式下接收多个客户端" class="headerlink" title="3.5 BIO模式下接收多个客户端"></a>3.5 BIO模式下接收多个客户端</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​		在上述的案例中，一个服务端只能接收一个客户端的通信请求，<strong>那么如果服务端需要处理很多个客户端的消息通信请求应该如何处理呢</strong>，此时我们就需要在服务端引入线程了，也就是说客户端每发起一个请求，服务端就创建一个新的线程来处理这个客户端的请求，这样就实现了一个客户端一个线程的模型，图解模式如下：</p>
<p><img src="/../imgs/BLOG28/image-20200615181141593.png" alt="image-20200615181141593"></p>
<h3 id="客户端案例代码如下"><a href="#客户端案例代码如下" class="headerlink" title="客户端案例代码如下"></a>客户端案例代码如下</h3><pre><code class="java">/**
    目标: Socket网络编程。

    功能1：客户端可以反复发，一个服务端可以接收无数个客户端的消息！！

    小结：
         服务器如果想要接收多个客户端，那么必须引入线程，一个客户端一个线程处理！！

 */
public class ClientDemo &#123;
    public static void main(String[] args) throws Exception &#123;
        System.out.println(&quot;==客户端的启动==&quot;);
        // （1）创建一个Socket的通信管道，请求与服务端的端口连接。
        Socket socket = new Socket(&quot;127.0.0.1&quot;,7777);
        // （2）从Socket通信管道中得到一个字节输出流。
        OutputStream os = socket.getOutputStream();
        // （3）把字节流改装成自己需要的流进行数据的发送
        PrintStream ps = new PrintStream(os);
        // （4）开始发送消息
        Scanner sc = new Scanner(System.in);
        while(true)&#123;
            System.out.print(&quot;请说:&quot;);
            String msg = sc.nextLine();
            ps.println(msg);
            ps.flush();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="服务端案例代码如下"><a href="#服务端案例代码如下" class="headerlink" title="服务端案例代码如下"></a>服务端案例代码如下</h3><pre><code class="java">/**
    服务端
 */
public class ServerDemo &#123;
    public static void main(String[] args) throws Exception &#123;
        System.out.println(&quot;==服务器的启动==&quot;);
        // （1）注册端口
        ServerSocket serverSocket = new ServerSocket(7777);
        while(true)&#123;
            //（2）开始在这里暂停等待接收客户端的连接,得到一个端到端的Socket管道
            Socket socket = serverSocket.accept();
            new ServerReadThread(socket).start();
            System.out.println(socket.getRemoteSocketAddress()+&quot;上线了！&quot;);
        &#125;
    &#125;
&#125;

class ServerReadThread extends Thread&#123;
    private Socket socket;

    public ServerReadThread(Socket socket)&#123;
        this.socket = socket;
    &#125;

    @Override
    public void run() &#123;
        try&#123;
            //（3）从Socket管道中得到一个字节输入流。
            InputStream is = socket.getInputStream();
            //（4）把字节输入流包装成自己需要的流进行数据的读取。
            BufferedReader br = new BufferedReader(new InputStreamReader(is));
            //（5）读取数据
            String line ;
            while((line = br.readLine())!=null)&#123;
                System.out.println(&quot;服务端收到：&quot;+socket.getRemoteSocketAddress()+&quot;:&quot;+line);
            &#125;
        &#125;catch (Exception e)&#123;
            System.out.println(socket.getRemoteSocketAddress()+&quot;下线了！&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul>
<li>1.每个Socket接收到，都会创建一个线程，线程的竞争、切换上下文影响性能；</li>
<li>2.每个线程都会占用栈空间和CPU资源；</li>
<li>3.并不是每个socket都进行IO操作，无意义的线程处理；  </li>
<li>4.客户端的并发访问增加时。服务端将呈现1:1的线程开销，访问量越大，系统将发生线程栈溢出，线程创建失败，最终导致进程宕机或者僵死，从而不能对外提供服务。</li>
</ul>
<h2 id="3-6-伪异步I-x2F-O编程"><a href="#3-6-伪异步I-x2F-O编程" class="headerlink" title="3.6 伪异步I&#x2F;O编程"></a>3.6 伪异步I&#x2F;O编程</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>​		在上述案例中：客户端的并发访问增加时。服务端将呈现1:1的线程开销，访问量越大，系统将发生线程栈溢出，线程创建失败，最终导致进程宕机或者僵死，从而不能对外提供服务。</p>
<p>​		接下来我们采用一个伪异步I&#x2F;O的通信框架，采用线程池和任务队列实现，当客户端接入时，将客户端的Socket封装成一个Task(该任务实现java.lang.Runnable线程任务接口)交给后端的线程池中进行处理。JDK的线程池维护一个消息队列和N个活跃的线程，对消息队列中Socket任务进行处理，由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。</p>
<p>​		图示如下:</p>
<p><img src="/../imgs/BLOG28/image-20200619085953166.png" alt="image-20200619085953166"></p>
<h3 id="客户端源码分析"><a href="#客户端源码分析" class="headerlink" title="客户端源码分析"></a>客户端源码分析</h3><pre><code class="java">public class Client &#123;
   public static void main(String[] args) &#123;
      try &#123;
         // 1.简历一个与服务端的Socket对象：套接字
         Socket socket = new Socket(&quot;127.0.0.1&quot;, 9999);
         // 2.从socket管道中获取一个输出流，写数据给服务端 
         OutputStream os = socket.getOutputStream() ;
         // 3.把输出流包装成一个打印流 
         PrintWriter pw = new PrintWriter(os);
         // 4.反复接收用户的输入 
         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
         String line = null ;
         while((line = br.readLine()) != null)&#123;
            pw.println(line);
            pw.flush();
         &#125;
      &#125; catch (Exception e) &#123;
         e.printStackTrace();
      &#125;
   &#125;
&#125;
</code></pre>
<h3 id="线程池处理类"><a href="#线程池处理类" class="headerlink" title="线程池处理类"></a>线程池处理类</h3><pre><code class="java">// 线程池处理类
public class HandlerSocketThreadPool &#123;
   
   // 线程池 
   private ExecutorService executor;
   
   public HandlerSocketThreadPool(int maxPoolSize, int queueSize)&#123;
      
      this.executor = new ThreadPoolExecutor(
            3, // 8
            maxPoolSize,  
            120L, 
            TimeUnit.SECONDS,
            new ArrayBlockingQueue&lt;Runnable&gt;(queueSize) );
   &#125;
   
   public void execute(Runnable task)&#123;
      this.executor.execute(task);
   &#125;
&#125;
</code></pre>
<h3 id="服务端源码分析"><a href="#服务端源码分析" class="headerlink" title="服务端源码分析"></a>服务端源码分析</h3><pre><code class="java">public class Server &#123;
   public static void main(String[] args) &#123;
      try &#123;
         System.out.println(&quot;----------服务端启动成功------------&quot;);
         ServerSocket ss = new ServerSocket(9999);

         // 一个服务端只需要对应一个线程池
         HandlerSocketThreadPool handlerSocketThreadPool =
               new HandlerSocketThreadPool(3, 1000);

         // 客户端可能有很多个
         while(true)&#123;
            Socket socket = ss.accept() ; // 阻塞式的！
            System.out.println(&quot;有人上线了！！&quot;);
            // 每次收到一个客户端的socket请求，都需要为这个客户端分配一个
            // 独立的线程 专门负责对这个客户端的通信！！
            handlerSocketThreadPool.execute(new ReaderClientRunnable(socket));
         &#125;

      &#125; catch (Exception e) &#123;
         e.printStackTrace();
      &#125;
   &#125;

&#125;
class ReaderClientRunnable implements Runnable&#123;

   private Socket socket ;

   public ReaderClientRunnable(Socket socket) &#123;
      this.socket = socket;
   &#125;

   @Override
   public void run() &#123;
      try &#123;
         // 读取一行数据
         InputStream is = socket.getInputStream() ;
         // 转成一个缓冲字符流
         Reader fr = new InputStreamReader(is);
         BufferedReader br = new BufferedReader(fr);
         // 一行一行的读取数据
         String line = null ;
         while((line = br.readLine())!=null)&#123; // 阻塞式的！！
            System.out.println(&quot;服务端收到了数据：&quot;+line);
         &#125;
      &#125; catch (Exception e) &#123;
         System.out.println(&quot;有人下线了&quot;);
      &#125;

   &#125;
&#125;
</code></pre>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ul>
<li>伪异步io采用了线程池实现，因此避免了为每个请求创建一个独立线程造成线程资源耗尽的问题，但由于底层依然是采用的同步阻塞模型，因此无法从根本上解决问题。</li>
<li>如果单个消息处理的缓慢，或者服务器线程池中的全部线程都被阻塞，那么后续socket的i&#x2F;o消息都将在队列中排队。新的Socket请求将被拒绝，客户端会发生大量连接超时。</li>
</ul>
<h2 id="3-7-基于BIO形式下的文件上传"><a href="#3-7-基于BIO形式下的文件上传" class="headerlink" title="3.7 基于BIO形式下的文件上传"></a>3.7 基于BIO形式下的文件上传</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>支持任意类型文件形式的上传。</p>
<h3 id="客户端开发"><a href="#客户端开发" class="headerlink" title="客户端开发"></a>客户端开发</h3><pre><code class="java">package com.itheima.file;

import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.InputStream;
import java.net.Socket;

/**
    目标：实现客户端上传任意类型的文件数据给服务端保存起来。

 */
public class Client &#123;
    public static void main(String[] args) &#123;
        try(
                InputStream is = new FileInputStream(&quot;C:\\Users\\dlei\\Desktop\\BIO,NIO,AIO\\文件\\java.png&quot;);
        )&#123;
            //  1、请求与服务端的Socket链接
            Socket socket = new Socket(&quot;127.0.0.1&quot; , 8888);
            //  2、把字节输出流包装成一个数据输出流
            DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
            //  3、先发送上传文件的后缀给服务端
            dos.writeUTF(&quot;.png&quot;);
            //  4、把文件数据发送给服务端进行接收
            byte[] buffer = new byte[1024];
            int len;
            while((len = is.read(buffer)) &gt; 0 )&#123;
                dos.write(buffer , 0 , len);
            &#125;
            dos.flush();
            Thread.sleep(10000);
        &#125;catch (Exception e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="服务端开发"><a href="#服务端开发" class="headerlink" title="服务端开发"></a>服务端开发</h3><pre><code class="java">package com.itheima.file;

import java.net.ServerSocket;
import java.net.Socket;

/**
    目标：服务端开发，可以实现接收客户端的任意类型文件，并保存到服务端磁盘。
 */
public class Server &#123;
    public static void main(String[] args) &#123;
        try&#123;
            ServerSocket ss = new ServerSocket(8888);
            while (true)&#123;
                Socket socket = ss.accept();
                // 交给一个独立的线程来处理与这个客户端的文件通信需求。
                new ServerReaderThread(socket).start();
            &#125;
        &#125;catch (Exception e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">package com.itheima.file;

import java.io.DataInputStream;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.util.UUID;

public class ServerReaderThread extends Thread &#123;
    private Socket socket;
    public ServerReaderThread(Socket socket)&#123;
        this.socket = socket;
    &#125;
    @Override
    public void run() &#123;
        try&#123;
            // 1、得到一个数据输入流读取客户端发送过来的数据
            DataInputStream dis = new DataInputStream(socket.getInputStream());
            // 2、读取客户端发送过来的文件类型
            String suffix = dis.readUTF();
            System.out.println(&quot;服务端已经成功接收到了文件类型：&quot; + suffix);
            // 3、定义一个字节输出管道负责把客户端发来的文件数据写出去
            OutputStream os = new FileOutputStream(&quot;C:\\Users\\dlei\\Desktop\\BIO,NIO,AIO\\文件\\server\\&quot;+
                    UUID.randomUUID().toString()+suffix);
            // 4、从数据输入流中读取文件数据，写出到字节输出流中去
            byte[] buffer = new byte[1024];
            int len;
            while((len = dis.read(buffer)) &gt; 0)&#123;
                os.write(buffer,0, len);
            &#125;
            os.close();
            System.out.println(&quot;服务端接收文件保存成功！&quot;);

        &#125;catch (Exception e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>客户端怎么发，服务端就怎么接收</p>
<h2 id="3-9-Java-BIO模式下的端口转发思想"><a href="#3-9-Java-BIO模式下的端口转发思想" class="headerlink" title="3.9 Java BIO模式下的端口转发思想"></a>3.9 Java BIO模式下的端口转发思想</h2><p>需求：需要实现一个客户端的消息可以发送给所有的客户端去接收。（群聊实现）</p>
<p><img src="/../imgs/BLOG28/image-20200619123304241.png" alt="image-20200619123304241"></p>
<h3 id="客户端开发-1"><a href="#客户端开发-1" class="headerlink" title="客户端开发"></a>客户端开发</h3><pre><code class="java">package com.itheima.file;

import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.InputStream;
import java.net.Socket;

/**
    目标：实现客户端上传任意类型的文件数据给服务端保存起来。

 */
public class Client &#123;
    public static void main(String[] args) &#123;
        try(
                InputStream is = new FileInputStream(&quot;C:\\Users\\dlei\\Desktop\\BIO,NIO,AIO\\文件\\java.png&quot;);
        )&#123;
            //  1、请求与服务端的Socket链接
            Socket socket = new Socket(&quot;127.0.0.1&quot; , 8888);
            //  2、把字节输出流包装成一个数据输出流
            DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
            //  3、先发送上传文件的后缀给服务端
            dos.writeUTF(&quot;.png&quot;);
            //  4、把文件数据发送给服务端进行接收
            byte[] buffer = new byte[1024];
            int len;
            while((len = is.read(buffer)) &gt; 0 )&#123;
                dos.write(buffer , 0 , len);
            &#125;
            dos.flush();
            Thread.sleep(10000);
        &#125;catch (Exception e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h3><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><h2 id="3-10-基于BIO模式下即时通信"><a href="#3-10-基于BIO模式下即时通信" class="headerlink" title="3.10 基于BIO模式下即时通信"></a>3.10 基于BIO模式下即时通信</h2><p>基于BIO模式下的即时通信，我们需要解决客户端到客户端的通信，也就是需要实现客户端与客户端的端口消息转发逻辑。</p>
<h3 id="项目功能演示"><a href="#项目功能演示" class="headerlink" title="项目功能演示"></a>项目功能演示</h3><h4 id="项目案例说明"><a href="#项目案例说明" class="headerlink" title="项目案例说明"></a>项目案例说明</h4><p>本项目案例为即时通信的软件项目，适合基础加强的大案例，具备综合性。学习本项目案例至少需要具备如下Java SE技术点:</p>
<ul>
<li><ol>
<li>Java 面向对象设计，语法设计。</li>
</ol>
</li>
<li><ol start="2">
<li>多线程技术。</li>
</ol>
</li>
<li><ol start="3">
<li>IO流技术。</li>
</ol>
</li>
<li><ol start="4">
<li>网络通信相关技术。</li>
</ol>
</li>
<li><ol start="5">
<li>集合框架。</li>
</ol>
</li>
<li><ol start="6">
<li>项目开发思维。</li>
</ol>
</li>
<li><ol start="7">
<li>Java 常用 api 使用。</li>
</ol>
</li>
</ul>
<p>​    ……</p>
<h4 id="功能清单简单说明："><a href="#功能清单简单说明：" class="headerlink" title="功能清单简单说明："></a>功能清单简单说明：</h4><p><strong>1.客户端登陆功能</strong></p>
<ul>
<li>可以启动客户端进行登录，客户端登陆只需要输入用户名和服务端ip地址即可。</li>
</ul>
<p><strong>2.在线人数实时更新。</strong></p>
<ul>
<li>客户端用户户登陆以后，需要同步更新所有客户端的联系人信息栏。</li>
</ul>
<p><strong>3.离线人数更新</strong></p>
<ul>
<li>检测到有客户端下线后，需要同步更新所有客户端的联系人信息栏。</li>
</ul>
<p><strong>4.群聊</strong></p>
<ul>
<li>任意一个客户端的消息，可以推送给当前所有客户端接收。</li>
</ul>
<p><strong>5.私聊</strong></p>
<ul>
<li>可以选择某个员工，点击私聊按钮，然后发出的消息可以被该客户端单独接收。</li>
</ul>
<p><strong>6.@消息</strong></p>
<ul>
<li>可以选择某个员工，然后发出的消息可以@该用户，但是其他所有人都能</li>
</ul>
<p><strong>7.消息用户和消息时间点</strong></p>
<ul>
<li>服务端可以实时记录该用户的消息时间点，然后进行消息的多路转发或者选择。</li>
</ul>
<h4 id="项目启动与演示"><a href="#项目启动与演示" class="headerlink" title="项目启动与演示"></a>项目启动与演示</h4><p><strong>项目代码结构演示。</strong></p>
<p><img src="/../imgs/BLOG28/image-20200223212913139.png" alt="image-20200223212913139"></p>
<p><strong>项目启动步骤：</strong></p>
<ul>
<li><p>1.首先需要启动服务端，点击ServerChat类直接右键启动，显示服务端启动成功！</p>
</li>
<li><p>2.其次，点击客户端类ClientChat类，在弹出的方框中输入服务端的ip和当前客户端的昵称</p>
<p><img src="/../imgs/BLOG28/image-20200223214123052.png" alt="image-20200223214123052"></p>
</li>
<li><p>3.登陆进入后的聊天界面如下，即可进行相关操作。</p>
<ul>
<li>如果直接点击发送，默认发送群聊消息</li>
</ul>
</li>
<li><p>如果选中右侧在线列表某个用户，默认发送@消息</p>
<ul>
<li>如果选中右侧在线列表某个用户，然后选择右下侧私聊按钮默，认发送私聊消息。</li>
</ul>
<p><img src="/../imgs/BLOG28/image-20200223214143465.png" alt="image-20200223214143465"></p>
<p><img src="/../imgs/BLOG28/image-20200223214155975.png" alt="image-20200223214155975"></p>
</li>
</ul>
<h4 id="技术选型分析"><a href="#技术选型分析" class="headerlink" title="技术选型分析"></a>技术选型分析</h4><p>本项目案例涉及到Java基础加强的案例，具体涉及到的技术点如下：</p>
<ul>
<li><ol>
<li>Java 面向对象设计，语法设计。</li>
</ol>
</li>
<li><ol start="2">
<li>多线程技术。</li>
</ol>
</li>
<li><ol start="3">
<li>IO流技术。</li>
</ol>
</li>
<li><ol start="4">
<li>网络通信相关技术。</li>
</ol>
</li>
<li><ol start="5">
<li>集合框架。</li>
</ol>
</li>
<li><ol start="6">
<li>项目开发思维。</li>
</ol>
</li>
<li><ol start="7">
<li>Java 常用 api 使用。</li>
</ol>
<p>……</p>
</li>
</ul>
<h3 id="服务端设计"><a href="#服务端设计" class="headerlink" title="服务端设计"></a>服务端设计</h3><h4 id="服务端接收多个客户端逻辑"><a href="#服务端接收多个客户端逻辑" class="headerlink" title="服务端接收多个客户端逻辑"></a>服务端接收多个客户端逻辑</h4><h5 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h5><p>服务端需要接收多个客户端的接入。</p>
<h5 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h5><ul>
<li>1.服务端需要接收多个客户端，目前我们采取的策略是一个客户端对应一个服务端线程。</li>
<li>2.服务端除了要注册端口以外，还需要为每个客户端分配一个独立线程处理与之通信。</li>
</ul>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><ul>
<li>服务端主体代码，主要进行端口注册，和接收客户端，分配线程处理该客户端请求</li>
</ul>
<pre><code class="java">public class ServerChat &#123;
    
    /** 定义一个集合存放所有在线的socket  */
    public static Map&lt;Socket, String&gt; onLineSockets = new HashMap&lt;&gt;();

   public static void main(String[] args) &#123;
      try &#123;
         /** 1.注册端口   */
         ServerSocket serverSocket = new ServerSocket(Constants.PORT);

         /** 2.循环一直等待所有可能的客户端连接 */
         while(true)&#123;
            Socket socket = serverSocket.accept();
            /**3. 把客户端的socket管道单独配置一个线程来处理 */
            new ServerReader(socket).start();
         &#125;
      &#125; catch (Exception e) &#123;
         e.printStackTrace();
      &#125;
   &#125;
&#125;
</code></pre>
<ul>
<li>服务端分配的独立线程类负责处理该客户端Socket的管道请求。</li>
</ul>
<pre><code class="java">class ServerReader extends Thread &#123;
   private Socket socket;
   public ServerReader(Socket socket) &#123;
      this.socket = socket;
   &#125;
   @Override
   public void run() &#123;
      try &#123;
       
      &#125; catch (Exception e) &#123;
            e.printStackTrace();
      &#125;
   &#125;
&#125;
</code></pre>
<p>常量包负责做端口配置</p>
<pre><code class="java">public class Constants &#123;
   /** 常量 */
   public static final int PORT = 7778 ;

&#125;
</code></pre>
<h5 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h5><p>​	本节实现了服务端可以接收多个客户端请求。</p>
<h4 id="服务端接收登陆消息以及监测离线"><a href="#服务端接收登陆消息以及监测离线" class="headerlink" title="服务端接收登陆消息以及监测离线"></a>服务端接收登陆消息以及监测离线</h4><h5 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h5><p>在上节我们实现了服务端可以接收多个客户端，然后服务端可以接收多个客户端连接，接下来我们要接收客户端的登陆消息。</p>
<h5 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h5><ul>
<li>需要在服务端处理客户端的线程的登陆消息。</li>
<li>需要注意的是，服务端需要接收客户端的消息可能有很多种。<ul>
<li>分别是登陆消息，群聊消息，私聊消息 和@消息。</li>
<li>这里需要约定如果客户端发送消息之前需要先发送消息的类型，类型我们使用信号值标志（1，2，3）。<ul>
<li>1代表接收的是登陆消息</li>
<li>2代表群发| @消息</li>
<li>3代表了私聊消息</li>
</ul>
</li>
</ul>
</li>
<li>服务端的线程中有异常校验机制，一旦发现客户端下线会在异常机制中处理，然后移除当前客户端用户，把最新的用户列表发回给全部客户端进行在线人数更新。</li>
</ul>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><pre><code class="java">public class ServerReader extends Thread &#123;
    private Socket socket;
    public ServerReader(Socket socket) &#123;
        this.socket = socket;
    &#125;

    @Override
    public void run() &#123;
        DataInputStream dis = null;
        try &#123;
            dis = new DataInputStream(socket.getInputStream());
            /** 1.循环一直等待客户端的消息 */
            while(true)&#123;
                /** 2.读取当前的消息类型 ：登录,群发,私聊 , @消息 */
                int flag = dis.readInt();
                if(flag == 1)&#123;
                    /** 先将当前登录的客户端socket存到在线人数的socket集合中   */
                    String name = dis.readUTF() ;
                    System.out.println(name+&quot;----&gt;&quot;+socket.getRemoteSocketAddress());
                    ServerChat.onLineSockets.put(socket, name);
                &#125;
                writeMsg(flag,dis);
            &#125;
        &#125; catch (Exception e) &#123;
            System.out.println(&quot;--有人下线了--&quot;);
            // 从在线人数中将当前socket移出去  
            ServerChat.onLineSockets.remove(socket);
            try &#123;
                // 从新更新在线人数并发给所有客户端 
                writeMsg(1,dis);
            &#125; catch (Exception e1) &#123;
                e1.printStackTrace();
            &#125;
        &#125;

    &#125;

    private void writeMsg(int flag, DataInputStream dis) throws Exception &#123;
        // DataOutputStream dos = new DataOutputStream(socket.getOutputStream()); 
        // 定义一个变量存放最终的消息形式 
        String msg = null ;
        if(flag == 1)&#123;
            /** 读取所有在线人数发给所有客户端去更新自己的在线人数列表 */
            /** onlineNames = [波仔,zhangsan,波妞]*/
            StringBuilder rs = new StringBuilder();
            Collection&lt;String&gt; onlineNames = ServerChat.onLineSockets.values();
            // 判断是否存在在线人数 
            if(onlineNames != null &amp;&amp; onlineNames.size() &gt; 0)&#123;
                for(String name : onlineNames)&#123;
                    rs.append(name+ Constants.SPILIT);
                &#125;
                // 波仔003197♣♣㏘♣④④♣zhangsan003197♣♣㏘♣④④♣波妞003197♣♣㏘♣④④♣
                // 去掉最后的一个分隔符 
                msg = rs.substring(0, rs.lastIndexOf(Constants.SPILIT));

                /** 将消息发送给所有的客户端 */
                sendMsgToAll(flag,msg);
            &#125;
        &#125;else if(flag == 2 || flag == 3)&#123;
            
            &#125;
        &#125;
    &#125;
    
    private void sendMsgToAll(int flag, String msg) throws Exception &#123;
        // 拿到所有的在线socket管道 给这些管道写出消息
        Set&lt;Socket&gt; allOnLineSockets = ServerChat.onLineSockets.keySet();
        for(Socket sk :  allOnLineSockets)&#123;
            DataOutputStream dos = new DataOutputStream(sk.getOutputStream());
            dos.writeInt(flag); // 消息类型
            dos.writeUTF(msg);
            dos.flush();
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h5><ul>
<li>此处实现了接收客户端的登陆消息，然后提取当前在线的全部的用户名称和当前登陆的用户名称发送给全部在线用户更新自己的在线人数列表。</li>
</ul>
<h4 id="服务端接收群聊消息"><a href="#服务端接收群聊消息" class="headerlink" title="服务端接收群聊消息"></a>服务端接收群聊消息</h4><h5 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h5><p>在上节实现了接收客户端的登陆消息，然后提取当前在线的全部的用户名称和当前登陆的用户名称发送给全部在线用户更新自己的在线人数列表。接下来要接收客户端发来的群聊消息推送给当前在线的所有客户端</p>
<h5 id="实现步骤-2"><a href="#实现步骤-2" class="headerlink" title="实现步骤"></a>实现步骤</h5><ul>
<li>接下来要接收客户端发来的群聊消息。</li>
<li>需要注意的是，服务端需要接收客户端的消息可能有很多种。<ul>
<li>分别是登陆消息，群聊消息，私聊消息 和@消息。</li>
<li>这里需要约定如果客户端发送消息之前需要先发送消息的类型，类型我们使用信号值标志（1，2，3）。<ul>
<li>1代表接收的是登陆消息</li>
<li>2代表群发| @消息</li>
<li>3代表了私聊消息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><pre><code class="java">public class ServerReader extends Thread &#123;
    private Socket socket;
    public ServerReader(Socket socket) &#123;
        this.socket = socket;
    &#125;

    @Override
    public void run() &#123;
        DataInputStream dis = null;
        try &#123;
            dis = new DataInputStream(socket.getInputStream());
            /** 1.循环一直等待客户端的消息 */
            while(true)&#123;
                /** 2.读取当前的消息类型 ：登录,群发,私聊 , @消息 */
                int flag = dis.readInt();
                if(flag == 1)&#123;
                    /** 先将当前登录的客户端socket存到在线人数的socket集合中   */
                    String name = dis.readUTF() ;
                    System.out.println(name+&quot;----&gt;&quot;+socket.getRemoteSocketAddress());
                    ServerChat.onLineSockets.put(socket, name);
                &#125;
                writeMsg(flag,dis);
            &#125;
        &#125; catch (Exception e) &#123;
            System.out.println(&quot;--有人下线了--&quot;);
            // 从在线人数中将当前socket移出去  
            ServerChat.onLineSockets.remove(socket);
            try &#123;
                // 从新更新在线人数并发给所有客户端 
                writeMsg(1,dis);
            &#125; catch (Exception e1) &#123;
                e1.printStackTrace();
            &#125;
        &#125;

    &#125;

    private void writeMsg(int flag, DataInputStream dis) throws Exception &#123;
        // DataOutputStream dos = new DataOutputStream(socket.getOutputStream()); 
        // 定义一个变量存放最终的消息形式 
        String msg = null ;
        if(flag == 1)&#123;
            /** 读取所有在线人数发给所有客户端去更新自己的在线人数列表 */
            /** onlineNames = [波仔,zhangsan,波妞]*/
            StringBuilder rs = new StringBuilder();
            Collection&lt;String&gt; onlineNames = ServerChat.onLineSockets.values();
            // 判断是否存在在线人数 
            if(onlineNames != null &amp;&amp; onlineNames.size() &gt; 0)&#123;
                for(String name : onlineNames)&#123;
                    rs.append(name+ Constants.SPILIT);
                &#125;
                // 波仔003197♣♣㏘♣④④♣zhangsan003197♣♣㏘♣④④♣波妞003197♣♣㏘♣④④♣
                // 去掉最后的一个分隔符 
                msg = rs.substring(0, rs.lastIndexOf(Constants.SPILIT));

                /** 将消息发送给所有的客户端 */
                sendMsgToAll(flag,msg);
            &#125;
        &#125;else if(flag == 2 || flag == 3)&#123;
            // 读到消息  群发的 或者 @消息
            String newMsg = dis.readUTF() ; // 消息
            // 得到发件人 
            String sendName = ServerChat.onLineSockets.get(socket);
    
            // 内容
            StringBuilder msgFinal = new StringBuilder();
            // 时间  
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss EEE&quot;);
            if(flag == 2)&#123;
                msgFinal.append(sendName).append(&quot;  &quot;).append(sdf.format(System.currentTimeMillis())).append(&quot;\r\n&quot;);
                msgFinal.append(&quot;    &quot;).append(newMsg).append(&quot;\r\n&quot;);
                sendMsgToAll(flag,msgFinal.toString());
            &#125;else if(flag == 3)&#123;
    
            &#125;
        &#125;
    &#125;
    

    private void sendMsgToAll(int flag, String msg) throws Exception &#123;
        // 拿到所有的在线socket管道 给这些管道写出消息
        Set&lt;Socket&gt; allOnLineSockets = ServerChat.onLineSockets.keySet();
        for(Socket sk :  allOnLineSockets)&#123;
            DataOutputStream dos = new DataOutputStream(sk.getOutputStream());
            dos.writeInt(flag); // 消息类型
            dos.writeUTF(msg);
            dos.flush();
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h5><ul>
<li>此处根据消息的类型判断为群聊消息，然后把群聊消息推送给当前在线的所有客户端。</li>
</ul>
<h4 id="服务端接收私聊消息"><a href="#服务端接收私聊消息" class="headerlink" title="服务端接收私聊消息"></a>服务端接收私聊消息</h4><h5 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h5><p>在上节我们接收了客户端发来的群聊消息推送给当前在线的所有客户端，接下来要解决私聊消息的推送逻辑</p>
<h5 id="实现步骤-3"><a href="#实现步骤-3" class="headerlink" title="实现步骤"></a>实现步骤</h5><ul>
<li>解决私聊消息的推送逻辑，私聊消息需要知道推送给某个具体的客户端</li>
<li>我们可以接收到客户端发来的私聊用户名称，根据用户名称定位该用户的Socket管道，然后单独推送消息给该Socket管道。</li>
<li>需要注意的是，服务端需要接收客户端的消息可能有很多种。<ul>
<li>分别是登陆消息，群聊消息，私聊消息 和@消息。</li>
<li>这里需要约定如果客户端发送消息之前需要先发送消息的类型，类型我们使用信号值标志（1，2，3）。<ul>
<li>1代表接收的是登陆消息</li>
<li>2代表群发| @消息</li>
<li>3代表了私聊消息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h5><pre><code class="java">public class ServerReader extends Thread &#123;
    private Socket socket;
    public ServerReader(Socket socket) &#123;
        this.socket = socket;
    &#125;

    @Override
    public void run() &#123;
        DataInputStream dis = null;
        try &#123;
            dis = new DataInputStream(socket.getInputStream());
            /** 1.循环一直等待客户端的消息 */
            while(true)&#123;
                /** 2.读取当前的消息类型 ：登录,群发,私聊 , @消息 */
                int flag = dis.readInt();
                if(flag == 1)&#123;
                    /** 先将当前登录的客户端socket存到在线人数的socket集合中   */
                    String name = dis.readUTF() ;
                    System.out.println(name+&quot;----&gt;&quot;+socket.getRemoteSocketAddress());
                    ServerChat.onLineSockets.put(socket, name);
                &#125;
                writeMsg(flag,dis);
            &#125;
        &#125; catch (Exception e) &#123;
            System.out.println(&quot;--有人下线了--&quot;);
            // 从在线人数中将当前socket移出去  
            ServerChat.onLineSockets.remove(socket);
            try &#123;
                // 从新更新在线人数并发给所有客户端 
                writeMsg(1,dis);
            &#125; catch (Exception e1) &#123;
                e1.printStackTrace();
            &#125;
        &#125;

    &#125;

    private void writeMsg(int flag, DataInputStream dis) throws Exception &#123;
        // DataOutputStream dos = new DataOutputStream(socket.getOutputStream()); 
        // 定义一个变量存放最终的消息形式 
        String msg = null ;
        if(flag == 1)&#123;
            /** 读取所有在线人数发给所有客户端去更新自己的在线人数列表 */
            /** onlineNames = [波仔,zhangsan,波妞]*/
            StringBuilder rs = new StringBuilder();
            Collection&lt;String&gt; onlineNames = ServerChat.onLineSockets.values();
            // 判断是否存在在线人数 
            if(onlineNames != null &amp;&amp; onlineNames.size() &gt; 0)&#123;
                for(String name : onlineNames)&#123;
                    rs.append(name+ Constants.SPILIT);
                &#125;
                // 波仔003197♣♣㏘♣④④♣zhangsan003197♣♣㏘♣④④♣波妞003197♣♣㏘♣④④♣
                // 去掉最后的一个分隔符 
                msg = rs.substring(0, rs.lastIndexOf(Constants.SPILIT));

                /** 将消息发送给所有的客户端 */
                sendMsgToAll(flag,msg);
            &#125;
        &#125;else if(flag == 2 || flag == 3)&#123;
            // 读到消息  群发的 或者 @消息
            String newMsg = dis.readUTF() ; // 消息
            // 得到发件人 
            String sendName = ServerChat.onLineSockets.get(socket);
    
            // 内容
            StringBuilder msgFinal = new StringBuilder();
            // 时间  
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss EEE&quot;);
            if(flag == 2)&#123;
                msgFinal.append(sendName).append(&quot;  &quot;).append(sdf.format(System.currentTimeMillis())).append(&quot;\r\n&quot;);
                msgFinal.append(&quot;    &quot;).append(newMsg).append(&quot;\r\n&quot;);
                sendMsgToAll(flag,msgFinal.toString());
            &#125;else if(flag == 3)&#123;
            msgFinal.append(sendName).append(&quot;  &quot;).append(sdf.format(System.currentTimeMillis())).append(&quot;对您私发\r\n&quot;);
                msgFinal.append(&quot;    &quot;).append(newMsg).append(&quot;\r\n&quot;);
                // 私发 
                // 得到给谁私发 
                String destName = dis.readUTF();
                sendMsgToOne(destName,msgFinal.toString());
            &#125;
        &#125;
    &#125;
    /**
     * @param destName 对谁私发 
     * @param msg 发的消息内容 
     * @throws Exception
     */
    private void sendMsgToOne(String destName, String msg) throws Exception &#123;
        // 拿到所有的在线socket管道 给这些管道写出消息
        Set&lt;Socket&gt; allOnLineSockets = ServerChat.onLineSockets.keySet();
        for(Socket sk :  allOnLineSockets)&#123;
            // 得到当前需要私发的socket 
            // 只对这个名字对应的socket私发消息
            if(ServerChat.onLineSockets.get(sk).trim().equals(destName))&#123;
                DataOutputStream dos = new DataOutputStream(sk.getOutputStream());
                dos.writeInt(2); // 消息类型
                dos.writeUTF(msg);
                dos.flush();
            &#125;
        &#125;

    &#125;
    

    private void sendMsgToAll(int flag, String msg) throws Exception &#123;
        // 拿到所有的在线socket管道 给这些管道写出消息
        Set&lt;Socket&gt; allOnLineSockets = ServerChat.onLineSockets.keySet();
        for(Socket sk :  allOnLineSockets)&#123;
            DataOutputStream dos = new DataOutputStream(sk.getOutputStream());
            dos.writeInt(flag); // 消息类型
            dos.writeUTF(msg);
            dos.flush();
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h5><ul>
<li>本节我们解决了私聊消息的推送逻辑，私聊消息需要知道推送给某个具体的客户端Socket管道</li>
<li>我们可以接收到客户端发来的私聊用户名称，根据用户名称定位该用户的Socket管道，然后单独推送消息给该Socket管道。</li>
</ul>
<h3 id="客户端设计"><a href="#客户端设计" class="headerlink" title="客户端设计"></a>客户端设计</h3><h4 id="启动客户端界面-登陆，刷新在线"><a href="#启动客户端界面-登陆，刷新在线" class="headerlink" title="启动客户端界面 ,登陆，刷新在线"></a>启动客户端界面 ,登陆，刷新在线</h4><h5 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h5><p><strong>启动客户端界面</strong>，登陆，刷新在线人数列表</p>
<h5 id="实现步骤-4"><a href="#实现步骤-4" class="headerlink" title="实现步骤"></a>实现步骤</h5><ul>
<li>客户端界面主要是GUI设计，主体页面分为登陆界面和聊天窗口，以及在线用户列表。</li>
<li>GUI界面读者可以自行复制使用。</li>
<li>登陆输入服务端ip和用户名后，要请求与服务端的登陆，然后立即为当前客户端分配一个读线程处理客户端的读数据消息。因为客户端可能随时会接收到服务端那边转发过来的各种即时消息信息。</li>
<li>客户端登陆完成，服务端收到登陆的用户名后，会立即发来最新的用户列表给客户端更新。</li>
</ul>
<h5 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h5><p><strong>客户端主体代码：</strong></p>
<pre><code class="java">public class ClientChat implements ActionListener &#123;
   /** 1.设计界面  */
   private JFrame win = new JFrame();
   /** 2.消息内容框架 */
   public JTextArea smsContent =new JTextArea(23 , 50);
   /** 3.发送消息的框  */
   private JTextArea smsSend = new JTextArea(4,40);
   /** 4.在线人数的区域  */
   /** 存放人的数据 */
   /** 展示在线人数的窗口 */
   public JList&lt;String&gt; onLineUsers = new JList&lt;&gt;();

   // 是否私聊按钮
   private JCheckBox isPrivateBn = new JCheckBox(&quot;私聊&quot;);
   // 消息按钮
   private JButton sendBn  = new JButton(&quot;发送&quot;);

   // 登录界面
   private JFrame loginView;

   private JTextField ipEt , nameEt , idEt;

   private Socket socket ;

   public static void main(String[] args) &#123;
      new ClientChat().initView();

   &#125;

   private void initView() &#123;
      /** 初始化聊天窗口的界面 */
      win.setSize(650, 600);

      /** 展示登录界面  */
      displayLoginView();

      /** 展示聊天界面 */
      //displayChatView();

   &#125;

   private void displayChatView() &#123;

      JPanel bottomPanel = new JPanel(new BorderLayout());
      //-----------------------------------------------
      // 将消息框和按钮 添加到窗口的底端
      win.add(bottomPanel, BorderLayout.SOUTH);
      bottomPanel.add(smsSend);
      JPanel btns = new JPanel(new FlowLayout(FlowLayout.LEFT));
      btns.add(sendBn);
      btns.add(isPrivateBn);
      bottomPanel.add(btns, BorderLayout.EAST);
      //-----------------------------------------------
      // 给发送消息按钮绑定点击事件监听器
      // 将展示消息区centerPanel添加到窗口的中间
      smsContent.setBackground(new Color(0xdd,0xdd,0xdd));
      // 让展示消息区可以滚动。
      win.add(new JScrollPane(smsContent), BorderLayout.CENTER);
      smsContent.setEditable(false);
      //-----------------------------------------------
      // 用户列表和是否私聊放到窗口的最右边
      Box rightBox = new Box(BoxLayout.Y_AXIS);
      onLineUsers.setFixedCellWidth(120);
      onLineUsers.setVisibleRowCount(13);
      rightBox.add(new JScrollPane(onLineUsers));
      win.add(rightBox, BorderLayout.EAST);
      //-----------------------------------------------
      // 关闭窗口退出当前程序
      win.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      win.pack();  // swing 加上这句 就可以拥有关闭窗口的功能
      /** 设置窗口居中,显示出来  */
      setWindowCenter(win,650,600,true);
      // 发送按钮绑定点击事件
      sendBn.addActionListener(this);
   &#125;

   private void displayLoginView()&#123;

      /** 先让用户进行登录
       *  服务端ip
       *  用户名
       *  id
       *  */
      /** 显示一个qq的登录框     */
      loginView = new JFrame(&quot;登录&quot;);
      loginView.setLayout(new GridLayout(3, 1));
      loginView.setSize(400, 230);

      JPanel ip = new JPanel();
      JLabel label = new JLabel(&quot;   IP:&quot;);
      ip.add(label);
      ipEt = new JTextField(20);
      ip.add(ipEt);
      loginView.add(ip);

      JPanel name = new JPanel();
      JLabel label1 = new JLabel(&quot;姓名:&quot;);
      name.add(label1);
      nameEt = new JTextField(20);
      name.add(nameEt);
      loginView.add(name);

      JPanel btnView = new JPanel();
      JButton login = new JButton(&quot;登陆&quot;);
      btnView.add(login);
      JButton cancle = new JButton(&quot;取消&quot;);
      btnView.add(cancle);
      loginView.add(btnView);
      // 关闭窗口退出当前程序
      loginView.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      setWindowCenter(loginView,400,260,true);

      /** 给登录和取消绑定点击事件 */
      login.addActionListener(this);
      cancle.addActionListener(this);

   &#125;

   private static void setWindowCenter(JFrame frame, int width , int height, boolean flag) &#123;
      /** 得到所在系统所在屏幕的宽高 */
      Dimension ds = frame.getToolkit().getScreenSize();

      /** 拿到电脑的宽 */
      int width1 = ds.width;
      /** 高 */
      int height1 = ds.height ;

      System.out.println(width1 +&quot;*&quot; + height1);
      /** 设置窗口的左上角坐标 */
      frame.setLocation(width1/2 - width/2, height1/2 -height/2);
      frame.setVisible(flag);
   &#125;

   @Override
   public void actionPerformed(ActionEvent e) &#123;
      /** 得到点击的事件源 */
      JButton btn = (JButton) e.getSource();
      switch(btn.getText())&#123;
         case &quot;登陆&quot;:
            String ip = ipEt.getText().toString();
            String name = nameEt.getText().toString();
            // 校验参数是否为空
            // 错误提示
            String msg = &quot;&quot; ;
            // 12.1.2.0
            // \d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\
            if(ip==null || !ip.matches(&quot;\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;&quot;))&#123;
               msg = &quot;请输入合法的服务端ip地址&quot;;
            &#125;else if(name==null || !name.matches(&quot;\\S&#123;1,&#125;&quot;))&#123;
               msg = &quot;姓名必须1个字符以上&quot;;
            &#125;

            if(!msg.equals(&quot;&quot;))&#123;
               /** msg有内容说明参数有为空 */
               // 参数一：弹出放到哪个窗口里面
               JOptionPane.showMessageDialog(loginView, msg);
            &#125;else&#123;
               try &#123;
                  // 参数都合法了
                  // 当前登录的用户,去服务端登陆
                  /** 先把当前用户的名称展示到界面 */
                  win.setTitle(name);
                  // 去服务端登陆连接一个socket管道
                  socket = new Socket(ip, Constants.PORT);

                  //为客户端的socket分配一个线程 专门负责收消息
                  new ClientReader(this,socket).start();

                  // 带上用户信息过去
                  DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
                  dos.writeInt(1); // 登录消息
                  dos.writeUTF(name.trim());
                  dos.flush();

                  // 关系当前窗口 弹出聊天界面
                  loginView.dispose(); // 登录窗口销毁
                  displayChatView(); // 展示了聊天窗口了


               &#125; catch (Exception e1) &#123;
                  e1.printStackTrace();
               &#125;
            &#125;
            break;
         case &quot;取消&quot;:
            /** 退出系统 */
            System.exit(0);
            break;
         case &quot;发送&quot;:
            
            break;

      &#125;

   &#125;
&#125;
</code></pre>
<p><strong>客户端socket处理线程：</strong></p>
<pre><code class="java">public class ClientReader extends Thread &#123;

   private Socket socket;
    // 接收客户端界面，方便收到消息后，更新界面数据。
   private ClientChat clientChat ;

   public ClientReader(ClientChat clientChat, Socket socket) &#123;
      this.clientChat = clientChat;
      this.socket = socket;
   &#125;

   @Override
   public void run() &#123;
      try &#123;
         DataInputStream dis = new DataInputStream(socket.getInputStream());
         /** 循环一直等待客户端的消息 */
         while(true)&#123;
            /** 读取当前的消息类型 ：登录,群发,私聊 , @消息 */
            int flag = dis.readInt();
            if(flag == 1)&#123;
               // 在线人数消息回来了
               String nameDatas = dis.readUTF();
               // 展示到在线人数的界面
               String[] names = nameDatas.split(Constants.SPILIT);

               clientChat.onLineUsers.setListData(names);
            &#125;else if(flag == 2)&#123;
              
            &#125;
         &#125;
      &#125; catch (Exception e) &#123;
         e.printStackTrace();
      &#125;
   &#125;
&#125;
</code></pre>
<h5 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h5><ul>
<li>此处说明了如果启动客户端界面，以及登陆功能后，服务端收到新的登陆消息后，会响应一个在线列表用户回来给客户端更新在线人数！</li>
</ul>
<h4 id="客户端发送消息逻辑"><a href="#客户端发送消息逻辑" class="headerlink" title="客户端发送消息逻辑"></a>客户端发送消息逻辑</h4><h5 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h5><p>客户端发送群聊消息，@消息，以及私聊消息。</p>
<h5 id="实现步骤-5"><a href="#实现步骤-5" class="headerlink" title="实现步骤"></a>实现步骤</h5><ul>
<li>客户端启动后，在聊天界面需要通过发送按钮推送群聊消息，@消息，以及私聊消息。</li>
<li><img src="/../imgs/BLOG28/image-20200223232406727.png" alt="image-20200223232406727"></li>
<li>如果直接点击发送，默认发送群聊消息</li>
<li>如果选中右侧在线列表某个用户，默认发送@消息</li>
<li>如果选中右侧在线列表某个用户，然后选择右下侧私聊按钮默，认发送私聊消息。</li>
</ul>
<h5 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h5><p><strong>客户端主体代码：</strong></p>
<pre><code class="java">public class ClientChat implements ActionListener &#123;
    /** 1.设计界面  */
    private JFrame win = new JFrame();
    /** 2.消息内容框架 */
    public JTextArea smsContent =new JTextArea(23 , 50);
    /** 3.发送消息的框  */
    private JTextArea smsSend = new JTextArea(4,40);
    /** 4.在线人数的区域  */
    /** 存放人的数据 */
    /** 展示在线人数的窗口 */
    public JList&lt;String&gt; onLineUsers = new JList&lt;&gt;();

    // 是否私聊按钮
    private JCheckBox isPrivateBn = new JCheckBox(&quot;私聊&quot;);
    // 消息按钮
    private JButton sendBn  = new JButton(&quot;发送&quot;);

    // 登录界面
    private JFrame loginView;

    private JTextField ipEt , nameEt , idEt;

    private Socket socket ;

    public static void main(String[] args) &#123;
        new ClientChat().initView();

    &#125;

    private void initView() &#123;
        /** 初始化聊天窗口的界面 */
        win.setSize(650, 600);

        /** 展示登录界面  */
        displayLoginView();

        /** 展示聊天界面 */
        //displayChatView();

    &#125;

    private void displayChatView() &#123;

        JPanel bottomPanel = new JPanel(new BorderLayout());
        //-----------------------------------------------
        // 将消息框和按钮 添加到窗口的底端
        win.add(bottomPanel, BorderLayout.SOUTH);
        bottomPanel.add(smsSend);
        JPanel btns = new JPanel(new FlowLayout(FlowLayout.LEFT));
        btns.add(sendBn);
        btns.add(isPrivateBn);
        bottomPanel.add(btns, BorderLayout.EAST);
        //-----------------------------------------------
        // 给发送消息按钮绑定点击事件监听器
        // 将展示消息区centerPanel添加到窗口的中间
        smsContent.setBackground(new Color(0xdd,0xdd,0xdd));
        // 让展示消息区可以滚动。
        win.add(new JScrollPane(smsContent), BorderLayout.CENTER);
        smsContent.setEditable(false);
        //-----------------------------------------------
        // 用户列表和是否私聊放到窗口的最右边
        Box rightBox = new Box(BoxLayout.Y_AXIS);
        onLineUsers.setFixedCellWidth(120);
        onLineUsers.setVisibleRowCount(13);
        rightBox.add(new JScrollPane(onLineUsers));
        win.add(rightBox, BorderLayout.EAST);
        //-----------------------------------------------
        // 关闭窗口退出当前程序
        win.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        win.pack();  // swing 加上这句 就可以拥有关闭窗口的功能
        /** 设置窗口居中,显示出来  */
        setWindowCenter(win,650,600,true);
        // 发送按钮绑定点击事件
        sendBn.addActionListener(this);
    &#125;

    private void displayLoginView()&#123;

        /** 先让用户进行登录
         *  服务端ip
         *  用户名
         *  id
         *  */
        /** 显示一个qq的登录框     */
        loginView = new JFrame(&quot;登录&quot;);
        loginView.setLayout(new GridLayout(3, 1));
        loginView.setSize(400, 230);

        JPanel ip = new JPanel();
        JLabel label = new JLabel(&quot;   IP:&quot;);
        ip.add(label);
        ipEt = new JTextField(20);
        ip.add(ipEt);
        loginView.add(ip);

        JPanel name = new JPanel();
        JLabel label1 = new JLabel(&quot;姓名:&quot;);
        name.add(label1);
        nameEt = new JTextField(20);
        name.add(nameEt);
        loginView.add(name);

        JPanel btnView = new JPanel();
        JButton login = new JButton(&quot;登陆&quot;);
        btnView.add(login);
        JButton cancle = new JButton(&quot;取消&quot;);
        btnView.add(cancle);
        loginView.add(btnView);
        // 关闭窗口退出当前程序
        loginView.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setWindowCenter(loginView,400,260,true);

        /** 给登录和取消绑定点击事件 */
        login.addActionListener(this);
        cancle.addActionListener(this);

    &#125;

    private static void setWindowCenter(JFrame frame, int width , int height, boolean flag) &#123;
        /** 得到所在系统所在屏幕的宽高 */
        Dimension ds = frame.getToolkit().getScreenSize();

        /** 拿到电脑的宽 */
        int width1 = ds.width;
        /** 高 */
        int height1 = ds.height ;

        System.out.println(width1 +&quot;*&quot; + height1);
        /** 设置窗口的左上角坐标 */
        frame.setLocation(width1/2 - width/2, height1/2 -height/2);
        frame.setVisible(flag);
    &#125;

    @Override
    public void actionPerformed(ActionEvent e) &#123;
        /** 得到点击的事件源 */
        JButton btn = (JButton) e.getSource();
        switch(btn.getText())&#123;
            case &quot;登陆&quot;:
                String ip = ipEt.getText().toString();
                String name = nameEt.getText().toString();
                // 校验参数是否为空
                // 错误提示
                String msg = &quot;&quot; ;
                // 12.1.2.0
                // \d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\
                if(ip==null || !ip.matches(&quot;\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;&quot;))&#123;
                    msg = &quot;请输入合法的服务端ip地址&quot;;
                &#125;else if(name==null || !name.matches(&quot;\\S&#123;1,&#125;&quot;))&#123;
                    msg = &quot;姓名必须1个字符以上&quot;;
                &#125;

                if(!msg.equals(&quot;&quot;))&#123;
                    /** msg有内容说明参数有为空 */
                    // 参数一：弹出放到哪个窗口里面
                    JOptionPane.showMessageDialog(loginView, msg);
                &#125;else&#123;
                    try &#123;
                        // 参数都合法了
                        // 当前登录的用户,去服务端登陆
                        /** 先把当前用户的名称展示到界面 */
                        win.setTitle(name);
                        // 去服务端登陆连接一个socket管道
                        socket = new Socket(ip, Constants.PORT);

                        //为客户端的socket分配一个线程 专门负责收消息
                        new ClientReader(this,socket).start();

                        // 带上用户信息过去
                        DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
                        dos.writeInt(1); // 登录消息
                        dos.writeUTF(name.trim());
                        dos.flush();

                        // 关系当前窗口 弹出聊天界面
                        loginView.dispose(); // 登录窗口销毁
                        displayChatView(); // 展示了聊天窗口了


                    &#125; catch (Exception e1) &#123;
                        e1.printStackTrace();
                    &#125;
                &#125;
                break;
            case &quot;取消&quot;:
                /** 退出系统 */
                System.exit(0);
                break;
            case &quot;发送&quot;:
                // 得到发送消息的内容
                String msgSend = smsSend.getText().toString();
                if(!msgSend.trim().equals(&quot;&quot;))&#123;
                    /** 发消息给服务端 */
                    try &#123;
                        // 判断是否对谁发消息
                        String selectName = onLineUsers.getSelectedValue();
                        int flag = 2 ;// 群发 @消息
                        if(selectName!=null&amp;&amp;!selectName.equals(&quot;&quot;))&#123;
                            msgSend =(&quot;@&quot;+selectName+&quot;,&quot;+msgSend);
                            /** 判断是否选中了私法 */
                            if(isPrivateBn.isSelected())&#123;
                                /** 私法 */
                                flag = 3 ;//私发消息
                            &#125;

                        &#125;

                        DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
                        dos.writeInt(flag); // 群发消息  发送给所有人
                        dos.writeUTF(msgSend);
                        if(flag == 3)&#123;
                            // 告诉服务端我对谁私发
                            dos.writeUTF(selectName.trim());
                        &#125;
                        dos.flush();

                    &#125; catch (Exception e1) &#123;
                        e1.printStackTrace();
                    &#125;

                &#125;
                smsSend.setText(null);
                break;

        &#125;

    &#125;
&#125;
</code></pre>
<p><strong>客户端socket处理线程：</strong></p>
<pre><code class="java">class ClientReader extends Thread &#123;

    private Socket socket;
    private ClientChat clientChat ;

    public ClientReader(ClientChat clientChat, Socket socket) &#123;
        this.clientChat = clientChat;
        this.socket = socket;
    &#125;

    @Override
    public void run() &#123;
        try &#123;
            DataInputStream dis = new DataInputStream(socket.getInputStream());
            /** 循环一直等待客户端的消息 */
            while(true)&#123;
                /** 读取当前的消息类型 ：登录,群发,私聊 , @消息 */
                int flag = dis.readInt();
                if(flag == 1)&#123;
                    // 在线人数消息回来了
                    String nameDatas = dis.readUTF();
                    // 展示到在线人数的界面
                    String[] names = nameDatas.split(Constants.SPILIT);

                    clientChat.onLineUsers.setListData(names);
                &#125;else if(flag == 2)&#123;
                    //群发,私聊 , @消息 都是直接显示的。
                    String msg = dis.readUTF() ;
                    clientChat.smsContent.append(msg);
                    // 让消息界面滾動到底端
                    clientChat.smsContent.setCaretPosition(clientChat.smsContent.getText().length());
                &#125;
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h5><ul>
<li>此处实现了客户端发送群聊消息，@消息，以及私聊消息。</li>
<li>如果直接点击发送，默认发送群聊消息</li>
<li>如果选中右侧在线列表某个用户，默认发送@消息</li>
<li>如果选中右侧在线列表某个用户，然后选择右下侧私聊按钮默，认发送私聊消息。</li>
</ul>
<h1 id="4-JAVA-NIO深入剖析"><a href="#4-JAVA-NIO深入剖析" class="headerlink" title="4  JAVA NIO深入剖析"></a>4  JAVA NIO深入剖析</h1><p>在讲解利用NIO实现通信架构之前，我们需要先来了解一下NIO的基本特点和使用。</p>
<h2 id="4-1-Java-NIO-基本介绍"><a href="#4-1-Java-NIO-基本介绍" class="headerlink" title="4.1 Java NIO 基本介绍"></a>4.1 Java NIO 基本介绍</h2><ul>
<li>Java NIO（New IO）也有人称之为 java non-blocking IO是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面<strong>向缓冲区</strong>的、基于<strong>通道</strong>的IO操作。NIO将以更加高效的方式进行文件的读写操作。NIO可以理解为非阻塞IO,传统的IO的read和write只能阻塞执行，线程在读写IO期间不能干其他事情，比如调用socket.read()时，如果服务器一直没有数据传输过来，线程就一直阻塞，而NIO中可以配置socket为非阻塞模式。</li>
<li>NIO 相关类都被放在 java.nio 包及子包下，并且对原 java.io 包中的很多类进行改写。</li>
<li>NIO 有三大核心部分：<strong>Channel( 通道) ，Buffer( 缓冲区), Selector( 选择器)</strong></li>
<li>Java NIO 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</li>
<li>通俗理解：NIO 是可以做到用一个线程来处理多个操作的。假设有 1000 个请求过来,根据实际情况，可以分配20 或者 80个线程来处理。不像之前的阻塞 IO 那样，非得分配 1000 个。</li>
</ul>
<h2 id="4-2-NIO-和-BIO-的比较"><a href="#4-2-NIO-和-BIO-的比较" class="headerlink" title="4.2 NIO 和 BIO 的比较"></a>4.2 NIO 和 BIO 的比较</h2><ul>
<li>BIO 以流的方式处理数据,而 NIO 以块的方式处理数据,块 I&#x2F;O 的效率比流 I&#x2F;O 高很多</li>
<li>BIO 是阻塞的，NIO 则是非阻塞的</li>
<li>BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据总是从通道<br>读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道</li>
</ul>
<table>
<thead>
<tr>
<th>NIO</th>
<th>BIO</th>
</tr>
</thead>
<tbody><tr>
<td>面向缓冲区（Buffer）</td>
<td>面向流（Stream）</td>
</tr>
<tr>
<td>非阻塞（Non Blocking IO）</td>
<td>阻塞IO(Blocking IO)</td>
</tr>
<tr>
<td>选择器（Selectors）</td>
<td></td>
</tr>
</tbody></table>
<h2 id="4-3-NIO-三大核心原理示意图"><a href="#4-3-NIO-三大核心原理示意图" class="headerlink" title="4.3 NIO 三大核心原理示意图"></a>4.3 NIO 三大核心原理示意图</h2><p>NIO 有三大核心部分：<strong>Channel( 通道) ，Buffer( 缓冲区), Selector( 选择器)</strong></p>
<h3 id="Buffer缓冲区"><a href="#Buffer缓冲区" class="headerlink" title="Buffer缓冲区"></a>Buffer缓冲区</h3><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。相比较直接对数组的操作，Buffer API更加容易操作和管理。</p>
<h3 id="Channel（通道）"><a href="#Channel（通道）" class="headerlink" title="Channel（通道）"></a><strong>Channel（通道）</strong></h3><p>Java NIO的通道类似流，但又有些不同：既可以从通道中读取数据，又可以写数据到通道。但流的（input或output)读写通常是单向的。 通道可以非阻塞读取和写入通道，通道可以支持读取或写入缓冲区，也支持异步地读写。</p>
<h3 id="Selector选择器"><a href="#Selector选择器" class="headerlink" title="Selector选择器"></a>Selector选择器</h3><p>Selector是 一个Java NIO组件，可以能够检查一个或多个 NIO 通道，并确定哪些通道已经准备好进行读取或写入。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接，提高效率</p>
<p><img src="/../imgs/BLOG28/image-20200619153658139.png" alt="image-20200619153658139"></p>
<ul>
<li>每个 channel 都会对应一个 Buffer</li>
<li>一个线程对应Selector ， 一个Selector对应多个 channel(连接)</li>
<li>程序切换到哪个 channel 是由事件决定的</li>
<li>Selector 会根据不同的事件，在各个通道上切换</li>
<li>Buffer 就是一个内存块 ， 底层是一个数组</li>
<li>数据的读取写入是通过 Buffer完成的 , BIO 中要么是输入流，或者是输出流, 不能双向，但是 NIO 的 Buffer 是可以读也可以写。</li>
<li>Java NIO系统的核心在于：通道(Channel)和缓冲区 (Buffer)。通道表示打开到 IO 设备(例如：文件、 套接字)的连接。若需要使用 NIO 系统，需要获取 用于连接 IO 设备的通道以及用于容纳数据的缓冲 区。然后操作缓冲区，对数据进行处理。简而言之，Channel 负责传输， Buffer 负责存取数据</li>
</ul>
<h2 id="4-4-NIO核心一：缓冲区-Buffer"><a href="#4-4-NIO核心一：缓冲区-Buffer" class="headerlink" title="4.4 NIO核心一：缓冲区(Buffer)"></a>4.4 NIO核心一：缓冲区(Buffer)</h2><h3 id="缓冲区（Buffer）"><a href="#缓冲区（Buffer）" class="headerlink" title="缓冲区（Buffer）"></a>缓冲区（Buffer）</h3><p>一个用于特定基本数据类 型的容器。由 java.nio 包定义的，所有缓冲区 都是 Buffer 抽象类的子类.。Java NIO 中的 Buffer 主要用于与 NIO 通道进行 交互，数据是从通道读入缓冲区，从缓冲区写入通道中的</p>
<p><img src="/../imgs/BLOG28/image-20200619163952309.png" alt="image-20200619163952309"></p>
<h3 id="Buffer-类及其子类"><a href="#Buffer-类及其子类" class="headerlink" title="Buffer 类及其子类"></a><strong>Buffer 类及其子类</strong></h3><p><strong>Buffer</strong> 就像一个数组，可以保存多个相同类型的数据。根 据数据类型不同 ，有以下 Buffer 常用子类： </p>
<ul>
<li>ByteBuffer </li>
<li>CharBuffer </li>
<li>ShortBuffer </li>
<li>IntBuffer </li>
<li>LongBuffer </li>
<li>FloatBuffer </li>
<li>DoubleBuffer</li>
</ul>
<p>上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自 管理的数据类型不同而已。都是通过如下方法获取一个 Buffer 对象：</p>
<pre><code class="java">static XxxBuffer allocate(int capacity) : 创建一个容量为capacity 的 XxxBuffer 对象
</code></pre>
<h3 id="缓冲区的基本属性"><a href="#缓冲区的基本属性" class="headerlink" title="缓冲区的基本属性"></a>缓冲区的基本属性</h3><p>Buffer 中的重要概念： </p>
<ul>
<li><strong>容量 (capacity)</strong> ：作为一个内存块，Buffer具有一定的固定大小，也称为”容量”，缓冲区容量不能为负，并且创建后不能更改。 </li>
<li>**限制 (limit)**：表示缓冲区中可以操作数据的大小（limit 后数据不能进行读写）。缓冲区的限制不能为负，并且不能大于其容量。 <strong>写入模式，限制等于buffer的容量。读取模式下，limit等于写入的数据量</strong>。</li>
<li>**位置 (position)**：下一个要读取或写入的数据的索引。缓冲区的位置不能为 负，并且不能大于其限制 </li>
<li>**标记 (mark)与重置 (reset)**：标记是一个索引，通过 Buffer 中的 mark() 方法 指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这 个 position.<br><strong>标记、位置、限制、容量遵守以下不变式： 0 &lt;&#x3D; mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</strong></li>
<li><strong>图示:</strong></li>
<li><img src="/../imgs/BLOG28/image-20200619172434538.png" alt="image-20200619172434538"></li>
</ul>
<h3 id="Buffer常见方法"><a href="#Buffer常见方法" class="headerlink" title="Buffer常见方法"></a>Buffer常见方法</h3><pre><code class="java">Buffer clear() 清空缓冲区并返回对缓冲区的引用
Buffer flip() 为 将缓冲区的界限设置为当前位置，并将当前位置充值为 0
int capacity() 返回 Buffer 的 capacity 大小
boolean hasRemaining() 判断缓冲区中是否还有元素
int limit() 返回 Buffer 的界限(limit) 的位置
Buffer limit(int n) 将设置缓冲区界限为 n, 并返回一个具有新 limit 的缓冲区对象
Buffer mark() 对缓冲区设置标记
int position() 返回缓冲区的当前位置 position
Buffer position(int n) 将设置缓冲区的当前位置为 n , 并返回修改后的 Buffer 对象
int remaining() 返回 position 和 limit 之间的元素个数
Buffer reset() 将位置 position 转到以前设置的 mark 所在的位置
Buffer rewind() 将位置设为为 0， 取消设置的 mark
</code></pre>
<h3 id="缓冲区的数据操作"><a href="#缓冲区的数据操作" class="headerlink" title="缓冲区的数据操作"></a>缓冲区的数据操作</h3><pre><code class="java">Buffer 所有子类提供了两个用于数据操作的方法：get()put() 方法
取获取 Buffer中的数据
get() ：读取单个字节
get(byte[] dst)：批量读取多个字节到 dst 中
get(int index)：读取指定索引位置的字节(不会移动 position)
    
放到 入数据到 Buffer 中 中
put(byte b)：将给定单个字节写入缓冲区的当前位置
put(byte[] src)：将 src 中的字节写入缓冲区的当前位置
put(int index, byte b)：将指定字节写入缓冲区的索引位置(不会移动 position)
</code></pre>
<p><strong>使用Buffer读写数据一般遵循以下四个步骤：</strong></p>
<ul>
<li>1.写入数据到Buffer</li>
<li>2.调用flip()方法，转换为读取模式</li>
<li>3.从Buffer中读取数据</li>
<li>4.调用buffer.clear()方法或者buffer.compact()方法清除缓冲区</li>
</ul>
<h3 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h3><pre><code class="java">public class TestBuffer &#123;
   @Test
   public void test3()&#123;
      //分配直接缓冲区
      ByteBuffer buf = ByteBuffer.allocateDirect(1024);
      System.out.println(buf.isDirect());
   &#125;
   
   @Test
   public void test2()&#123;
      String str = &quot;itheima&quot;;
      
      ByteBuffer buf = ByteBuffer.allocate(1024);
      
      buf.put(str.getBytes());
      
      buf.flip();
      
      byte[] dst = new byte[buf.limit()];
      buf.get(dst, 0, 2);
      System.out.println(new String(dst, 0, 2));
      System.out.println(buf.position());
      
      //mark() : 标记
      buf.mark();
      
      buf.get(dst, 2, 2);
      System.out.println(new String(dst, 2, 2));
      System.out.println(buf.position());
      
      //reset() : 恢复到 mark 的位置
      buf.reset();
      System.out.println(buf.position());
      
      //判断缓冲区中是否还有剩余数据
      if(buf.hasRemaining())&#123;
         //获取缓冲区中可以操作的数量
         System.out.println(buf.remaining());
      &#125;
   &#125;
    
   @Test
   public void test1()&#123;
      String str = &quot;itheima&quot;;
      //1. 分配一个指定大小的缓冲区
      ByteBuffer buf = ByteBuffer.allocate(1024);
      System.out.println(&quot;-----------------allocate()----------------&quot;);
      System.out.println(buf.position());
      System.out.println(buf.limit());
      System.out.println(buf.capacity());
      
      //2. 利用 put() 存入数据到缓冲区中
      buf.put(str.getBytes());
      System.out.println(&quot;-----------------put()----------------&quot;);
      System.out.println(buf.position());
      System.out.println(buf.limit());
      System.out.println(buf.capacity());
      
      //3. 切换读取数据模式
      buf.flip();
      System.out.println(&quot;-----------------flip()----------------&quot;);
      System.out.println(buf.position());
      System.out.println(buf.limit());
      System.out.println(buf.capacity());
      
      //4. 利用 get() 读取缓冲区中的数据
      byte[] dst = new byte[buf.limit()];
      buf.get(dst);
      System.out.println(new String(dst, 0, dst.length));

      System.out.println(&quot;-----------------get()----------------&quot;);
      System.out.println(buf.position());
      System.out.println(buf.limit());
      System.out.println(buf.capacity());
      //5. rewind() : 可重复读
      buf.rewind();
      System.out.println(&quot;-----------------rewind()----------------&quot;);
      System.out.println(buf.position());
      System.out.println(buf.limit());
      System.out.println(buf.capacity());
      
      //6. clear() : 清空缓冲区. 但是缓冲区中的数据依然存在，但是处于“被遗忘”状态
      buf.clear();
      System.out.println(&quot;-----------------clear()----------------&quot;);
      System.out.println(buf.position());
      System.out.println(buf.limit());
      System.out.println(buf.capacity());
      System.out.println((char)buf.get());
      
   &#125;

&#125;
</code></pre>
<h3 id="直接与非直接缓冲区"><a href="#直接与非直接缓冲区" class="headerlink" title="直接与非直接缓冲区"></a>直接与非直接缓冲区</h3><p>什么是直接内存与非直接内存</p>
<p>根据官方文档的描述：</p>
<p><code>byte byffer</code>可以是两种类型，一种是基于直接内存（也就是非堆内存）；另一种是非直接内存（也就是堆内存）。对于直接内存来说，JVM将会在IO操作上具有更高的性能，因为它直接作用于本地系统的IO操作。而非直接内存，也就是堆内存中的数据，如果要作IO操作，会先从本进程内存复制到直接内存，再利用本地IO处理。</p>
<p>从数据流的角度，非直接内存是下面这样的作用链：</p>
<pre><code>本地IO--&gt;直接内存--&gt;非直接内存--&gt;直接内存--&gt;本地IO
</code></pre>
<p>而直接内存是：</p>
<pre><code>本地IO--&gt;直接内存--&gt;本地IO
</code></pre>
<p>很明显，在做IO处理时，比如网络发送大量数据时，直接内存会具有更高的效率。直接内存使用allocateDirect创建，但是它比申请普通的堆内存需要耗费更高的性能。不过，这部分的数据是在JVM之外的，因此它不会占用应用的内存。所以呢，当你有很大的数据要缓存，并且它的生命周期又很长，那么就比较适合使用直接内存。只是一般来说，如果不是能带来很明显的性能提升，还是推荐直接使用堆内存。字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect()  方法来确定。</p>
<p><strong>使用场景</strong></p>
<ul>
<li>1 有很大的数据需要存储，它的生命周期又很长</li>
<li>2 适合频繁的IO操作，比如网络并发场景</li>
</ul>
<h2 id="4-5-NIO核心二：通道-Channel"><a href="#4-5-NIO核心二：通道-Channel" class="headerlink" title="4.5 NIO核心二：通道(Channel)"></a>4.5 NIO核心二：通道(Channel)</h2><h3 id="通道Channe概述"><a href="#通道Channe概述" class="headerlink" title="通道Channe概述"></a>通道Channe概述</h3><p>通道（Channel）：由 java.nio.channels 包定义 的。Channel 表示 IO 源与目标打开的连接。 Channel 类似于传统的“流”。只不过 Channel 本身不能直接访问数据，Channel 只能与 Buffer 进行交互。</p>
<p>1、 NIO 的通道类似于流，但有些区别如下：</p>
<ul>
<li><p>通道可以同时进行读写，而流只能读或者只能写</p>
</li>
<li><p>通道可以实现异步读写数据</p>
</li>
<li><p>通道可以从缓冲读数据，也可以写数据到缓冲:</p>
</li>
</ul>
<p>2、BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道(Channel)<br>  是双向的，可以读操作，也可以写操作。</p>
<p>3、Channel 在 NIO 中是一个接口</p>
<pre><code class="java">public interface Channel extends Closeable&#123;&#125;
</code></pre>
<h3 id="常用的Channel实现类"><a href="#常用的Channel实现类" class="headerlink" title="常用的Channel实现类"></a>常用的Channel实现类</h3><ul>
<li>FileChannel：用于读取、写入、映射和操作文件的通道。</li>
<li>DatagramChannel：通过 UDP 读写网络中的数据通道。</li>
<li>SocketChannel：通过 TCP 读写网络中的数据。</li>
<li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。 【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】</li>
</ul>
<h3 id="FileChannel-类"><a href="#FileChannel-类" class="headerlink" title="FileChannel 类"></a>FileChannel 类</h3><p>获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下：</p>
<ul>
<li>FileInputStream</li>
<li>FileOutputStream</li>
<li>RandomAccessFile</li>
<li>DatagramSocket</li>
<li>Socket</li>
<li>ServerSocket<br>获取通道的其他方式是使用 Files 类的静态方法 newByteChannel() 获取字节通道。或者通过通道的静态方法 open() 打开并返回指定通道</li>
</ul>
<h3 id="FileChannel的常用方法"><a href="#FileChannel的常用方法" class="headerlink" title="FileChannel的常用方法"></a>FileChannel的常用方法</h3><pre><code class="java">int read(ByteBuffer dst) 从 从  Channel 到 中读取数据到  ByteBuffer
long  read(ByteBuffer[] dsts) 将 将  Channel 到 中的数据“分散”到  ByteBuffer[]
int  write(ByteBuffer src) 将 将  ByteBuffer 到 中的数据写入到  Channel
long write(ByteBuffer[] srcs) 将 将  ByteBuffer[] 到 中的数据“聚集”到  Channel
long position() 返回此通道的文件位置
FileChannel position(long p) 设置此通道的文件位置
long size() 返回此通道的文件的当前大小
FileChannel truncate(long s) 将此通道的文件截取为给定大小
void force(boolean metaData) 强制将所有对此通道的文件更新写入到存储设备中
</code></pre>
<h3 id="案例1-本地文件写数据"><a href="#案例1-本地文件写数据" class="headerlink" title="案例1-本地文件写数据"></a>案例1-本地文件写数据</h3><p>需求：使用前面学习后的 ByteBuffer(缓冲) 和 FileChannel(通道)， 将 “hello,黑马Java程序员！” 写入到 data.txt 中.</p>
<pre><code class="java">package com.itheima;


import org.junit.Test;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

public class ChannelTest &#123;
    @Test
    public void write()&#123;
        try &#123;
            // 1、字节输出流通向目标文件
            FileOutputStream fos = new FileOutputStream(&quot;data01.txt&quot;);
            // 2、得到字节输出流对应的通道Channel
            FileChannel channel = fos.getChannel();
            // 3、分配缓冲区
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            buffer.put(&quot;hello,黑马Java程序员！&quot;.getBytes());
            // 4、把缓冲区切换成写出模式
            buffer.flip();
            channel.write(buffer);
            channel.close();
            System.out.println(&quot;写数据到文件中！&quot;);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="案例2-本地文件读数据"><a href="#案例2-本地文件读数据" class="headerlink" title="案例2-本地文件读数据"></a>案例2-本地文件读数据</h3><p>需求：使用前面学习后的 ByteBuffer(缓冲) 和 FileChannel(通道)， 将 data01.txt 中的数据读入到程序，并显示在控制台屏幕</p>
<pre><code class="java">public class ChannelTest &#123;

    @Test
    public void read() throws Exception &#123;
        // 1、定义一个文件字节输入流与源文件接通
        FileInputStream is = new FileInputStream(&quot;data01.txt&quot;);
        // 2、需要得到文件字节输入流的文件通道
        FileChannel channel = is.getChannel();
        // 3、定义一个缓冲区
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        // 4、读取数据到缓冲区
        channel.read(buffer);
        buffer.flip();
        // 5、读取出缓冲区中的数据并输出即可
        String rs = new String(buffer.array(),0,buffer.remaining());
        System.out.println(rs);

    &#125;
</code></pre>
<h3 id="案例3-使用Buffer完成文件复制"><a href="#案例3-使用Buffer完成文件复制" class="headerlink" title="案例3-使用Buffer完成文件复制"></a>案例3-使用Buffer完成文件复制</h3><p>使用 FileChannel(通道) ，完成文件的拷贝。</p>
<pre><code class="java">@Test
public void copy() throws Exception &#123;
    // 源文件
    File srcFile = new File(&quot;C:\\Users\\dlei\\Desktop\\BIO,NIO,AIO\\文件\\壁纸.jpg&quot;);
    File destFile = new File(&quot;C:\\Users\\dlei\\Desktop\\BIO,NIO,AIO\\文件\\壁纸new.jpg&quot;);
    // 得到一个字节字节输入流
    FileInputStream fis = new FileInputStream(srcFile);
    // 得到一个字节输出流
    FileOutputStream fos = new FileOutputStream(destFile);
    // 得到的是文件通道
    FileChannel isChannel = fis.getChannel();
    FileChannel osChannel = fos.getChannel();
    // 分配缓冲区
    ByteBuffer buffer = ByteBuffer.allocate(1024);
    while(true)&#123;
        // 必须先清空缓冲然后再写入数据到缓冲区
        buffer.clear();
        // 开始读取一次数据
        int flag = isChannel.read(buffer);
        if(flag == -1)&#123;
            break;
        &#125;
        // 已经读取了数据 ，把缓冲区的模式切换成可读模式
        buffer.flip();
        // 把数据写出到
        osChannel.write(buffer);
    &#125;
    isChannel.close();
    osChannel.close();
    System.out.println(&quot;复制完成！&quot;);
&#125;
</code></pre>
<h3 id="案例4-分散-Scatter-和聚集-Gather"><a href="#案例4-分散-Scatter-和聚集-Gather" class="headerlink" title="案例4-分散 (Scatter) 和聚集 (Gather)"></a>案例4-分散 (Scatter) 和聚集 (Gather)</h3><p>分散读取（Scatter ）:是指把Channel通道的数据读入到多个缓冲区中去</p>
<p>聚集写入（Gathering ）是指将多个 Buffer 中的数据“聚集”到 Channel。</p>
<pre><code class="java">//分散和聚集
@Test
public void test() throws IOException&#123;
        RandomAccessFile raf1 = new RandomAccessFile(&quot;1.txt&quot;, &quot;rw&quot;);
    //1. 获取通道
    FileChannel channel1 = raf1.getChannel();
    
    //2. 分配指定大小的缓冲区
    ByteBuffer buf1 = ByteBuffer.allocate(100);
    ByteBuffer buf2 = ByteBuffer.allocate(1024);
    
    //3. 分散读取
    ByteBuffer[] bufs = &#123;buf1, buf2&#125;;
    channel1.read(bufs);
    
    for (ByteBuffer byteBuffer : bufs) &#123;
        byteBuffer.flip();
    &#125;
    
    System.out.println(new String(bufs[0].array(), 0, bufs[0].limit()));
    System.out.println(&quot;-----------------&quot;);
    System.out.println(new String(bufs[1].array(), 0, bufs[1].limit()));
    
    //4. 聚集写入
    RandomAccessFile raf2 = new RandomAccessFile(&quot;2.txt&quot;, &quot;rw&quot;);
    FileChannel channel2 = raf2.getChannel();
    
    channel2.write(bufs);
&#125;
</code></pre>
<h3 id="案例5-transferFrom"><a href="#案例5-transferFrom" class="headerlink" title="案例5-transferFrom()"></a>案例5-transferFrom()</h3><p>从目标通道中去复制原通道数据</p>
<pre><code class="java">@Test
public void test02() throws Exception &#123;
    // 1、字节输入管道
    FileInputStream is = new FileInputStream(&quot;data01.txt&quot;);
    FileChannel isChannel = is.getChannel();
    // 2、字节输出流管道
    FileOutputStream fos = new FileOutputStream(&quot;data03.txt&quot;);
    FileChannel osChannel = fos.getChannel();
    // 3、复制
    osChannel.transferFrom(isChannel,isChannel.position(),isChannel.size());
    isChannel.close();
    osChannel.close();
&#125;
</code></pre>
<h3 id="案例6-transferTo"><a href="#案例6-transferTo" class="headerlink" title="案例6-transferTo()"></a>案例6-transferTo()</h3><p>把原通道数据复制到目标通道</p>
<pre><code class="java">@Test
public void test02() throws Exception &#123;
    // 1、字节输入管道
    FileInputStream is = new FileInputStream(&quot;data01.txt&quot;);
    FileChannel isChannel = is.getChannel();
    // 2、字节输出流管道
    FileOutputStream fos = new FileOutputStream(&quot;data04.txt&quot;);
    FileChannel osChannel = fos.getChannel();
    // 3、复制
    isChannel.transferTo(isChannel.position() , isChannel.size() , osChannel);
    isChannel.close();
    osChannel.close();
&#125;
</code></pre>
<h2 id="4-6-NIO核心三：选择器-Selector"><a href="#4-6-NIO核心三：选择器-Selector" class="headerlink" title="4.6 NIO核心三：选择器(Selector)"></a>4.6 NIO核心三：选择器(Selector)</h2><h3 id="选择器-Selector-概述"><a href="#选择器-Selector-概述" class="headerlink" title="选择器(Selector)概述"></a>选择器(Selector)概述</h3><p>选择器（Selector） 是 SelectableChannle 对象的多路复用器，Selector 可以同时监控多个 SelectableChannel 的 IO 状况，也就是说，利用 Selector可使一个单独的线程管理多个 Channel。Selector 是非阻塞 IO 的核心</p>
<p><img src="/../imgs/BLOG28/image-20200619230246145.png" alt="image-20200619230246145"></p>
<ul>
<li>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到 Selector(选择器)</li>
<li>Selector 能够检测多个注册的通道上是否有事件发生(注意:多个 Channel 以事件的方式可以注册到同一个<br>Selector)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管<br>理多个通道，也就是管理多个连接和请求。</li>
<li>只有在 连接&#x2F;通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都<br>创建一个线程，不用去维护多个线程</li>
<li>避免了多线程之间的上下文切换导致的开销</li>
</ul>
<h3 id="选择-器（Selector）的应用"><a href="#选择-器（Selector）的应用" class="headerlink" title="选择 器（Selector）的应用"></a>选择 器（Selector）的应用</h3><p>创建 Selector ：通过调用 Selector.open() 方法创建一个 Selector。</p>
<pre><code class="java">Selector selector = Selector.open();
</code></pre>
<p>向选择器注册通道：SelectableChannel.register(Selector sel, int ops)</p>
<pre><code class="java">//1. 获取通道
ServerSocketChannel ssChannel = ServerSocketChannel.open();
//2. 切换非阻塞模式
ssChannel.configureBlocking(false);
//3. 绑定连接
ssChannel.bind(new InetSocketAddress(9898));
//4. 获取选择器
Selector selector = Selector.open();
//5. 将通道注册到选择器上, 并且指定“监听接收事件”
ssChannel.register(selector, SelectionKey.OP_ACCEPT);
</code></pre>
<p> 当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数 ops 指定。可以监听的事件类型（用 可使用 SelectionKey  的四个常量 表示）：</p>
<ul>
<li>读 : SelectionKey.OP_READ （1）</li>
<li>写 : SelectionKey.OP_WRITE （4）</li>
<li>连接 : SelectionKey.OP_CONNECT （8）</li>
<li>接收 : SelectionKey.OP_ACCEPT （16）</li>
<li>若注册时不止监听一个事件，则可以使用“位或”操作符连接。</li>
</ul>
<pre><code class="java">int interestSet = SelectionKey.OP_READ|SelectionKey.OP_WRITE 
</code></pre>
<h2 id="4-7-NIO非阻塞式网络通信原理分析"><a href="#4-7-NIO非阻塞式网络通信原理分析" class="headerlink" title="4.7 NIO非阻塞式网络通信原理分析"></a>4.7 NIO非阻塞式网络通信原理分析</h2><h3 id="Selector-示意图和特点说明"><a href="#Selector-示意图和特点说明" class="headerlink" title="Selector 示意图和特点说明"></a>Selector 示意图和特点说明</h3><p>Selector可以实现： 一个 I&#x2F;O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I&#x2F;O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</p>
<p><img src="/../imgs/BLOG28/image-20200619153658139.png" alt="image-20200619153658139"></p>
<h3 id="服务端流程"><a href="#服务端流程" class="headerlink" title="服务端流程"></a>服务端流程</h3><ul>
<li><p>1、当客户端连接服务端时，服务端会通过 ServerSocketChannel 得到 SocketChannel：1. 获取通道</p>
<pre><code class="java"> ServerSocketChannel ssChannel = ServerSocketChannel.open();
</code></pre>
</li>
<li><p>2、切换非阻塞模式</p>
<pre><code> ssChannel.configureBlocking(false);
</code></pre>
</li>
<li><p>3、绑定连接</p>
<pre><code> ssChannel.bind(new InetSocketAddress(9999));
</code></pre>
</li>
<li><p>4、 获取选择器</p>
<pre><code>Selector selector = Selector.open();
</code></pre>
</li>
<li><p>5、 将通道注册到选择器上, 并且指定“监听接收事件”</p>
<pre><code>ssChannel.register(selector, SelectionKey.OP_ACCEPT);
</code></pre>
</li>
<li><ol start="6">
<li>轮询式的获取选择器上已经“准备就绪”的事件</li>
</ol>
</li>
<li><pre><code class="java">//轮询式的获取选择器上已经“准备就绪”的事件
 while (selector.select() &gt; 0) &#123;
        System.out.println(&quot;轮一轮&quot;);
        //7. 获取当前选择器中所有注册的“选择键(已就绪的监听事件)”
        Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();
        while (it.hasNext()) &#123;
            //8. 获取准备“就绪”的是事件
            SelectionKey sk = it.next();
            //9. 判断具体是什么事件准备就绪
            if (sk.isAcceptable()) &#123;
                //10. 若“接收就绪”，获取客户端连接
                SocketChannel sChannel = ssChannel.accept();
                //11. 切换非阻塞模式
                sChannel.configureBlocking(false);
                //12. 将该通道注册到选择器上
                sChannel.register(selector, SelectionKey.OP_READ);
            &#125; else if (sk.isReadable()) &#123;
                //13. 获取当前选择器上“读就绪”状态的通道
                SocketChannel sChannel = (SocketChannel) sk.channel();
                //14. 读取数据
                ByteBuffer buf = ByteBuffer.allocate(1024);
                int len = 0;
                while ((len = sChannel.read(buf)) &gt; 0) &#123;
                    buf.flip();
                    System.out.println(new String(buf.array(), 0, len));
                    buf.clear();
                &#125;
            &#125;
            //15. 取消选择键 SelectionKey
            it.remove();
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h3 id="客户端流程"><a href="#客户端流程" class="headerlink" title="客户端流程"></a>客户端流程</h3><ul>
<li><ol>
<li><p>获取通道</p>
<pre><code>SocketChannel sChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 9999));
</code></pre>
</li>
</ol>
</li>
<li><ol start="2">
<li><p>切换非阻塞模式</p>
<pre><code>sChannel.configureBlocking(false);
</code></pre>
</li>
</ol>
</li>
<li><ol start="3">
<li>分配指定大小的缓冲区</li>
</ol>
<pre><code>ByteBuffer buf = ByteBuffer.allocate(1024);
</code></pre>
</li>
<li><ol start="4">
<li><p>发送数据给服务端</p>
<p> Scanner scan &#x3D; new Scanner(System.in);<br> while(scan.hasNext()){<br> String str &#x3D; scan.nextLine();<br> buf.put((new SimpleDateFormat(“yyyy&#x2F;MM&#x2F;dd HH:mm:ss”).format(System.currentTimeMillis())<br>         + “\n” + str).getBytes());<br> buf.flip();<br> sChannel.write(buf);<br> buf.clear();<br> }<br> &#x2F;&#x2F;关闭通道<br> sChannel.close();</p>
</li>
</ol>
</li>
</ul>
<h2 id="4-8-NIO非阻塞式网络通信入门案例"><a href="#4-8-NIO非阻塞式网络通信入门案例" class="headerlink" title="4.8 NIO非阻塞式网络通信入门案例"></a>4.8 NIO非阻塞式网络通信入门案例</h2><p>需求：服务端接收客户端的连接请求，并接收多个客户端发送过来的事件。</p>
<h3 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h3><pre><code class="java">/**
  客户端
 */
public class Client &#123;

    public static void main(String[] args) throws Exception &#123;
        //1. 获取通道
        SocketChannel sChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 9999));
        //2. 切换非阻塞模式
        sChannel.configureBlocking(false);
        //3. 分配指定大小的缓冲区
        ByteBuffer buf = ByteBuffer.allocate(1024);
        //4. 发送数据给服务端
        Scanner scan = new Scanner(System.in);
        while(scan.hasNext())&#123;
            String str = scan.nextLine();
            buf.put((new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;).format(System.currentTimeMillis())
                    + &quot;\n&quot; + str).getBytes());
            buf.flip();
            sChannel.write(buf);
            buf.clear();
        &#125;
        //5. 关闭通道
        sChannel.close();
    &#125;
&#125;

/**
 服务端
 */
public class Server &#123;
    public static void main(String[] args) throws IOException &#123;
        //1. 获取通道
        ServerSocketChannel ssChannel = ServerSocketChannel.open();
        //2. 切换非阻塞模式
        ssChannel.configureBlocking(false);
        //3. 绑定连接
        ssChannel.bind(new InetSocketAddress(9999));
        //4. 获取选择器
        Selector selector = Selector.open();
        //5. 将通道注册到选择器上, 并且指定“监听接收事件”
        ssChannel.register(selector, SelectionKey.OP_ACCEPT);
        //6. 轮询式的获取选择器上已经“准备就绪”的事件
        while (selector.select() &gt; 0) &#123;
            System.out.println(&quot;轮一轮&quot;);
            //7. 获取当前选择器中所有注册的“选择键(已就绪的监听事件)”
            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();
            while (it.hasNext()) &#123;
                //8. 获取准备“就绪”的是事件
                SelectionKey sk = it.next();
                //9. 判断具体是什么事件准备就绪
                if (sk.isAcceptable()) &#123;
                    //10. 若“接收就绪”，获取客户端连接
                    SocketChannel sChannel = ssChannel.accept();
                    //11. 切换非阻塞模式
                    sChannel.configureBlocking(false);
                    //12. 将该通道注册到选择器上
                    sChannel.register(selector, SelectionKey.OP_READ);
                &#125; else if (sk.isReadable()) &#123;
                    //13. 获取当前选择器上“读就绪”状态的通道
                    SocketChannel sChannel = (SocketChannel) sk.channel();
                    //14. 读取数据
                    ByteBuffer buf = ByteBuffer.allocate(1024);
                    int len = 0;
                    while ((len = sChannel.read(buf)) &gt; 0) &#123;
                        buf.flip();
                        System.out.println(new String(buf.array(), 0, len));
                        buf.clear();
                    &#125;
                &#125;
                //15. 取消选择键 SelectionKey
                it.remove();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="4-9-NIO-网络编程应用实例-群聊系统"><a href="#4-9-NIO-网络编程应用实例-群聊系统" class="headerlink" title="4.9  NIO 网络编程应用实例-群聊系统"></a>4.9  NIO 网络编程应用实例-群聊系统</h2><h3 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h3><p><strong>需求:进一步理解 NIO 非阻塞网络编程机制，实现多人群聊</strong></p>
<ul>
<li>编写一个 NIO 群聊系统，实现客户端与客户端的通信需求（非阻塞）</li>
<li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过 channel 可以无阻塞发送消息给其它所有客户端用户，同时可以接受其它客户端用户通过服务端转发来的消息</li>
</ul>
<h3 id="服务端代码实现"><a href="#服务端代码实现" class="headerlink" title="服务端代码实现"></a>服务端代码实现</h3><pre><code class="java">public class Server &#123;
    //定义属性
    private Selector selector;
    private ServerSocketChannel ssChannel;
    private static final int PORT = 9999;
    //构造器
    //初始化工作
    public Server() &#123;
        try &#123;
            // 1、获取通道
            ssChannel = ServerSocketChannel.open();
            // 2、切换为非阻塞模式
            ssChannel.configureBlocking(false);
            // 3、绑定连接的端口
            ssChannel.bind(new InetSocketAddress(PORT));
            // 4、获取选择器Selector
            selector = Selector.open();
            // 5、将通道都注册到选择器上去，并且开始指定监听接收事件
            ssChannel.register(selector , SelectionKey.OP_ACCEPT);
        &#125;catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    //监听
    public void listen() &#123;
        System.out.println(&quot;监听线程: &quot; + Thread.currentThread().getName());
        try &#123;
            while (selector.select() &gt; 0)&#123;
                System.out.println(&quot;开始一轮事件处理~~~&quot;);
                // 7、获取选择器中的所有注册的通道中已经就绪好的事件
                Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();
                // 8、开始遍历这些准备好的事件
                while (it.hasNext())&#123;
                    // 提取当前这个事件
                    SelectionKey sk = it.next();
                    // 9、判断这个事件具体是什么
                    if(sk.isAcceptable())&#123;
                        // 10、直接获取当前接入的客户端通道
                        SocketChannel schannel = ssChannel.accept();
                        // 11 、切换成非阻塞模式
                        schannel.configureBlocking(false);
                        // 12、将本客户端通道注册到选择器
                        System.out.println(schannel.getRemoteAddress() + &quot; 上线 &quot;);
                        schannel.register(selector , SelectionKey.OP_READ);
                        //提示
                    &#125;else if(sk.isReadable())&#123;
                        //处理读 (专门写方法..)
                        readData(sk);
                    &#125;

                    it.remove(); // 处理完毕之后需要移除当前事件
                &#125;
            &#125;
        &#125;catch (Exception e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            //发生异常处理....

        &#125;
    &#125;

    //读取客户端消息
    private void readData(SelectionKey key) &#123;
        //取到关联的channle
        SocketChannel channel = null;
        try &#123;
           //得到channel
            channel = (SocketChannel) key.channel();
            //创建buffer
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            int count = channel.read(buffer);
            //根据count的值做处理
            if(count &gt; 0) &#123;
                //把缓存区的数据转成字符串
                String msg = new String(buffer.array());
                //输出该消息
                System.out.println(&quot;form 客户端: &quot; + msg);
                //向其它的客户端转发消息(去掉自己), 专门写一个方法来处理
                sendInfoToOtherClients(msg, channel);
            &#125;
        &#125;catch (IOException e) &#123;
            try &#123;
                System.out.println(channel.getRemoteAddress() + &quot; 离线了..&quot;);
                e.printStackTrace();
                //取消注册
                key.cancel();
                //关闭通道
                channel.close();
            &#125;catch (IOException e2) &#123;
                e2.printStackTrace();;
            &#125;
        &#125;
    &#125;

    //转发消息给其它客户(通道)
    private void sendInfoToOtherClients(String msg, SocketChannel self ) throws  IOException&#123;
        System.out.println(&quot;服务器转发消息中...&quot;);
        System.out.println(&quot;服务器转发数据给客户端线程: &quot; + Thread.currentThread().getName());
        //遍历 所有注册到selector 上的 SocketChannel,并排除 self
        for(SelectionKey key: selector.keys()) &#123;
            //通过 key  取出对应的 SocketChannel
            Channel targetChannel = key.channel();
            //排除自己
            if(targetChannel instanceof  SocketChannel &amp;&amp; targetChannel != self) &#123;
                //转型
                SocketChannel dest = (SocketChannel)targetChannel;
                //将msg 存储到buffer
                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());
                //将buffer 的数据写入 通道
                dest.write(buffer);
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        //创建服务器对象
        Server groupChatServer = new Server();
        groupChatServer.listen();
    &#125;
&#125;
</code></pre>
<h3 id="客户端代码实现"><a href="#客户端代码实现" class="headerlink" title="客户端代码实现"></a>客户端代码实现</h3><pre><code class="java">package com.itheima.chat;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Scanner;

public class Client &#123;
    //定义相关的属性
    private final String HOST = &quot;127.0.0.1&quot;; // 服务器的ip
    private final int PORT = 9999; //服务器端口
    private Selector selector;
    private SocketChannel socketChannel;
    private String username;

    //构造器, 完成初始化工作
    public Client() throws IOException &#123;

        selector = Selector.open();
        //连接服务器
        socketChannel = socketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, PORT));
        //设置非阻塞
        socketChannel.configureBlocking(false);
        //将channel 注册到selector
        socketChannel.register(selector, SelectionKey.OP_READ);
        //得到username
        username = socketChannel.getLocalAddress().toString().substring(1);
        System.out.println(username + &quot; is ok...&quot;);

    &#125;

    //向服务器发送消息
    public void sendInfo(String info) &#123;
        info = username + &quot; 说：&quot; + info;
        try &#123;
            socketChannel.write(ByteBuffer.wrap(info.getBytes()));
        &#125;catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    //读取从服务器端回复的消息
    public void readInfo() &#123;
        try &#123;

            int readChannels = selector.select();
            if(readChannels &gt; 0) &#123;//有可以用的通道

                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();
                while (iterator.hasNext()) &#123;

                    SelectionKey key = iterator.next();
                    if(key.isReadable()) &#123;
                        //得到相关的通道
                       SocketChannel sc = (SocketChannel) key.channel();
                       //得到一个Buffer
                        ByteBuffer buffer = ByteBuffer.allocate(1024);
                        //读取
                        sc.read(buffer);
                        //把读到的缓冲区的数据转成字符串
                        String msg = new String(buffer.array());
                        System.out.println(msg.trim());
                    &#125;
                &#125;
                iterator.remove(); //删除当前的selectionKey, 防止重复操作
            &#125; else &#123;
                //System.out.println(&quot;没有可以用的通道...&quot;);

            &#125;

        &#125;catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public static void main(String[] args) throws Exception &#123;
        //启动我们客户端
        Client chatClient = new Client();
        //启动一个线程, 每个3秒，读取从服务器发送数据
        new Thread() &#123;
            public void run() &#123;

                while (true) &#123;
                    chatClient.readInfo();
                    try &#123;
                        Thread.currentThread().sleep(3000);
                    &#125;catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;
        &#125;.start();

        //发送数据给服务器端
        Scanner scanner = new Scanner(System.in);

        while (scanner.hasNextLine()) &#123;
            String s = scanner.nextLine();
            chatClient.sendInfo(s);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="小结-12"><a href="#小结-12" class="headerlink" title="小结"></a>小结</h3><h1 id="5-JAVA-AIO深入剖析"><a href="#5-JAVA-AIO深入剖析" class="headerlink" title="5  JAVA AIO深入剖析"></a>5  JAVA AIO深入剖析</h1><h2 id="5-1-AIO编程"><a href="#5-1-AIO编程" class="headerlink" title="5.1 AIO编程"></a>5.1 AIO编程</h2><ul>
<li>Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</li>
</ul>
<pre><code class="java">AIO
异步非阻塞，基于NIO的，可以称之为NIO2.0
    BIO                   NIO                              AIO        
Socket                SocketChannel                    AsynchronousSocketChannel
ServerSocket          ServerSocketChannel	       AsynchronousServerSocketChannel
</code></pre>
<p>与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可, 这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区,对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序</p>
<p>即可以理解为，read&#x2F;write方法都是异步的，完成后会主动调用回调函数。在JDK1.7中，这部分内容被称作NIO.2，主要在Java.nio.channels包下增加了下面四个异步通道：</p>
<pre><code class="java">    AsynchronousSocketChannel
    AsynchronousServerSocketChannel
    AsynchronousFileChannel
    AsynchronousDatagramChannel
</code></pre>
<h1 id="6-BIO-NIO-AIO总结"><a href="#6-BIO-NIO-AIO总结" class="headerlink" title="6  BIO,NIO,AIO总结"></a>6  BIO,NIO,AIO总结</h1><p><strong>BIO、NIO、AIO：</strong></p>
<ul>
<li>Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li>
<li>Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I&#x2F;O请求时才启动一个线程进行处理。</li>
<li>Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</li>
</ul>
<p><strong>BIO、NIO、AIO适用场景分析:</strong></p>
<ul>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li>
<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li>
<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持Netty!</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Mercury</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/09/02/blog27/">http://example.com/2023/09/02/blog27/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Mercury个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/IO/">IO</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/16/blog37/" title="Tomcat类加载机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Tomcat类加载机制</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/01/blog4/" title="为什么Redis集群分片最大槽数是16384个"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">为什么Redis集群分片最大槽数是16384个</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODUzMS8zNDk5NA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Mercury</div><div class="author-info__description">与谁同坐。明月清风我</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Mercury4915"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">java学习日记，不定时更新</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-IO%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">1 IO介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E6%95%B4%E4%BD%93%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">通信技术整体解决的问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Java%E7%9A%84I-x2F-O%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF"><span class="toc-number">2.</span> <span class="toc-text">2 Java的I&#x2F;O演进之路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-I-x2F-O-%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E8%AF%B4%E6%98%8E"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 I&#x2F;O 模型基本说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-I-x2F-O%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 I&#x2F;O模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-BIO"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">Java BIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-NIO"><span class="toc-number">2.2.0.2.</span> <span class="toc-text">Java NIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-AIO"><span class="toc-number">2.2.0.3.</span> <span class="toc-text">Java AIO</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-BIO%E3%80%81NIO%E3%80%81AIO-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 BIO、NIO、AIO 适用场景分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-JAVA-BIO%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">3 JAVA BIO深入剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Java-BIO-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 Java BIO 基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Java-BIO-%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 Java BIO 工作机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E4%BC%A0%E7%BB%9F%E7%9A%84BIO%E7%BC%96%E7%A8%8B%E5%AE%9E%E4%BE%8B%E5%9B%9E%E9%A1%BE"><span class="toc-number">3.3.</span> <span class="toc-text">3.3  传统的BIO编程实例回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A1%88%E4%BE%8B%E5%A6%82%E4%B8%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text">客户端案例如下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A1%88%E4%BE%8B%E5%A6%82%E4%B8%8B"><span class="toc-number">3.3.2.</span> <span class="toc-text">服务端案例如下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.3.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-BIO%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%A4%9A%E5%8F%91%E5%92%8C%E5%A4%9A%E6%94%B6%E6%B6%88%E6%81%AF"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 BIO模式下多发和多收消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B"><span class="toc-number">3.4.1.</span> <span class="toc-text">客户端代码如下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B"><span class="toc-number">3.4.2.</span> <span class="toc-text">服务端代码如下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">3.4.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-BIO%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%8E%A5%E6%94%B6%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 BIO模式下接收多个客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">3.5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B"><span class="toc-number">3.5.2.</span> <span class="toc-text">客户端案例代码如下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B"><span class="toc-number">3.5.3.</span> <span class="toc-text">服务端案例代码如下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">3.5.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E4%BC%AA%E5%BC%82%E6%AD%A5I-x2F-O%E7%BC%96%E7%A8%8B"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 伪异步I&#x2F;O编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">3.6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">3.6.2.</span> <span class="toc-text">客户端源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86%E7%B1%BB"><span class="toc-number">3.6.3.</span> <span class="toc-text">线程池处理类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">3.6.4.</span> <span class="toc-text">服务端源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-number">3.6.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E5%9F%BA%E4%BA%8EBIO%E5%BD%A2%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 基于BIO形式下的文件上传</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87"><span class="toc-number">3.7.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91"><span class="toc-number">3.7.2.</span> <span class="toc-text">客户端开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91"><span class="toc-number">3.7.3.</span> <span class="toc-text">服务端开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="toc-number">3.7.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-Java-BIO%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E6%80%9D%E6%83%B3"><span class="toc-number">3.8.</span> <span class="toc-text">3.9 Java BIO模式下的端口转发思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91-1"><span class="toc-number">3.8.1.</span> <span class="toc-text">客户端开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.8.2.</span> <span class="toc-text">服务端实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="toc-number">3.8.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-%E5%9F%BA%E4%BA%8EBIO%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">3.9.</span> <span class="toc-text">3.10 基于BIO模式下即时通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA"><span class="toc-number">3.9.1.</span> <span class="toc-text">项目功能演示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">3.9.1.1.</span> <span class="toc-text">项目案例说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%B8%85%E5%8D%95%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">3.9.1.2.</span> <span class="toc-text">功能清单简单说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E4%B8%8E%E6%BC%94%E7%A4%BA"><span class="toc-number">3.9.1.3.</span> <span class="toc-text">项目启动与演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E5%88%86%E6%9E%90"><span class="toc-number">3.9.1.4.</span> <span class="toc-text">技术选型分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.9.2.</span> <span class="toc-text">服务端设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A5%E6%94%B6%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%BB%E8%BE%91"><span class="toc-number">3.9.2.1.</span> <span class="toc-text">服务端接收多个客户端逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-1"><span class="toc-number">3.9.2.1.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.9.2.1.2.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.9.2.1.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-6"><span class="toc-number">3.9.2.1.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A5%E6%94%B6%E7%99%BB%E9%99%86%E6%B6%88%E6%81%AF%E4%BB%A5%E5%8F%8A%E7%9B%91%E6%B5%8B%E7%A6%BB%E7%BA%BF"><span class="toc-number">3.9.2.2.</span> <span class="toc-text">服务端接收登陆消息以及监测离线</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-2"><span class="toc-number">3.9.2.2.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">3.9.2.2.2.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">3.9.2.2.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-7"><span class="toc-number">3.9.2.2.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A5%E6%94%B6%E7%BE%A4%E8%81%8A%E6%B6%88%E6%81%AF"><span class="toc-number">3.9.2.3.</span> <span class="toc-text">服务端接收群聊消息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-3"><span class="toc-number">3.9.2.3.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4-2"><span class="toc-number">3.9.2.3.2.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">3.9.2.3.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-8"><span class="toc-number">3.9.2.3.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A5%E6%94%B6%E7%A7%81%E8%81%8A%E6%B6%88%E6%81%AF"><span class="toc-number">3.9.2.4.</span> <span class="toc-text">服务端接收私聊消息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-4"><span class="toc-number">3.9.2.4.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4-3"><span class="toc-number">3.9.2.4.2.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">3.9.2.4.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-9"><span class="toc-number">3.9.2.4.4.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.9.3.</span> <span class="toc-text">客户端设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%95%8C%E9%9D%A2-%E7%99%BB%E9%99%86%EF%BC%8C%E5%88%B7%E6%96%B0%E5%9C%A8%E7%BA%BF"><span class="toc-number">3.9.3.1.</span> <span class="toc-text">启动客户端界面 ,登陆，刷新在线</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-5"><span class="toc-number">3.9.3.1.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4-4"><span class="toc-number">3.9.3.1.2.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">3.9.3.1.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-10"><span class="toc-number">3.9.3.1.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E9%80%BB%E8%BE%91"><span class="toc-number">3.9.3.2.</span> <span class="toc-text">客户端发送消息逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-6"><span class="toc-number">3.9.3.2.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4-5"><span class="toc-number">3.9.3.2.2.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">3.9.3.2.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-11"><span class="toc-number">3.9.3.2.4.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-JAVA-NIO%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">4  JAVA NIO深入剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Java-NIO-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 Java NIO 基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-NIO-%E5%92%8C-BIO-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 NIO 和 BIO 的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-NIO-%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 NIO 三大核心原理示意图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.3.1.</span> <span class="toc-text">Buffer缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel%EF%BC%88%E9%80%9A%E9%81%93%EF%BC%89"><span class="toc-number">4.3.2.</span> <span class="toc-text">Channel（通道）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Selector%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">4.3.3.</span> <span class="toc-text">Selector选择器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-NIO%E6%A0%B8%E5%BF%83%E4%B8%80%EF%BC%9A%E7%BC%93%E5%86%B2%E5%8C%BA-Buffer"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 NIO核心一：缓冲区(Buffer)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88Buffer%EF%BC%89"><span class="toc-number">4.4.1.</span> <span class="toc-text">缓冲区（Buffer）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer-%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%AD%90%E7%B1%BB"><span class="toc-number">4.4.2.</span> <span class="toc-text">Buffer 类及其子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7"><span class="toc-number">4.4.3.</span> <span class="toc-text">缓冲区的基本属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.4.</span> <span class="toc-text">Buffer常见方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">4.4.5.</span> <span class="toc-text">缓冲区的数据操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">4.4.6.</span> <span class="toc-text">案例演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%B8%8E%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.4.7.</span> <span class="toc-text">直接与非直接缓冲区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-NIO%E6%A0%B8%E5%BF%83%E4%BA%8C%EF%BC%9A%E9%80%9A%E9%81%93-Channel"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 NIO核心二：通道(Channel)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93Channe%E6%A6%82%E8%BF%B0"><span class="toc-number">4.5.1.</span> <span class="toc-text">通道Channe概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84Channel%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">4.5.2.</span> <span class="toc-text">常用的Channel实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileChannel-%E7%B1%BB"><span class="toc-number">4.5.3.</span> <span class="toc-text">FileChannel 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileChannel%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.5.4.</span> <span class="toc-text">FileChannel的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B1-%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">4.5.5.</span> <span class="toc-text">案例1-本地文件写数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B2-%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="toc-number">4.5.6.</span> <span class="toc-text">案例2-本地文件读数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B3-%E4%BD%BF%E7%94%A8Buffer%E5%AE%8C%E6%88%90%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6"><span class="toc-number">4.5.7.</span> <span class="toc-text">案例3-使用Buffer完成文件复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B4-%E5%88%86%E6%95%A3-Scatter-%E5%92%8C%E8%81%9A%E9%9B%86-Gather"><span class="toc-number">4.5.8.</span> <span class="toc-text">案例4-分散 (Scatter) 和聚集 (Gather)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B5-transferFrom"><span class="toc-number">4.5.9.</span> <span class="toc-text">案例5-transferFrom()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B6-transferTo"><span class="toc-number">4.5.10.</span> <span class="toc-text">案例6-transferTo()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-NIO%E6%A0%B8%E5%BF%83%E4%B8%89%EF%BC%9A%E9%80%89%E6%8B%A9%E5%99%A8-Selector"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 NIO核心三：选择器(Selector)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8-Selector-%E6%A6%82%E8%BF%B0"><span class="toc-number">4.6.1.</span> <span class="toc-text">选择器(Selector)概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9-%E5%99%A8%EF%BC%88Selector%EF%BC%89%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.6.2.</span> <span class="toc-text">选择 器（Selector）的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-NIO%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 NIO非阻塞式网络通信原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Selector-%E7%A4%BA%E6%84%8F%E5%9B%BE%E5%92%8C%E7%89%B9%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="toc-number">4.7.1.</span> <span class="toc-text">Selector 示意图和特点说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B5%81%E7%A8%8B"><span class="toc-number">4.7.2.</span> <span class="toc-text">服务端流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%81%E7%A8%8B"><span class="toc-number">4.7.3.</span> <span class="toc-text">客户端流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-NIO%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">4.8.</span> <span class="toc-text">4.8 NIO非阻塞式网络通信入门案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B"><span class="toc-number">4.8.1.</span> <span class="toc-text">代码案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-NIO-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B-%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.9.</span> <span class="toc-text">4.9  NIO 网络编程应用实例-群聊系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-7"><span class="toc-number">4.9.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.9.2.</span> <span class="toc-text">服务端代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.9.3.</span> <span class="toc-text">客户端代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-12"><span class="toc-number">4.9.4.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-JAVA-AIO%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">5  JAVA AIO深入剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-AIO%E7%BC%96%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 AIO编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-BIO-NIO-AIO%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">6  BIO,NIO,AIO总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/02/blog6/" title="redis主从同步">redis主从同步</a><time datetime="2024-04-02T02:50:44.000Z" title="发表于 2024-04-02 10:50:44">2024-04-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/27/blog49/" title="ElasticSearch性能优化">ElasticSearch性能优化</a><time datetime="2024-02-27T02:18:00.000Z" title="发表于 2024-02-27 10:18:00">2024-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/20/blog48/" title="ES索引文档流程详解">ES索引文档流程详解</a><time datetime="2024-02-20T09:15:44.000Z" title="发表于 2024-02-20 17:15:44">2024-02-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/31/blog2/" title="MySQL索引失效情况">MySQL索引失效情况</a><time datetime="2024-01-31T13:01:53.000Z" title="发表于 2024-01-31 21:01:53">2024-01-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/27/blog47/" title="Redis 性能优化方案">Redis 性能优化方案</a><time datetime="2024-01-27T07:03:34.000Z" title="发表于 2024-01-27 15:03:34">2024-01-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Mercury</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !true) {
  if (true) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>